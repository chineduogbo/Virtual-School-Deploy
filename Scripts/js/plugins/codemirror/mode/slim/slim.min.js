(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror"), require("../htmlmixed/htmlmixed"), require("../ruby/ruby")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror", "../htmlmixed/htmlmixed", "../ruby/ruby"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("slim", function (t) { function vt(n, t, i) { var r = function (r, u) { return (u.tokenize = t, r.pos < n) ? (r.pos = n, i) : u.tokenize(r, u) }; return function (n, i) { return i.tokenize = r, t(n, i) } } function yt(n, t, i, r, u) { var f = n.current(), e = f.search(i); return e > -1 && (t.tokenize = vt(n.pos, t.tokenize, u), n.backUp(f.length - e - r)), u } function a(n, t) { n.stack = { parent: n.stack, style: "continuation", indented: t, tokenize: n.line }; n.line = n.tokenize } function v(n) { n.line == n.tokenize && (n.line = n.stack.tokenize, n.stack = n.stack.parent) } function pt(n, t) { return function (i, r) { if (v(r), i.match(/^\\$/)) return a(r, n), "lineContinuation"; var u = t(i, r); return i.eol() && i.current().match(/(?:^|[^\\])(?:\\\\)*\\$/) && i.backUp(1), u } } function wt(n, t) { return function (i, r) { v(r); var u = t(i, r); return i.eol() && i.current().match(/,$/) && a(r, n), u } } function y(n, t) { return function (i, r) { var u = i.peek(); return u == n && r.rubyState.tokenize.length == 1 ? (i.next(), r.tokenize = t, "closeAttributeTag") : e(i, r) } } function i(n) { var t, i = function (i, r) { if (r.rubyState.tokenize.length == 1 && !r.rubyState.context.prev) { if (i.backUp(1), i.eatSpace()) return r.rubyState = t, r.tokenize = n, n(i, r); i.next() } return e(i, r) }; return function (n, r) { return t = r.rubyState, r.rubyState = f.startState(), r.tokenize = i, e(n, r) } } function e(n, t) { return f.token(n, t.rubyState) } function bt(n, t) { return n.match(/^\\$/) ? "lineContinuation" : d(n, t) } function d(n, t) { return n.match(/^#\{/) ? (t.tokenize = y("}", t.tokenize), null) : yt(n, t, /[^\\]#\{/, 1, s.token(n, t.htmlState)) } function kt(n) { return function (t, i) { var r = bt(t, i); return t.eol() && (i.tokenize = n), r } } function g(n, t, i) { return t.stack = { parent: t.stack, style: "html", indented: n.column() + i, tokenize: t.line }, t.line = t.tokenize = d, null } function nt(n, t) { return n.skipToEnd(), t.stack.style } function dt(n, t) { return t.stack = { parent: t.stack, style: "comment", indented: t.indented + 1, tokenize: t.line }, t.line = nt, nt(n, t) } function u(n, t) { return n.eat(t.stack.endQuote) ? (t.line = t.stack.line, t.tokenize = t.stack.tokenize, t.stack = t.stack.parent, null) : n.match(ct) ? (t.tokenize = gt, "slimAttribute") : (n.next(), null) } function gt(n, t) { return n.match(/^==?/) ? (t.tokenize = ni, null) : u(n, t) } function ni(n, t) { var r = n.peek(); return r == '"' || r == "'" ? (t.tokenize = rt(r, "string", !0, !1, u), n.next(), t.tokenize(n, t)) : r == "[" ? i(u)(n, t) : n.match(/^(true|false|nil)\b/) ? (t.tokenize = u, "keyword") : i(u)(n, t) } function ti(n, t, i) { return n.stack = { parent: n.stack, style: "wrapper", indented: n.indented + 1, tokenize: i, line: n.line, endQuote: t }, n.line = n.tokenize = u, null } function ii(t, i) { var r, u; return t.match(/^#\{/) ? (i.tokenize = y("}", i.tokenize), null) : (r = new n.StringStream(t.string.slice(i.stack.indented), t.tabSize), r.pos = t.pos - i.stack.indented, r.start = t.start - i.stack.indented, r.lastColumnPos = t.lastColumnPos - i.stack.indented, r.lastColumnValue = t.lastColumnValue - i.stack.indented, u = i.subMode.token(r, i.subState), t.pos = r.pos + i.stack.indented, u) } function ri(n, t) { return t.stack.indented = n.column(), t.line = t.tokenize = ii, t.tokenize(n, t) } function ui(i) { var r = b[i], f = n.mimeModes[r], u; return f ? n.getMode(t, f) : (u = n.modes[r], u) ? u(t, { name: r }) : n.getMode(t, "null") } function fi(n) { return l.hasOwnProperty(n) ? l[n] : l[n] = ui(n) } function ei(n, t) { var i = fi(n), r = i.startState && i.startState(); return t.subMode = i, t.subState = r, t.stack = { parent: t.stack, style: "sub", indented: t.indented + 1, tokenize: t.line }, t.line = t.tokenize = ri, "slimSubmode" } function oi(n) { return n.skipToEnd(), "slimDoctype" } function si(n, t) { var r = n.peek(), i; return r == "<" ? (t.tokenize = kt(t.tokenize))(n, t) : n.match(/^[|']/) ? g(n, t, 1) : n.match(/^\/(!|\[\w+])?/) ? dt(n, t) : n.match(/^(-|==?[<>]?)/) ? (t.tokenize = pt(n.column(), wt(n.column(), e)), "slimSwitch") : n.match(/^doctype\b/) ? (t.tokenize = oi, "keyword") : (i = n.match(et), i) ? ei(i[1], t) : w(n, t) } function p(n, t) { return t.startOfLine ? si(n, t) : w(n, t) } function w(n, t) { return n.eat("*") ? (t.tokenize = i(tt), null) : n.match(st) ? (t.tokenize = tt, "slimTag") : o(n, t) } function tt(n, t) { return n.match(/^(<>?|><?)/) ? (t.tokenize = o, null) : o(n, t) } function o(n, t) { return n.match(at) ? (t.tokenize = o, "slimId") : n.match(lt) ? (t.tokenize = o, "slimClass") : r(n, t) } function r(n, t) { return n.match(/^([\[\{\(])/) ? ti(t, ot[RegExp.$1], r) : n.match(ht) ? (t.tokenize = hi, "slimAttribute") : n.peek() == "*" ? (n.next(), t.tokenize = i(ut), null) : ut(n, t) } function hi(n, t) { return n.match(/^==?/) ? (t.tokenize = ci, null) : r(n, t) } function ci(n, t) { var u = n.peek(); return u == '"' || u == "'" ? (t.tokenize = rt(u, "string", !0, !1, r), n.next(), t.tokenize(n, t)) : u == "[" ? i(r)(n, t) : u == ":" ? i(it)(n, t) : n.match(/^(true|false|nil)\b/) ? (t.tokenize = r, "keyword") : i(r)(n, t) } function it(n, t) { return (n.backUp(1), n.match(/^[^\s],(?=:)/)) ? (t.tokenize = i(it), null) : (n.next(), r(n, t)) } function rt(n, t, i, r, u) { return function (f, e) { var s, o, h; if (v(e), s = f.current().length == 0, f.match(/^\\$/, s)) return s ? (a(e, e.indented), "lineContinuation") : t; if (f.match(/^#\{/, s)) return s ? (e.tokenize = y("}", e.tokenize), null) : t; for (o = !1; (h = f.next()) != null;) { if (h == n && (r || !o)) { e.tokenize = u; break } if (i && h == "#" && !o && f.eat("{")) { f.backUp(2); break } o = !o && h == "\\" } return f.eol() && o && f.backUp(1), t } } function ut(n, t) { return n.match(/^==?/) ? (t.tokenize = e, "slimSwitch") : n.match(/^\/$/) ? (t.tokenize = p, null) : n.match(/^:/) ? (t.tokenize = w, "slimSwitch") : (g(n, t, 0), t.tokenize(n, t)) } var s = n.getMode(t, { name: "htmlmixed" }), f = n.getMode(t, "ruby"), l = { html: s, ruby: f }, b = { ruby: "ruby", javascript: "javascript", css: "text/css", sass: "text/x-sass", scss: "text/x-scss", less: "text/x-less", styl: "text/x-styl", coffee: "coffeescript", asciidoc: "text/x-asciidoc", markdown: "text/x-markdown", textile: "text/x-textile", creole: "text/x-creole", wiki: "text/x-wiki", mediawiki: "text/x-mediawiki", rdoc: "text/x-rdoc", builder: "text/x-builder", nokogiri: "text/x-nokogiri", erb: "application/x-erb" }, et = function (n) { var t = []; for (var i in n) t.push(i); return new RegExp("^(" + t.join("|") + "):") }(b), k = { commentLine: "comment", slimSwitch: "operator special", slimTag: "tag", slimId: "attribute def", slimClass: "attribute qualifier", slimAttribute: "attribute", slimSubmode: "keyword special", closeAttributeTag: null, slimDoctype: null, lineContinuation: null }, ot = { "{": "}", "[": "]", "(": ")" }, h = "_a-zA-ZÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�", c = h + "\\-0-9·̀-ͯ‿-⁀", st = new RegExp("^[:" + h + "](?::[" + c + "]|[" + c + "]*)"), ht = new RegExp("^[:" + h + "][:\\." + c + "]*(?=\\s*=)"), ct = new RegExp("^[:" + h + "][:\\." + c + "]*"), lt = /^\.-?[_a-zA-Z]+[\w\-]*/, at = /^#[_a-zA-Z]+[\w\-]*/, ft = { startState: function () { var n = s.startState(), t = f.startState(); return { htmlState: n, rubyState: t, stack: null, last: null, tokenize: p, line: p, indented: 0 } }, copyState: function (t) { return { htmlState: n.copyState(s, t.htmlState), rubyState: n.copyState(f, t.rubyState), subMode: t.subMode, subState: t.subMode && n.copyState(t.subMode, t.subState), stack: t.stack, last: t.last, tokenize: t.tokenize, line: t.line } }, token: function (n, t) { if (n.sol()) for (t.indented = n.indentation(), t.startOfLine = !0, t.tokenize = t.line; t.stack && t.stack.indented > t.indented && t.last != "slimSubmode";) t.line = t.tokenize = t.stack.tokenize, t.stack = t.stack.parent, t.subMode = null, t.subState = null; if (n.eatSpace()) return null; var i = t.tokenize(n, t); return t.startOfLine = !1, i && (t.last = i), k.hasOwnProperty(i) ? k[i] : i }, blankLine: function (n) { if (n.subMode && n.subMode.blankLine) return n.subMode.blankLine(n.subState) }, innerMode: function (n) { return n.subMode ? { state: n.subState, mode: n.subMode } : { state: n, mode: ft } } }; return ft }, "htmlmixed", "ruby"); n.defineMIME("text/x-slim", "slim"); n.defineMIME("application/x-slim", "slim") });
//# sourceMappingURL=slim.min.js.map