(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("rust", function () { function h(n, t) { return p = n, t } function g(n, i) { var r = n.next(), u; if (r == '"') return i.tokenize = ri, i.tokenize(n, i); if (r == "'") return p = "atom", n.eat("\\") ? n.skipTo("'") ? (n.next(), "string") : "error" : (n.next(), n.eat("'") ? "string" : "error"); if (r == "/") { if (n.eat("/")) return n.skipToEnd(), "comment"; if (n.eat("*")) return i.tokenize = ft(1), i.tokenize(n, i) } return r == "#" ? n.eat("[") ? (p = "open-attr", null) : (n.eatWhile(/\w/), h("macro", "meta")) : r == ":" && n.match(":<") ? h("op", null) : r.match(/\d/) || r == "." && n.eat(/\d/) ? (u = !1, n.match(/^x[\da-f]+/i) || n.match(/^b[01]+/) || (n.eatWhile(/\d/), n.eat(".") && (u = !0, n.eatWhile(/\d/)), n.match(/^e[+\-]?\d+/i) && (u = !0)), u ? n.match(/^f(?:32|64)/) : n.match(/^[ui](?:8|16|32|64)/), h("atom", "number")) : r.match(/[()\[\]{}:;,]/) ? h(r, null) : r == "-" && n.eat(">") ? h("->", null) : r.match(at) ? (n.eatWhile(at), h("op", null)) : (n.eatWhile(/\w/), t = n.current(), n.match(/^::\w/)) ? (n.backUp(1), h("prefix", "variable-2")) : i.keywords.propertyIsEnumerable(t) ? h(i.keywords[t], t.match(/true|false/) ? "atom" : "keyword") : h("name", "variable") } function ri(n, t) { for (var i, r = !1; i = n.next() ;) { if (i == '"' && !r) return t.tokenize = g, h("atom", "string"); r = !r && i == "\\" } return h("op", "string") } function ft(n) { return function (t, i) { for (var u = null, r; r = t.next() ;) { if (r == "/" && u == "*") if (n == 1) { i.tokenize = g; break } else return i.tokenize = ft(n - 1), i.tokenize(t, i); if (r == "*" && u == "/") return i.tokenize = ft(n + 1), i.tokenize(t, i); u = r } return "comment" } } function r() { for (var n = arguments.length - 1; n >= 0; n--) i.cc.push(arguments[n]) } function n() { return r.apply(null, arguments), !0 } function f(n, t) { var r = function () { var r = i.state; r.lexical = { indented: r.indented, column: i.stream.column(), type: n, prev: r.lexical, info: t } }; return r.lex = !0, r } function u() { var n = i.state; n.lexical.prev && (n.lexical.type == ")" && (n.indented = n.lexical.indented), n.lexical = n.lexical.prev) } function a() { i.state.keywords = ii } function v() { i.state.keywords = lt } function y(t, i) { function u(r) { return r == "," ? n(t, u) : r == i ? n() : n(u) } return function (f) { return f == i ? n() : r(t, u) } } function w(t, i) { return n(f("stat", i), t, u, s) } function s(t) { return t == "}" ? n() : t == "let" ? w(nt, "let") : t == "fn" ? w(l) : t == "type" ? n(f("stat"), tt, et, u, s) : t == "enum" ? w(it) : t == "mod" ? w(wt) : t == "iface" ? w(ct) : t == "impl" ? w(rt) : t == "open-attr" ? n(f("]"), y(e, "]"), u) : t == "ignore" || t.match(/[\]\);,]/) ? n(s) : r(f("stat"), e, u, et, s) } function et(t) { return t == ";" ? n() : r() } function e(t) { return t == "atom" || t == "name" ? n(ot) : t == "{" ? n(f("}"), fi, u) : t.match(/[\[\(]/) ? d(t, e) : t.match(/[\]\)\};,]/) ? r() : t == "if-style" ? n(e, e) : t == "else-style" || t == "op" ? n(e) : t == "for" ? n(b, pt, ei, e, e) : t == "alt" ? n(e, oi) : t == "fn" ? n(l) : t == "macro" ? n(si) : n() } function ot(i) { return t == "." ? n(ui) : t == "::<" ? n(c, ot) : i == "op" || t == ":" ? n(e) : i == "(" || i == "[" ? d(i, e) : r() } function ui() { return t.match(/^\w+$/) ? (i.marked = "variable", n(ot)) : r(e) } function fi(o) { if (o == "op") { if (t == "|") return n(st, u, f("}", "block"), s); if (t == "||") return n(u, f("}", "block"), s) } return t == "mutable" || t.match(/^\w+$/) && i.stream.peek() == ":" && !i.stream.match("::", !1) ? r(vt(e)) : r(s) } function vt(r) { function u(f) { return t == "mutable" || t == "with" ? (i.marked = "keyword", n(u)) : t.match(/^\w*$/) ? (i.marked = "variable", n(u)) : f == ":" ? n(r, u) : f == "}" ? n() : n(u) } return u } function st(r) { return r == "name" ? (i.marked = "def", n(st)) : r == "op" && t == "|" ? n() : n(st) } function nt(i) { return i.match(/[\]\)\};]/) ? n() : t == "=" ? n(e, yt) : i == "," ? n(nt) : r(b, pt, nt) } function yt(n) { return n.match(/[\]\)\};,]/) ? r(nt) : r(e, yt) } function pt(t) { return t == ":" ? n(a, o, v) : r() } function ei(u) { return u == "name" && t == "in" ? (i.marked = "keyword", n()) : r() } function l(s) { return t == "@" || t == "~" ? (i.marked = "keyword", n(l)) : s == "name" ? (i.marked = "def", n(l)) : t == "<" ? n(c, l) : s == "{" ? r(e) : s == "(" ? n(f(")"), y(bt, ")"), u, l) : s == "->" ? n(a, o, v, l) : s == ";" ? n() : n(l) } function tt(r) { return r == "name" ? (i.marked = "def", n(tt)) : t == "<" ? n(c, tt) : t == "=" ? n(a, o, v) : n(tt) } function it(r) { return r == "name" ? (i.marked = "def", n(it)) : t == "<" ? n(c, it) : t == "=" ? n(a, o, v, et) : r == "{" ? n(f("}"), a, ht, v, u) : n(it) } function ht(r) { return r == "}" ? n() : r == "(" ? n(f(")"), y(o, ")"), u, ht) : (t.match(/^\w+$/) && (i.marked = "def"), n(ht)) } function wt(t) { return t == "name" ? (i.marked = "def", n(wt)) : t == "{" ? n(f("}"), s, u) : r() } function ct(e) { return e == "name" ? (i.marked = "def", n(ct)) : t == "<" ? n(c, ct) : e == "{" ? n(f("}"), s, u) : r() } function rt(e) { return t == "<" ? n(c, rt) : t == "of" || t == "for" ? (i.marked = "keyword", n(o, rt)) : e == "name" ? (i.marked = "def", n(rt)) : e == "{" ? n(f("}"), s, u) : r() } function c() { return t == ">" ? n() : t == "," ? n(c) : t == ":" ? n(o, c) : r(o, c) } function bt(t) { return t == "name" ? (i.marked = "def", n(bt)) : t == ":" ? n(a, o, v) : r() } function o(r) { return r == "name" ? (i.marked = "variable-3", n(kt)) : t == "mutable" ? (i.marked = "keyword", n(o)) : r == "atom" ? n(kt) : r == "op" || r == "obj" ? n(o) : r == "fn" ? n(dt) : r == "{" ? n(f("{"), vt(o), u) : d(r, o) } function kt() { return t == "<" ? n(c) : r() } function dt(t) { return t == "(" ? n(f("("), y(o, ")"), u, dt) : t == "->" ? n(o) : r() } function b(t) { return t == "name" ? (i.marked = "def", n(gt)) : t == "atom" ? n(gt) : t == "op" ? n(b) : t.match(/[\]\)\};,]/) ? r() : d(t, b) } function gt(u) { return u == "op" && t == "." ? n() : t == "to" ? (i.marked = "keyword", n(b)) : r() } function oi(t) { return t == "{" ? n(f("}", "alt"), k, u) : r() } function k(u) { return u == "}" ? n() : u == "|" ? n(k) : t == "when" ? (i.marked = "keyword", n(e, ni)) : u.match(/[\]\);,]/) ? n(k) : r(b, ni) } function ni(t) { return t == "{" ? n(f("}", "alt"), s, u, k) : r(k) } function si(n) { return n.match(/[\[\(\{]/) ? d(n, e) : r() } function d(t, i) { return t == "[" ? n(f("]"), y(i, "]"), u) : t == "(" ? n(f(")"), y(i, ")"), u) : t == "{" ? n(f("}"), y(i, "}"), u) : n() } function hi(n, t, r) { var u = n.cc, f; for (i.state = n, i.stream = t, i.marked = null, i.cc = u; ;) if (f = u.length ? u.pop() : s, f(p)) { while (u.length && u[u.length - 1].lex) u.pop()(); return i.marked || r } } var ut = 4, ti = 2, lt = { "if": "if-style", "while": "if-style", "else": "else-style", "do": "else-style", ret: "else-style", fail: "else-style", "break": "atom", cont: "atom", "const": "let", resource: "fn", "let": "let", fn: "fn", "for": "for", alt: "alt", iface: "iface", impl: "impl", type: "type", "enum": "enum", mod: "mod", as: "op", "true": "atom", "false": "atom", assert: "op", check: "op", claim: "op", "native": "ignore", unsafe: "ignore", "import": "else-style", "export": "else-style", copy: "op", log: "op", log_err: "op", use: "op", bind: "op", self: "atom" }, ii = function () { for (var t = { fn: "fn", block: "fn", obj: "obj" }, i = "bool uint int i8 i16 i32 i64 u8 u16 u32 u64 float f32 f64 str char".split(" "), n = 0, r = i.length; n < r; ++n) t[i[n]] = "atom"; return t }(), at = /[+\-*&%=<>!?|\.@]/, p, t, i = { state: null, stream: null, marked: null, cc: null }; return u.lex = a.lex = v.lex = !0, { startState: function () { return { tokenize: g, cc: [], lexical: { indented: -ut, column: 0, type: "top", align: !1 }, keywords: lt, indented: 0 } }, token: function (n, i) { if (n.sol() && (i.lexical.hasOwnProperty("align") || (i.lexical.align = !1), i.indented = n.indentation()), n.eatSpace()) return null; p = t = null; var r = i.tokenize(n, i); return r == "comment" ? r : (i.lexical.hasOwnProperty("align") || (i.lexical.align = !0), p == "prefix") ? r : (t || (t = n.current()), hi(i, n, r)) }, indent: function (n, t) { if (n.tokenize != g) return 0; var f = t && t.charAt(0), i = n.lexical, r = i.type, u = f == r; return r == "stat" ? i.indented + ut : i.align ? i.column + (u ? 0 : 1) : i.indented + (u ? 0 : i.info == "alt" ? ti : ut) }, electricChars: "{}", blockCommentStart: "/*", blockCommentEnd: "*/", lineComment: "//", fold: "brace" } }); n.defineMIME("text/x-rustsrc", "rust") });
//# sourceMappingURL=rust.min.js.map