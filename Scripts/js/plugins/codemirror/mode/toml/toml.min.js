(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("toml", function () { return { startState: function () { return { inString: !1, stringType: "", lhs: !0, inArray: 0 } }, token: function (n, t) { if (t.inString || n.peek() != '"' && n.peek() != "'" || (t.stringType = n.peek(), n.next(), t.inString = !0), n.sol() && t.inArray === 0 && (t.lhs = !0), t.inString) { while (t.inString && !n.eol()) n.peek() === t.stringType ? (n.next(), t.inString = !1) : n.peek() === "\\" ? (n.next(), n.next()) : n.match(/^.[^\\\"\']*/); return t.lhs ? "property string" : "string" } if (t.inArray && n.peek() === "]") return n.next(), t.inArray--, "bracket"; if (t.lhs && n.peek() === "[" && n.skipTo("]")) return n.next(), n.peek() === "]" && n.next(), "atom"; if (n.peek() === "#") return n.skipToEnd(), "comment"; if (n.eatSpace()) return null; if (t.lhs && n.eatWhile(function (n) { return n != "=" && n != " " })) return "property"; if (t.lhs && n.peek() === "=") return n.next(), t.lhs = !1, null; if (!t.lhs && n.match(/^\d\d\d\d[\d\-\:\.T]*Z/) || !t.lhs && (n.match("true") || n.match("false"))) return "atom"; if (t.lhs || n.peek() !== "[") { if (!t.lhs && n.match(/^\-?\d+(?:\.\d+)?/)) return "number"; n.eatSpace() || n.next() } else return t.inArray++, n.next(), "bracket"; return null } } }); n.defineMIME("text/x-toml", "toml") });
//# sourceMappingURL=toml.min.js.map