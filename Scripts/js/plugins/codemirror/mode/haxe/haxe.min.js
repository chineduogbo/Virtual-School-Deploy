(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("haxe", function (n, t) { function ft(n, t, i) { return t.tokenize = i, i(n, t) } function et(n, t) { for (var i = !1, r; (r = n.next()) != null;) { if (r == t && !i) return !1; i = !i && r == "\\" } return i } function o(n, t, i) { return a = n, ot = i, t } function w(n, t) { var i = n.next(), r, u; return i == '"' || i == "'" ? ft(n, t, wt(i)) : /[\[\]{}\(\),;\:\.]/.test(i) ? o(i) : i == "0" && n.eat(/x/i) ? (n.eatWhile(/[\da-f]/i), o("number", "number")) : /\d/.test(i) || i == "-" && n.eat(/\d/) ? (n.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/), o("number", "number")) : t.reAllowed && i == "~" && n.eat(/\//) ? (et(n, "/"), n.eatWhile(/[gimsu]/), o("regexp", "string-2")) : i == "/" ? n.eat("*") ? ft(n, t, bt) : n.eat("/") ? (n.skipToEnd(), o("comment", "comment")) : (n.eatWhile(nt), o("operator", null, n.current())) : i == "#" ? (n.skipToEnd(), o("conditional", "meta")) : i == "@" ? (n.eat(/:/), n.eatWhile(/[\w_]/), o("metadata", "meta")) : nt.test(i) ? (n.eatWhile(nt), o("operator", null, n.current())) : /[A-Z]/.test(i) ? (n.eatWhile(/[\w_<>]/), r = n.current(), o("type", "variable-3", r)) : (n.eatWhile(/[\w_]/), r = n.current(), u = ut.propertyIsEnumerable(r) && ut[r], u && t.kwAllowed ? o(u.type, u.style, r) : o("variable", "variable", r)) } function wt(n) { return function (t, i) { return et(t, n) || (i.tokenize = w), o("string", "string") } } function bt(n, t) { for (var r = !1, i; i = n.next() ;) { if (i == "/" && r) { t.tokenize = w; break } r = i == "*" } return o("comment", "comment") } function ht(n, t, i, r, u, f) { this.indented = n; this.column = t; this.type = i; this.prev = u; this.info = f; r != null && (this.align = r) } function kt(n, t) { for (var i = n.localVars; i; i = i.next) if (i.name == t) return !0 } function dt(n, t, i, u, f) { var e = n.cc, o; for (r.state = n, r.stream = f, r.marked = null, r.cc = e, n.lexical.hasOwnProperty("align") || (n.lexical.align = !0) ; ;) if (o = e.length ? e.pop() : h, o(i, u)) { while (e.length && e[e.length - 1].lex) e.pop()(); return r.marked ? r.marked : i == "variable" && kt(n, u) ? "variable-2" : i == "variable" && gt(n, u) ? "variable-3" : t } } function gt(n, t) { var r, i; if (/[a-z]/.test(t.charAt(0))) return !1; for (r = n.importedtypes.length, i = 0; i < r; i++) if (n.importedtypes[i] == t) return !0 } function ct(n) { for (var i = r.state, t = i.importedtypes; t; t = t.next) if (t.name == n) return; i.importedtypes = { name: n, next: i.importedtypes } } function l() { for (var n = arguments.length - 1; n >= 0; n--) r.cc.push(arguments[n]) } function i() { return l.apply(null, arguments), !0 } function b(n) { var i = r.state, t; if (i.context) { for (r.marked = "def", t = i.localVars; t; t = t.next) if (t.name == n) return; i.localVars = { name: n, next: i.localVars } } } function k() { r.state.context || (r.state.localVars = ni); r.state.context = { prev: r.state.context, vars: r.state.localVars } } function d() { r.state.localVars = r.state.context.vars; r.state.context = r.state.context.prev } function f(n, t) { var i = function () { var i = r.state; i.lexical = new ht(i.indented, r.stream.column(), n, null, i.lexical, t) }; return i.lex = !0, i } function u() { var n = r.state; n.lexical.prev && (n.lexical.type == ")" && (n.indented = n.lexical.indented), n.lexical = n.lexical.prev) } function e(n) { function t(r) { return r == n ? i() : n == ";" ? l() : i(t) } return t } function h(n) { return n == "@" ? i(tt) : n == "var" ? i(f("vardef"), rt, e(";"), u) : n == "keyword a" ? i(f("form"), s, h, u) : n == "keyword b" ? i(f("form"), h, u) : n == "{" ? i(f("}"), k, it, u, d) : n == ";" ? i() : n == "attribute" ? i(at) : n == "function" ? i(p) : n == "for" ? i(f("form"), e("("), f(")"), ei, e(")"), u, h, u) : n == "variable" ? i(f("stat"), ri) : n == "switch" ? i(f("form"), s, f("}", "switch"), e("{"), it, u, u) : n == "case" ? i(s, e(":")) : n == "default" ? i(e(":")) : n == "catch" ? i(f("form"), k, e("("), pt, e(")"), h, u, d) : n == "import" ? i(vt, e(";")) : n == "typedef" ? i(ii) : l(f("stat"), s, e(";"), u) } function s(n) { return st.hasOwnProperty(n) ? i(c) : n == "function" ? i(p) : n == "keyword c" ? i(lt) : n == "(" ? i(f(")"), lt, e(")"), u, c) : n == "operator" ? i(s) : n == "[" ? i(f("]"), v(s, "]"), u, c) : n == "{" ? i(f("}"), v(fi, "}"), u, c) : i() } function lt(n) { return n.match(/[;\}\)\],]/) ? l() : l(s) } function c(n, t) { return n == "operator" && /\+\+|--/.test(t) ? i(c) : n == "operator" || n == ":" ? i(s) : n == ";" ? void 0 : n == "(" ? i(f(")"), v(s, ")"), u, c) : n == "." ? i(ui, c) : n == "[" ? i(f("]"), s, e("]"), u, c) : void 0 } function at(n) { return n == "attribute" ? i(at) : n == "function" ? i(p) : n == "var" ? i(rt) : void 0 } function tt(n) { return n == ":" ? i(tt) : n == "variable" ? i(tt) : n == "(" ? i(f(")"), v(ti, ")"), u, h) : void 0 } function ti(n) { if (n == "variable") return i() } function vt(n, t) { return n == "variable" && /[A-Z]/.test(t.charAt(0)) ? (ct(t), i()) : n == "variable" || n == "property" || n == "." || t == "*" ? i(vt) : void 0 } function ii(n, t) { return n == "variable" && /[A-Z]/.test(t.charAt(0)) ? (ct(t), i()) : n == "type" && /[A-Z]/.test(t.charAt(0)) ? i() : void 0 } function ri(n) { return n == ":" ? i(u, h) : l(c, e(";"), u) } function ui(n) { if (n == "variable") return r.marked = "property", i() } function fi(n) { return n == "variable" && (r.marked = "property"), st.hasOwnProperty(n) ? i(e(":"), s) : void 0 } function v(n, t) { function r(u) { return u == "," ? i(n, r) : u == t ? i() : i(e(t)) } return function (u) { return u == t ? i() : l(n, r) } } function it(n) { return n == "}" ? i() : l(h, it) } function rt(n, t) { return n == "variable" ? (b(t), i(g, yt)) : i() } function yt(n, t) { return t == "=" ? i(s, yt) : n == "," ? i(rt) : void 0 } function ei(n, t) { return n == "variable" && b(t), i(f(")"), k, oi, s, u, h, d) } function oi(n, t) { if (t == "in") return i() } function p(n, t) { return n == "variable" ? (b(t), i(p)) : t == "new" ? i(p) : n == "(" ? i(f(")"), k, v(pt, ")"), u, g, h, d) : void 0 } function g(n) { if (n == ":") return i(si) } function si(n) { return n == "type" ? i() : n == "variable" ? i() : n == "{" ? i(f("}"), v(hi, "}"), u) : void 0 } function hi(n) { if (n == "variable") return i(g) } function pt(n, t) { if (n == "variable") return b(t), i(g) } var y = n.indentUnit, ut = function () { function n(n) { return { type: n, style: "keyword" } } var e = n("keyword a"), u = n("keyword b"), i = n("keyword c"), o = n("operator"), f = { type: "atom", style: "atom" }, r = { type: "attribute", style: "attribute" }, t = n("typedef"); return { "if": e, "while": e, "else": u, "do": u, "try": u, "return": i, "break": i, "continue": i, "new": i, "throw": i, "var": n("var"), inline: r, "static": r, using: n("import"), "public": r, "private": r, cast: n("cast"), "import": n("import"), macro: n("macro"), "function": n("function"), "catch": n("catch"), untyped: n("untyped"), callback: n("cb"), "for": n("for"), "switch": n("switch"), "case": n("case"), "default": n("default"), "in": o, never: n("property_access"), trace: n("trace"), "class": t, abstract: t, "enum": t, "interface": t, typedef: t, "extends": t, "implements": t, dynamic: t, "true": f, "false": f, "null": f } }(), nt = /[+\-*&%=<>!?|]/, a, ot, st = { atom: !0, number: !0, variable: !0, string: !0, regexp: !0 }, r = { state: null, column: null, marked: null, cc: null }, ni = { name: "this", next: null }; return u.lex = !0, { startState: function (n) { return { tokenize: w, reAllowed: !0, kwAllowed: !0, cc: [], lexical: new ht((n || 0) - y, 0, "block", !1), localVars: t.localVars, importedtypes: ["Int", "Float", "String", "Void", "Std", "Bool", "Dynamic", "Array"], context: t.localVars && { vars: t.localVars }, indented: 0 } }, token: function (n, t) { if (n.sol() && (t.lexical.hasOwnProperty("align") || (t.lexical.align = !1), t.indented = n.indentation()), n.eatSpace()) return null; var i = t.tokenize(n, t); return a == "comment" ? i : (t.reAllowed = !!(a == "operator" || a == "keyword c" || a.match(/^[\[{}\(,;:]$/)), t.kwAllowed = a != ".", dt(t, i, a, ot, n)) }, indent: function (n, t) { var u, i, r, f; return n.tokenize != w ? 0 : (u = t && t.charAt(0), i = n.lexical, i.type == "stat" && u == "}" && (i = i.prev), r = i.type, f = u == r, r == "vardef" ? i.indented + 4 : r == "form" && u == "{" ? i.indented : r == "stat" || r == "form" ? i.indented + y : i.info != "switch" || f ? i.align ? i.column + (f ? 0 : 1) : i.indented + (f ? 0 : y) : i.indented + (/^(?:case|default)\b/.test(t) ? y : 2 * y)) }, electricChars: "{}", blockCommentStart: "/*", blockCommentEnd: "*/", lineComment: "//" } }); n.defineMIME("text/x-haxe", "haxe"); n.defineMode("hxml", function () { return { startState: function () { return { define: !1, inString: !1 } }, token: function (n, t) { var i = n.peek(), u = n.sol(), r; return i == "#" ? (n.skipToEnd(), "comment") : u && i == "-" ? (r = "variable-2", n.eat(/-/), n.peek() == "-" && (n.eat(/-/), r = "keyword a"), n.peek() == "D" && (n.eat(/[D]/), r = "keyword c", t.define = !0), n.eatWhile(/[A-Z]/i), r) : (i = n.peek(), t.inString == !1 && i == "'" && (t.inString = !0, i = n.next()), t.inString == !0) ? (n.skipTo("'") || n.skipToEnd(), n.peek() == "'" && (n.next(), t.inString = !1), "string") : (n.next(), null) }, lineComment: "#" } }); n.defineMIME("text/x-hxml", "hxml") });
//# sourceMappingURL=haxe.min.js.map