(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("smarty", function (n) { var i = { rightDelimiter: "}", leftDelimiter: "{", smartyVersion: 2 }; n.hasOwnProperty("leftDelimiter") && (i.leftDelimiter = n.leftDelimiter); n.hasOwnProperty("rightDelimiter") && (i.rightDelimiter = n.rightDelimiter); n.hasOwnProperty("smartyVersion") && n.smartyVersion === 3 && (i.smartyVersion = 3); var e = ["debug", "extends", "function", "include", "literal"], f, r = { operatorChars: /[+\-*&%=<>!?]/, validIdentifier: /[a-zA-Z0-9_]/, stringChar: /['"]/ }, t = { cont: function (n, t) { return f = t, n }, chain: function (n, t, i) { return t.tokenize = i, i(n, t) } }, u = { tokenizer: function (n, r) { if (n.match(i.leftDelimiter, !0)) { if (n.eat("*")) return t.chain(n, r, u.inBlock("comment", "*" + i.rightDelimiter)); r.depth++; var e = n.eol(), o = /\s/.test(n.peek()); return i.smartyVersion === 3 && i.leftDelimiter === "{" && (e || o) ? (r.depth--, null) : (r.tokenize = u.smarty, f = "startTag", "tag") } return n.next(), null }, smarty: function (n, o) { var s, h, l, c, a; if (n.match(i.rightDelimiter, !0)) return i.smartyVersion === 3 ? (o.depth--, o.depth <= 0 && (o.tokenize = u.tokenizer)) : o.tokenize = u.tokenizer, t.cont("tag", null); if (n.match(i.leftDelimiter, !0)) return o.depth++, t.cont("tag", "startTag"); if (s = n.next(), s == "$") return n.eatWhile(r.validIdentifier), t.cont("variable-2", "variable"); if (s == "|") return t.cont("operator", "pipe"); if (s == ".") return t.cont("operator", "property"); if (r.stringChar.test(s)) return o.tokenize = u.inAttribute(s), t.cont("string", "string"); if (r.operatorChars.test(s)) return n.eatWhile(r.operatorChars), t.cont("operator", "operator"); if (s == "[" || s == "]") return t.cont("bracket", "bracket"); if (s == "(" || s == ")") return t.cont("bracket", "operator"); if (/\d/.test(s)) return n.eatWhile(/\d/), t.cont("number", "number"); if (o.last == "variable") { if (s == "@") return n.eatWhile(r.validIdentifier), t.cont("property", "property"); if (s == "|") return n.eatWhile(r.validIdentifier), t.cont("qualifier", "modifier") } else { if (o.last == "pipe") return n.eatWhile(r.validIdentifier), t.cont("qualifier", "modifier"); if (o.last == "whitespace") return n.eatWhile(r.validIdentifier), t.cont("attribute", "modifier") } if (o.last == "property") return n.eatWhile(r.validIdentifier), t.cont("property", null); if (/\s/.test(s)) return f = "whitespace", null; for (h = "", s != "/" && (h += s), l = null; l = n.eat(r.validIdentifier) ;) h += l; for (c = 0, a = e.length; c < a; c++) if (e[c] == h) return t.cont("keyword", "keyword"); return /\s/.test(s) ? null : t.cont("tag", "tag") }, inAttribute: function (n) { return function (t, i) { for (var r = null, f = null; !t.eol() ;) { if (f = t.peek(), t.next() == n && r !== "\\") { i.tokenize = u.smarty; break } r = f } return "string" } }, inBlock: function (n, t) { return function (i, r) { while (!i.eol()) { if (i.match(t)) { r.tokenize = u.tokenizer; break } i.next() } return n } } }; return { startState: function () { return { tokenize: u.tokenizer, mode: "smarty", last: null, depth: 0 } }, token: function (n, t) { var i = t.tokenize(n, t); return t.last = f, i }, electricChars: "" } }); n.defineMIME("text/x-smarty", "smarty") });
//# sourceMappingURL=smarty.min.js.map