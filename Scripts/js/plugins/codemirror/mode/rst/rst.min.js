(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror"), require("../python/python"), require("../stex/stex"), require("../../addon/mode/overlay")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror", "../python/python", "../stex/stex", "../../addon/mode/overlay"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("rst", function (t, i) { var r = /^\*\*[^\*\s](?:[^\*]*[^\*\s])?\*\*/, u = /^\*[^\*\s](?:[^\*]*[^\*\s])?\*/, f = /^``[^`\s](?:[^`]*[^`\s])``/, e = /^(?:[\d]+(?:[\.,]\d+)*)/, o = /^(?:\s\+[\d]+(?:[\.,]\d+)*)/, s = /^(?:\s\-[\d]+(?:[\.,]\d+)*)/, h = new RegExp("^[Hh][Tt][Tt][Pp][Ss]?://(?:[\\d\\w.-]+)\\.(?:\\w{2,6})(?:/[\\d\\w\\#\\%\\&\\-\\.\\,\\/\\:\\=\\?\\~]+)*"), c = { token: function (n) { if (n.match(r) && n.match(/\W+|$/, !1)) return "strong"; if (n.match(u) && n.match(/\W+|$/, !1)) return "em"; if (n.match(f) && n.match(/\W+|$/, !1)) return "string-2"; if (n.match(e)) return "number"; if (n.match(o)) return "positive"; if (n.match(s)) return "negative"; if (n.match(h)) return "link"; while (n.next() != null) { if (n.match(r, !1)) break; if (n.match(u, !1)) break; if (n.match(f, !1)) break; if (n.match(e, !1)) break; if (n.match(o, !1)) break; if (n.match(s, !1)) break; if (n.match(h, !1)) break } return null } }, l = n.getMode(t, i.backdrop || "rst-base"); return n.overlayMode(l, c, !0) }, "python", "stex"); n.defineMode("rst-base", function (t) { function e(n) { var t = Array.prototype.slice.call(arguments, 1); return n.replace(/{(\d+)}/g, function (n, i) { return typeof t[i] != "undefined" ? t[i] : n }) } function ht(n) { this.message = n } function u(n, t) { if (!n) throw new ht(t); return n } function r(t, e) { var o = null; if (t.sol() && t.match(oi, !1)) i(e, st, { mode: d, local: n.startState(d) }); else if (t.sol() && t.match(vt)) i(e, h), o = "meta"; else if (t.sol() && t.match(at)) i(e, r), o = "header"; else if (v(e) == c || t.match(c, !1)) switch (a(e)) { case 0: i(e, r, f(c, 1)); u(t.match(/^:/)); o = "meta"; break; case 1: i(e, r, f(c, 2)); u(t.match(ft)); o = "keyword"; t.current().match(/^(?:math|latex)/) && (e.tmp_stex = !0); break; case 2: i(e, r, f(c, 3)); u(t.match(/^:`/)); o = "meta"; break; case 3: if (e.tmp_stex && (e.tmp_stex = undefined, e.tmp = { mode: g, local: n.startState(g) }), e.tmp) { if (t.peek() == "`") { i(e, r, f(c, 4)); e.tmp = undefined; break } o = e.tmp.mode.token(t, e.tmp.local); break } i(e, r, f(c, 4)); u(t.match(ot)); o = "string"; break; case 4: i(e, r, f(c, 5)); u(t.match(/^`/)); o = "meta"; break; case 5: i(e, r, f(c, 6)); u(t.match(ut)); break; default: i(e, r); u(t.current() == "") } else if (v(e) == l || t.match(l, !1)) switch (a(e)) { case 0: i(e, r, f(l, 1)); u(t.match(/^`/)); o = "meta"; break; case 1: i(e, r, f(l, 2)); u(t.match(ot)); o = "string"; break; case 2: i(e, r, f(l, 3)); u(t.match(/^`:/)); o = "meta"; break; case 3: i(e, r, f(l, 4)); u(t.match(ft)); o = "keyword"; break; case 4: i(e, r, f(l, 5)); u(t.match(/^:/)); o = "meta"; break; case 5: i(e, r, f(l, 6)); u(t.match(ut)); break; default: i(e, r); u(t.current() == "") } else if (v(e) == w || t.match(w, !1)) switch (a(e)) { case 0: i(e, r, f(w, 1)); u(t.match(/^:/)); o = "meta"; break; case 1: i(e, r, f(w, 2)); u(t.match(ft)); o = "keyword"; break; case 2: i(e, r, f(w, 3)); u(t.match(/^:/)); o = "meta"; break; case 3: i(e, r, f(w, 4)); u(t.match(ut)); break; default: i(e, r); u(t.current() == "") } else if (v(e) == it || t.match(it, !1)) switch (a(e)) { case 0: i(e, r, f(it, 1)); u(t.match(ct)); o = "variable-2"; break; case 1: i(e, r, f(it, 2)); t.match(/^_?_?/) && (o = "link"); break; default: i(e, r); u(t.current() == "") } else if (t.match(wt)) i(e, r), o = "quote"; else if (t.match(bt)) i(e, r), o = "quote"; else if (t.match(kt)) i(e, r), (!t.peek() || t.peek().match(/^\W$/)) && (o = "link"); else if (v(e) == y || t.match(y, !1)) switch (a(e)) { case 0: !t.peek() || t.peek().match(/^\W$/) ? i(e, r, f(y, 1)) : t.match(y); break; case 1: i(e, r, f(y, 2)); u(t.match(/^`/)); o = "link"; break; case 2: i(e, r, f(y, 3)); u(t.match(ot)); break; case 3: i(e, r, f(y, 4)); u(t.match(/^`_/)); o = "link"; break; default: i(e, r); u(t.current() == "") } else t.match(ei) ? i(e, hi) : t.next() && i(e, r); return o } function h(t, e) { var o = null; if (v(e) == p || t.match(p, !1)) switch (a(e)) { case 0: i(e, h, f(p, 1)); u(t.match(ct)); o = "variable-2"; break; case 1: i(e, h, f(p, 2)); u(t.match(ni)); break; case 2: i(e, h, f(p, 3)); u(t.match(ti)); o = "keyword"; break; case 3: i(e, h, f(p, 4)); u(t.match(ii)); o = "meta"; break; default: i(e, r); u(t.current() == "") } else if (v(e) == k || t.match(k, !1)) switch (a(e)) { case 0: i(e, h, f(k, 1)); u(t.match(dt)); o = "keyword"; t.current().match(/^(?:math|latex)/) ? e.tmp_stex = !0 : t.current().match(/^python/) && (e.tmp_py = !0); break; case 1: i(e, h, f(k, 2)); u(t.match(gt)); o = "meta"; (t.match(/^latex\s*$/) || e.tmp_stex) && (e.tmp_stex = undefined, i(e, st, { mode: g, local: n.startState(g) })); break; case 2: i(e, h, f(k, 3)); (t.match(/^python\s*$/) || e.tmp_py) && (e.tmp_py = undefined, i(e, st, { mode: d, local: n.startState(d) })); break; default: i(e, r); u(t.current() == "") } else if (v(e) == tt || t.match(tt, !1)) switch (a(e)) { case 0: i(e, h, f(tt, 1)); u(t.match(ri)); u(t.match(ui)); o = "link"; break; case 1: i(e, h, f(tt, 2)); u(t.match(fi)); o = "meta"; break; default: i(e, r); u(t.current() == "") } else t.match(yt) ? (i(e, r), o = "quote") : t.match(pt) ? (i(e, r), o = "quote") : (t.eatSpace(), t.eol() ? i(e, r) : (t.skipToEnd(), i(e, si), o = "comment")); return o } function si(n, t) { return lt(n, t, "comment") } function hi(n, t) { return lt(n, t, "meta") } function lt(n, t, u) { return n.eol() || n.eatSpace() ? (n.skipToEnd(), u) : (i(t, r), null) } function st(n, t) { return t.ctx.mode && t.ctx.local ? n.sol() ? (n.eatSpace() || i(t, r), null) : t.ctx.mode.token(n, t.ctx.local) : (i(t, r), null) } function f(n, t, i, r) { return { phase: n, stage: t, mode: i, local: r } } function i(n, t, i) { n.tok = t; n.ctx = i || {} } function a(n) { return n.ctx.stage || 0 } function v(n) { return n.ctx.phase } ht.prototype.toString = function () { return "AssertException: " + this.message }; var d = n.getMode(t, "python"), g = n.getMode(t, "stex"), rt = "\\s+", o = "(?:\\s*|\\W|$)", ut = new RegExp(e("^{0}", o)), b = "(?:[^\\W\\d_](?:[\\w!\"#$%&'()\\*\\+,\\-\\./:;<=>\\?]*[^\\W_])?)", ft = new RegExp(e("^{0}", b)), s = e("(?:{0}|`{1}`)", b, "(?:[^\\W\\d_](?:[\\w\\s!\"#$%&'()\\*\\+,\\-\\./:;<=>\\?]*[^\\W_])?)"), et = "(?:[^\\s\\|](?:[^\\|]*[^\\s\\|])?)", nt = "(?:[^\\`]+)", ot = new RegExp(e("^{0}", nt)), at = new RegExp("^([!'#$%&\"()*+,-./:;<=>?@\\[\\\\\\]^_`{|}~])\\1{3,}\\s*$"), vt = new RegExp(e("^\\.\\.{0}", rt)), tt = new RegExp(e("^_{0}:{1}|^__:{1}", s, o)), k = new RegExp(e("^{0}::{1}", s, o)), p = new RegExp(e("^\\|{0}\\|{1}{2}::{3}", et, rt, s, o)), yt = new RegExp(e("^\\[(?:\\d+|#{0}?|\\*)]{1}", s, o)), pt = new RegExp(e("^\\[{0}\\]{1}", s, o)), it = new RegExp(e("^\\|{0}\\|", et)), wt = new RegExp(e("^\\[(?:\\d+|#{0}?|\\*)]_", s)), bt = new RegExp(e("^\\[{0}\\]_", s)), kt = new RegExp(e("^{0}__?", s)), y = new RegExp(e("^`{0}`_", nt)), c = new RegExp(e("^:{0}:`{1}`{2}", b, nt, o)), l = new RegExp(e("^`{1}`:{0}:{2}", b, nt, o)), w = new RegExp(e("^:{0}:{1}", b, o)), dt = new RegExp(e("^{0}", s)), gt = new RegExp(e("^::{0}", o)), ct = new RegExp(e("^\\|{0}\\|", et)), ni = new RegExp(e("^{0}", rt)), ti = new RegExp(e("^{0}", s)), ii = new RegExp(e("^::{0}", o)), ri = new RegExp("^_"), ui = new RegExp(e("^{0}|_", s)), fi = new RegExp(e("^:{0}", o)), ei = new RegExp("^::\\s*$"), oi = new RegExp("^\\s+(?:>>>|In \\[\\d+\\]:)\\s"); return { startState: function () { return { tok: r, ctx: f(undefined, 0) } }, copyState: function (t) { var i = t.ctx, r = t.tmp; return i.local && (i = { mode: i.mode, local: n.copyState(i.mode, i.local) }), r && (r = { mode: r.mode, local: n.copyState(r.mode, r.local) }), { tok: t.tok, ctx: i, tmp: r } }, innerMode: function (n) { return n.tmp ? { state: n.tmp.local, mode: n.tmp.mode } : n.ctx.mode ? { state: n.ctx.local, mode: n.ctx.mode } : null }, token: function (n, t) { return t.tok(n, t) } } }, "python", "stex"); n.defineMIME("text/x-rst", "rst") });
//# sourceMappingURL=rst.min.js.map