(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("turtle", function (n) { function u(n) { return new RegExp("^(?:" + n.join("|") + ")$", "i") } function o(n, i) { var r = n.next(), u; return t = null, r != "<" || n.match(/^[\s\u00a0=]/, !1) ? r == '"' || r == "'" ? (i.tokenize = c(r), i.tokenize(n, i)) : /[{}\(\),\.;\[\]]/.test(r) ? (t = r, null) : r == "#" ? (n.skipToEnd(), "comment") : e.test(r) ? (n.eatWhile(e), null) : r == ":" ? "operator" : (n.eatWhile(/[_\w\d]/), n.peek() == ":" ? "variable-3" : (u = n.current(), f.test(u)) ? "meta" : r >= "A" && r <= "Z" ? "comment" : "keyword") : (n.match(/^[^\s\u00a0>]*>?/), "atom") } function c(n) { return function (t, i) { for (var r = !1, u; (u = t.next()) != null;) { if (u == n && !r) { i.tokenize = o; break } r = !r && u == "\\" } return "string" } } function i(n, t, i) { n.context = { prev: n.context, indent: n.indent, col: i, type: t } } function r(n) { n.indent = n.context.indent; n.context = n.context.prev } var s = n.indentUnit, t, h = u([]), f = u(["@prefix", "@base", "a"]), e = /[*+\-<>=&|]/; return { startState: function () { return { tokenize: o, context: null, indent: 0, col: 0 } }, token: function (n, u) { if (n.sol() && (u.context && u.context.align == null && (u.context.align = !1), u.indent = n.indentation()), n.eatSpace()) return null; var f = u.tokenize(n, u); if (f != "comment" && u.context && u.context.align == null && u.context.type != "pattern" && (u.context.align = !0), t == "(") i(u, ")", n.column()); else if (t == "[") i(u, "]", n.column()); else if (t == "{") i(u, "}", n.column()); else if (/[\]\}\)]/.test(t)) { while (u.context && u.context.type == "pattern") r(u); u.context && t == u.context.type && r(u) } else t == "." && u.context && u.context.type == "pattern" ? r(u) : /atom|string|variable/.test(f) && u.context && (/[\}\]]/.test(u.context.type) ? i(u, "pattern", n.column()) : u.context.type != "pattern" || u.context.align || (u.context.align = !0, u.context.col = n.column())); return f }, indent: function (n, t) { var u = t && t.charAt(0), i = n.context, r; if (/[\]\}]/.test(u)) while (i && i.type == "pattern") i = i.prev; return r = i && u == i.type, i ? i.type == "pattern" ? i.col : i.align ? i.col + (r ? 0 : 1) : i.indent + (r ? 0 : s) : 0 } } }); n.defineMIME("text/turtle", "turtle") });
//# sourceMappingURL=turtle.min.js.map