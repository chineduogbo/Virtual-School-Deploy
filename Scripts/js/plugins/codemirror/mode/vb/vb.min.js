(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("vb", function (n, t) { function i(n) { return new RegExp("^((" + n.join(")|(") + "))\\b", "i") } function f(n, t) { t.currentIndent++ } function u(n, t) { t.currentIndent-- } function e(n, t) { var tt, e, i; if (n.eatSpace()) return null; if (tt = n.peek(), tt === "'") return n.skipToEnd(), "comment"; if (n.match(/^((&H)|(&O))?[0-9\.a-f]/i, !1)) { if (e = !1, n.match(/^\d*\.\d+F?/i) ? e = !0 : n.match(/^\d+\.\d*F?/) ? e = !0 : n.match(/^\.\d+F?/) && (e = !0), e) return n.eat(/J/i), "number"; if (i = !1, n.match(/^&H[0-9a-f]+/i) ? i = !0 : n.match(/^&O[0-7]+/i) ? i = !0 : n.match(/^[1-9]\d*F?/) ? (n.eat(/J/i), i = !0) : n.match(/^0(?![\dx])/i) && (i = !0), i) return n.eat(/L/i), "number" } return n.match(d) ? (t.tokenize = it(n.current()), t.tokenize(n, t)) : n.match(y) || n.match(v) ? null : n.match(a) || n.match(c) || n.match(w) ? "operator" : n.match(l) ? null : n.match(nt) ? (f(n, t), t.doInCurrentLine = !0, "keyword") : n.match(g) ? (t.doInCurrentLine ? t.doInCurrentLine = !1 : f(n, t), "keyword") : n.match(o) ? "keyword" : n.match(h) ? (u(n, t), u(n, t), "keyword") : n.match(s) ? (u(n, t), "keyword") : n.match(k) ? "keyword" : n.match(b) ? "keyword" : n.match(p) ? "variable" : (n.next(), r) } function it(n) { var u = n.length == 1, i = "string"; return function (f, o) { while (!f.eol()) { if (f.eatWhile(/[^'"]/), f.match(n)) return o.tokenize = e, i; f.eat(/['"]/) } if (u) { if (t.singleLineStringErrors) return r; o.tokenize = e } return i } } function rt(n, t) { var o = t.tokenize(n, t), i = n.current(), e; return i === "." ? (o = t.tokenize(n, t), i = n.current(), o === "variable" ? "variable" : r) : (e = "[({".indexOf(i), e !== -1 && f(n, t), tt === "dedent" && u(n, t)) ? r : (e = "])}".indexOf(i), e !== -1 && u(n, t)) ? r : o } var r = "error", c = new RegExp("^[\\+\\-\\*/%&\\\\|\\^~<>!]"), l = new RegExp("^[\\(\\)\\[\\]\\{\\}@,:`=;\\.]"), a = new RegExp("^((==)|(<>)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\*\\*))"), v = new RegExp("^((\\+=)|(\\-=)|(\\*=)|(%=)|(/=)|(&=)|(\\|=)|(\\^=))"), y = new RegExp("^((//=)|(>>=)|(<<=)|(\\*\\*=))"), p = new RegExp("^[_A-Za-z][_A-Za-z0-9]*"), w = i(["and", "or", "not", "xor", "in"]), b = i(["as", "dim", "break", "continue", "optional", "then", "until", "goto", "byval", "byref", "new", "handles", "property", "return", "const", "private", "protected", "friend", "public", "shared", "static", "true", "false"]), k = i(["integer", "string", "double", "decimal", "boolean", "short", "char", "float", "single"]), d = '"', g = i(["class", "module", "sub", "enum", "select", "while", "if", "function", "get", "set", "property", "try"]), o = i(["else", "elseif", "case", "catch"]), s = i(["next", "loop"]), h = i(["end"]), nt = i(["do"]), tt = null; return { electricChars: "dDpPtTfFeE ", startState: function () { return { tokenize: e, lastToken: null, currentIndent: 0, nextLineIndent: 0, doInCurrentLine: !1 } }, token: function (n, t) { n.sol() && (t.currentIndent += t.nextLineIndent, t.nextLineIndent = 0, t.doInCurrentLine = 0); var i = rt(n, t); return t.lastToken = { style: i, content: n.current() }, i }, indent: function (t, i) { var r = i.replace(/^\s+|\s+$/g, ""); return r.match(s) || r.match(h) || r.match(o) ? n.indentUnit * (t.currentIndent - 1) : t.currentIndent < 0 ? 0 : t.currentIndent * n.indentUnit } } }); n.defineMIME("text/x-vb", "vb") });
//# sourceMappingURL=vb.min.js.map