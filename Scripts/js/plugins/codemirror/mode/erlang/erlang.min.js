(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMIME("text/x-erlang", "erlang"); n.defineMode("erlang", function (t) { function ht(n, t) { var u, f, s, c; if (t.in_string) return t.in_string = !p(n), i(t, n, "string"); if (t.in_atom) return t.in_atom = !w(n), i(t, n, "atom"); if (n.eatSpace()) return i(t, n, "whitespace"); if (!e(t) && n.match(/-\s*[a-zß-öø-ÿ][\wØ-ÞÀ-Öß-öø-ÿ]*/)) return r(n.current(), d) ? i(t, n, "type") : i(t, n, "attribute"); if (u = n.next(), u == "%") return n.skipToEnd(), i(t, n, "comment"); if (u == ":") return i(t, n, "colon"); if (u == "?") return n.eatSpace(), n.eatWhile(o), i(t, n, "macro"); if (u == "#") return n.eatSpace(), n.eatWhile(o), i(t, n, "record"); if (u == "$") return n.next() == "\\" && !n.match(st) ? i(t, n, "error") : i(t, n, "number"); if (u == ".") return i(t, n, "dot"); if (u == "'") { if (!(t.in_atom = !w(n))) { if (n.match(/\s*\/\s*[0-9]/, !1)) return n.match(/\s*\/\s*[0-9]/, !0), i(t, n, "fun"); if (n.match(/\s*\(/, !1) || n.match(/\s*:/, !1)) return i(t, n, "function") } return i(t, n, "atom") } return u == '"' ? (t.in_string = !p(n), i(t, n, "string")) : /[A-Z_Ø-ÞÀ-Ö]/.test(u) ? (n.eatWhile(o), i(t, n, "variable")) : /[a-z_ß-öø-ÿ]/.test(u) ? (n.eatWhile(o), n.match(/\s*\/\s*[0-9]/, !1)) ? (n.match(/\s*\/\s*[0-9]/, !0), i(t, n, "fun")) : (f = n.current(), r(f, g) ? i(t, n, "keyword") : r(f, l) ? i(t, n, "operator") : n.match(/\s*\(/, !1) ? r(f, ot) && (e(t).token != ":" || e(t, 2).token == "erlang") ? i(t, n, "builtin") : r(f, et) ? i(t, n, "guard") : i(t, n, "function") : r(f, l) ? i(t, n, "operator") : ct(n) == ":" ? f == "erlang" ? i(t, n, "builtin") : i(t, n, "function") : r(f, ["true", "false"]) ? i(t, n, "boolean") : r(f, ["true", "false"]) ? i(t, n, "boolean") : i(t, n, "atom")) : (s = /[0-9]/, c = /[0-9a-zA-Z]/, s.test(u)) ? (n.eatWhile(s), n.eat("#") ? n.eatWhile(c) || n.backUp(1) : n.eat(".") && (n.eatWhile(s) ? n.eat(/[eE]/) && (n.eat(/[-+]/) ? n.eatWhile(s) || n.backUp(2) : n.eatWhile(s) || n.backUp(1)) : n.backUp(1)), i(t, n, "number")) : v(n, ut, h) ? i(t, n, "open_paren") : v(n, ft, a) ? i(t, n, "close_paren") : y(n, nt, tt) ? i(t, n, "separator") : y(n, it, rt) ? i(t, n, "operator") : i(t, n, null) } function v(n, t, i) { if (n.current().length == 1 && t.test(n.current())) { for (n.backUp(1) ; t.test(n.peek()) ;) if (n.next(), r(n.current(), i)) return !0; n.backUp(n.current().length - 1) } return !1 } function y(n, t, i) { if (n.current().length == 1 && t.test(n.current())) { while (t.test(n.peek())) n.next(); while (0 < n.current().length) { if (r(n.current(), i)) return !0; n.backUp(1) } n.next() } return !1 } function p(n) { return b(n, '"', "\\") } function w(n) { return b(n, "'", "\\") } function b(n, t, i) { while (!n.eol()) { var r = n.next(); if (r == t) return !0; r == i && n.next() } return !1 } function ct(n) { var t = n.match(/([\n\s]+|%[^\n]*\n)*(.)/, !1); return t ? t.pop() : "" } function r(n, t) { return -1 < t.indexOf(n) } function i(n, t, i) { vt(n, lt(i, t)); switch (i) { case "atom": return "atom"; case "attribute": return "attribute"; case "boolean": return "atom"; case "builtin": return "builtin"; case "close_paren": return null; case "colon": return null; case "comment": return "comment"; case "dot": return null; case "error": return "error"; case "fun": return "meta"; case "function": return "tag"; case "guard": return "property"; case "keyword": return "keyword"; case "macro": return "variable-2"; case "number": return "number"; case "open_paren": return null; case "operator": return "operator"; case "record": return "bracket"; case "separator": return null; case "string": return "string"; case "type": return "def"; case "variable": return "variable"; default: return null } } function k(n, t, i, r) { return { token: n, column: t, indent: i, type: r } } function lt(n, t) { return k(t.current(), t.column(), t.indentation(), n) } function at(n) { return k(n, 0, 0, n) } function e(n, t) { var i = n.tokenStack.length, r = t ? t : 1; return i < r ? !1 : n.tokenStack[i - r] } function vt(n, t) { t.type == "comment" || t.type == "whitespace" || (n.tokenStack = yt(n.tokenStack, t), n.tokenStack = pt(n.tokenStack)) } function yt(n, t) { var i = n.length - 1; return 0 < i && n[i].type === "record" && t.type === "dot" ? n.pop() : 0 < i && n[i].type === "group" ? (n.pop(), n.push(t)) : n.push(t), n } function pt(n) { var t = n.length - 1; if (n[t].type === "dot") return []; if (n[t].type === "fun" && n[t - 1].token === "fun") return n.slice(0, t - 1); switch (n[n.length - 1].token) { case "}": return u(n, { g: ["{"] }); case "]": return u(n, { i: ["["] }); case ")": return u(n, { i: ["("] }); case ">>": return u(n, { i: ["<<"] }); case "end": return u(n, { i: ["begin", "case", "fun", "if", "receive", "try"] }); case ",": return u(n, { e: ["begin", "try", "when", "->", ",", "(", "[", "{", "<<"] }); case "->": return u(n, { r: ["when"], m: ["try", "if", "case", "receive"] }); case ";": return u(n, { E: ["case", "fun", "if", "receive", "try", "when"] }); case "catch": return u(n, { e: ["try"] }); case "of": return u(n, { e: ["case"] }); case "after": return u(n, { e: ["receive", "try"] }); default: return n } } function u(n, t) { var f, e, o, i, u; for (f in t) for (e = n.length - 1, o = t[f], i = e - 1; -1 < i; i--) if (r(n[i].token, o)) { u = n.slice(0, i); switch (f) { case "m": return u.concat(n[i]).concat(n[e]); case "r": return u.concat(n[e]); case "i": return u; case "g": return u.concat(at("group")); case "E": return u.concat(n[i]); case "e": return u.concat(n[i]) } } return f == "E" ? [] : n } function wt(i, u) { var o, l = t.indentUnit, v = bt(u), s = e(i, 1), y = e(i, 2); return i.in_string || i.in_atom ? n.Pass : y ? s.token == "when" ? s.column + l : v === "when" && y.type === "function" ? y.indent + l : v === "(" && s.token === "fun" ? s.column + 3 : v === "catch" && (o = c(i, ["try"])) ? o.column : r(v, ["end", "after", "of"]) ? (o = c(i, ["begin", "case", "fun", "if", "receive", "try"]), o ? o.column : n.Pass) : r(v, a) ? (o = c(i, h), o ? o.column : n.Pass) : r(s.token, [",", "|", "||"]) || r(v, [",", "|", "||"]) ? (o = kt(i), o ? o.column + o.token.length : l) : s.token == "->" ? r(y.token, ["receive", "case", "if", "try"]) ? y.column + l + l : y.column + l : r(s.token, h) ? s.column + s.token.length : (o = dt(i), f(o) ? o.column + l : 0) : 0 } function bt(n) { var t = n.match(/,|[a-z]+|\}|\]|\)|>>|\|+|\(/); return f(t) && t.index === 0 ? t[0] : "" } function kt(n) { var t = n.tokenStack.slice(0, -1), i = s(t, "type", ["open_paren"]); return f(t[i]) ? t[i] : !1 } function dt(n) { var i = n.tokenStack, t = s(i, "type", ["open_paren", "separator", "keyword"]), r = s(i, "type", ["operator"]); return f(t) && f(r) && t < r ? i[t + 1] : f(t) ? i[t] : !1 } function c(n, t) { var i = n.tokenStack, r = s(i, "token", t); return f(i[r]) ? i[r] : !1 } function s(n, t, i) { for (var u = n.length - 1; -1 < u; u--) if (r(n[u][t], i)) return u; return !1 } function f(n) { return n !== !1 && n != null } var d = ["-type", "-spec", "-export_type", "-opaque"], g = ["after", "begin", "catch", "case", "cond", "end", "fun", "if", "let", "of", "query", "receive", "try", "when"], nt = /[\->,;]/, tt = ["->", ";", ","], l = ["and", "andalso", "band", "bnot", "bor", "bsl", "bsr", "bxor", "div", "not", "or", "orelse", "rem", "xor"], it = /[\+\-\*\/<>=\|:!]/, rt = ["=", "+", "-", "*", "/", ">", ">=", "<", "=<", "=:=", "==", "=/=", "/=", "||", "<-", "!"], ut = /[<\(\[\{]/, h = ["<<", "(", "[", "{"], ft = /[>\)\]\}]/, a = ["}", "]", ")", ">>"], et = ["is_atom", "is_binary", "is_bitstring", "is_boolean", "is_float", "is_function", "is_integer", "is_list", "is_number", "is_pid", "is_port", "is_record", "is_reference", "is_tuple", "atom", "binary", "bitstring", "boolean", "function", "integer", "list", "number", "pid", "port", "record", "reference", "tuple"], ot = ["abs", "adler32", "adler32_combine", "alive", "apply", "atom_to_binary", "atom_to_list", "binary_to_atom", "binary_to_existing_atom", "binary_to_list", "binary_to_term", "bit_size", "bitstring_to_list", "byte_size", "check_process_code", "contact_binary", "crc32", "crc32_combine", "date", "decode_packet", "delete_module", "disconnect_node", "element", "erase", "exit", "float", "float_to_list", "garbage_collect", "get", "get_keys", "group_leader", "halt", "hd", "integer_to_list", "internal_bif", "iolist_size", "iolist_to_binary", "is_alive", "is_atom", "is_binary", "is_bitstring", "is_boolean", "is_float", "is_function", "is_integer", "is_list", "is_number", "is_pid", "is_port", "is_process_alive", "is_record", "is_reference", "is_tuple", "length", "link", "list_to_atom", "list_to_binary", "list_to_bitstring", "list_to_existing_atom", "list_to_float", "list_to_integer", "list_to_pid", "list_to_tuple", "load_module", "make_ref", "module_loaded", "monitor_node", "node", "node_link", "node_unlink", "nodes", "notalive", "now", "open_port", "pid_to_list", "port_close", "port_command", "port_connect", "port_control", "pre_loaded", "process_flag", "process_info", "processes", "purge_module", "put", "register", "registered", "round", "self", "setelement", "size", "spawn", "spawn_link", "spawn_monitor", "spawn_opt", "split_binary", "statistics", "term_to_binary", "time", "throw", "tl", "trunc", "tuple_size", "tuple_to_list", "unlink", "unregister", "whereis"], o = /[\w@Ø-ÞÀ-Öß-öø-ÿ]/, st = /[0-7]{1,3}|[bdefnrstv\\"']|\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/; return { startState: function () { return { tokenStack: [], in_string: !1, in_atom: !1 } }, token: function (n, t) { return ht(n, t) }, indent: function (n, t) { return wt(n, t) }, lineComment: "%" } }) });
//# sourceMappingURL=erlang.min.js.map