(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; var o, u, f, h, s; n.defineMode("livescript", function () { var n = function (n, t) { var e = t.next || "start", u, f, i, o; if (e) { if (t.next = t.next, u = r[e], u.splice) { for (f = 0; f < u.length; ++f) if (i = u[f], i.regex && (o = n.match(i.regex))) return t.next = i.next || t.next, i.token; return n.next(), "error" } if (n.match(i = r[e])) return i.regex && n.match(i.regex) ? (t.next = i.next, i.token) : (n.next(), "error") } return n.next(), "error" }; return { startState: function () { return { next: "start", lastToken: null } }, token: function (t, i) { while (t.pos == t.start) var r = n(t, i); return i.lastToken = { style: r, indent: t.indentation(), content: t.current() }, r.replace(/\./g, " ") }, indent: function (n) { var t = n.lastToken.indent; return n.lastToken.content.match(c) && (t += 2), t } } }); var e = "(?![\\d\\s])[$\\w\\xAA-\\uFFDC](?:(?!\\s)[$\\w\\xAA-\\uFFDC]|-[A-Za-z])*", c = RegExp("(?:[({[=:]|[-~]>|\\b(?:e(?:lse|xport)|d(?:o|efault)|t(?:ry|hen)|finally|import(?:\\s*all)?|const|var|let|new|catch(?:\\s*" + e + ")?))\\s*$"), t = "(?![$\\w]|-[A-Za-z]|\\s*:(?![:=]))", i = { token: "string", regex: ".+" }, r = { start: [{ token: "comment.doc", regex: "/\\*", next: "comment" }, { token: "comment", regex: "#.*" }, { token: "keyword", regex: "(?:t(?:h(?:is|row|en)|ry|ypeof!?)|c(?:on(?:tinue|st)|a(?:se|tch)|lass)|i(?:n(?:stanceof)?|mp(?:ort(?:\\s+all)?|lements)|[fs])|d(?:e(?:fault|lete|bugger)|o)|f(?:or(?:\\s+own)?|inally|unction)|s(?:uper|witch)|e(?:lse|x(?:tends|port)|val)|a(?:nd|rguments)|n(?:ew|ot)|un(?:less|til)|w(?:hile|ith)|o[fr]|return|break|let|var|loop)" + t }, { token: "constant.language", regex: "(?:true|false|yes|no|on|off|null|void|undefined)" + t }, { token: "invalid.illegal", regex: "(?:p(?:ackage|r(?:ivate|otected)|ublic)|i(?:mplements|nterface)|enum|static|yield)" + t }, { token: "language.support.class", regex: "(?:R(?:e(?:gExp|ferenceError)|angeError)|S(?:tring|yntaxError)|E(?:rror|valError)|Array|Boolean|Date|Function|Number|Object|TypeError|URIError)" + t }, { token: "language.support.function", regex: "(?:is(?:NaN|Finite)|parse(?:Int|Float)|Math|JSON|(?:en|de)codeURI(?:Component)?)" + t }, { token: "variable.language", regex: "(?:t(?:hat|il|o)|f(?:rom|allthrough)|it|by|e)" + t }, { token: "identifier", regex: e + "\\s*:(?![:=])" }, { token: "variable", regex: e }, { token: "keyword.operator", regex: "(?:\\.{3}|\\s+\\?)" }, { token: "keyword.variable", regex: "(?:@+|::|\\.\\.)", next: "key" }, { token: "keyword.operator", regex: "\\.\\s*", next: "key" }, { token: "string", regex: "\\\\\\S[^\\s,;)}\\]]*" }, { token: "string.doc", regex: "'''", next: "qdoc" }, { token: "string.doc", regex: '"""', next: "qqdoc" }, { token: "string", regex: "'", next: "qstring" }, { token: "string", regex: '"', next: "qqstring" }, { token: "string", regex: "`", next: "js" }, { token: "string", regex: "<\\[", next: "words" }, { token: "string.regex", regex: "//", next: "heregex" }, { token: "string.regex", regex: "\\/(?:[^[\\/\\n\\\\]*(?:(?:\\\\.|\\[[^\\]\\n\\\\]*(?:\\\\.[^\\]\\n\\\\]*)*\\])[^[\\/\\n\\\\]*)*)\\/[gimy$]{0,4}", next: "key" }, { token: "constant.numeric", regex: "(?:0x[\\da-fA-F][\\da-fA-F_]*|(?:[2-9]|[12]\\d|3[0-6])r[\\da-zA-Z][\\da-zA-Z_]*|(?:\\d[\\d_]*(?:\\.\\d[\\d_]*)?|\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[\\w$]*)" }, { token: "lparen", regex: "[({[]" }, { token: "rparen", regex: "[)}\\]]", next: "key" }, { token: "keyword.operator", regex: "\\S+" }, { token: "text", regex: "\\s+" }], heregex: [{ token: "string.regex", regex: ".*?//[gimy$?]{0,4}", next: "start" }, { token: "string.regex", regex: "\\s*#{" }, { token: "comment.regex", regex: "\\s+(?:#.*)?" }, { token: "string.regex", regex: "\\S+" }], key: [{ token: "keyword.operator", regex: "[.?@!]+" }, { token: "identifier", regex: e, next: "start" }, { token: "text", regex: "", next: "start" }], comment: [{ token: "comment.doc", regex: ".*?\\*/", next: "start" }, { token: "comment.doc", regex: ".+" }], qdoc: [{ token: "string", regex: ".*?'''", next: "key" }, i], qqdoc: [{ token: "string", regex: '.*?"""', next: "key" }, i], qstring: [{ token: "string", regex: "[^\\\\']*(?:\\\\.[^\\\\']*)*'", next: "key" }, i], qqstring: [{ token: "string", regex: '[^\\\\"]*(?:\\\\.[^\\\\"]*)*"', next: "key" }, i], js: [{ token: "string", regex: "[^\\\\`]*(?:\\\\.[^\\\\`]*)*`", next: "key" }, i], words: [{ token: "string", regex: ".*?\\]>", next: "key" }, i] }; for (o in r) if (u = r[o], u.splice) for (f = 0, h = u.length; f < h; ++f) s = u[f], typeof s.regex == "string" && (r[o][f].regex = new RegExp("^" + s.regex)); else typeof s.regex == "string" && (r[o].regex = new RegExp("^" + u.regex)); n.defineMIME("text/x-livescript", "livescript") });
//# sourceMappingURL=livescript.min.js.map