(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("haskell", function (n, t) { function r(n, t, i) { return t(i), i(n, t) } function i(n, t) { var i, c; if (n.eatWhile(o)) return null; if (i = n.next(), p.test(i)) return i == "{" && n.eat("-") ? (c = "comment", n.eat("#") && (c = "meta"), r(n, t, s(c, 1))) : null; if (i == "'") return (n.eat("\\") ? n.next() : n.next(), n.eat("'")) ? "string" : "error"; if (i == '"') return r(n, t, h); if (a.test(i)) return (n.eatWhile(e), n.eat(".")) ? "qualifier" : "variable-2"; if (l.test(i)) return n.eatWhile(e), "variable"; if (u.test(i)) { if (i == "0") { if (n.eat(/[xX]/)) return n.eatWhile(v), "integer"; if (n.eat(/[oO]/)) return n.eatWhile(y), "number" } return n.eatWhile(u), c = "number", n.match(/^\.\d+/) && (c = "number"), n.eat(/[eE]/) && (c = "number", n.eat(/[-+]/), n.eatWhile(u)), c } return i == "." && n.eat(".") ? "keyword" : f.test(i) ? i == "-" && n.eat(/-/) && (n.eatWhile(/-/), !n.eat(f)) ? (n.skipToEnd(), "comment") : (c = "variable", i == ":" && (c = "variable-2"), n.eatWhile(f), c) : "error" } function s(n, t) { return t == 0 ? i : function (r, u) { for (var f = t, e; !r.eol() ;) if (e = r.next(), e == "{" && r.eat("-"))++f; else if (e == "-" && r.eat("}") && (--f, f == 0)) return u(i), n; return u(s(n, f)), n } } function h(n, t) { while (!n.eol()) { var r = n.next(); if (r == '"') return t(i), "string"; if (r == "\\") { if (n.eol() || n.eat(o)) return t(w), "string"; n.eat("&") || n.next() } } return t(i), "error" } function w(n, t) { return n.eat("\\") ? r(n, t, h) : (n.next(), t(i), "error") } var l = /[a-z_]/, a = /[A-Z]/, u = /\d/, v = /[0-9A-Fa-f]/, y = /[0-7]/, e = /[a-z_A-Z0-9']/, f = /[-!#$%&*+.\/<=>?@\\^|~:]/, p = /[(),;[\]`{}]/, o = /[ \t\v\f]/, c = function () { function n(n) { return function () { for (var t = 0; t < arguments.length; t++) u[arguments[t]] = n } } var u = {}, i, r; if (n("keyword")("case", "class", "data", "default", "deriving", "do", "else", "foreign", "if", "import", "in", "infix", "infixl", "infixr", "instance", "let", "module", "newtype", "of", "then", "type", "where", "_"), n("keyword")("..", ":", "::", "=", "\\", '"', "<-", "->", "@", "~", "=>"), n("builtin")("!!", "$!", "$", "&&", "+", "++", "-", ".", "/", "/=", "<", "<=", "=<<", "==", ">", ">=", ">>", ">>=", "^", "^^", "||", "*", "**"), n("builtin")("Bool", "Bounded", "Char", "Double", "EQ", "Either", "Enum", "Eq", "False", "FilePath", "Float", "Floating", "Fractional", "Functor", "GT", "IO", "IOError", "Int", "Integer", "Integral", "Just", "LT", "Left", "Maybe", "Monad", "Nothing", "Num", "Ord", "Ordering", "Rational", "Read", "ReadS", "Real", "RealFloat", "RealFrac", "Right", "Show", "ShowS", "String", "True"), n("builtin")("abs", "acos", "acosh", "all", "and", "any", "appendFile", "asTypeOf", "asin", "asinh", "atan", "atan2", "atanh", "break", "catch", "ceiling", "compare", "concat", "concatMap", "const", "cos", "cosh", "curry", "cycle", "decodeFloat", "div", "divMod", "drop", "dropWhile", "either", "elem", "encodeFloat", "enumFrom", "enumFromThen", "enumFromThenTo", "enumFromTo", "error", "even", "exp", "exponent", "fail", "filter", "flip", "floatDigits", "floatRadix", "floatRange", "floor", "fmap", "foldl", "foldl1", "foldr", "foldr1", "fromEnum", "fromInteger", "fromIntegral", "fromRational", "fst", "gcd", "getChar", "getContents", "getLine", "head", "id", "init", "interact", "ioError", "isDenormalized", "isIEEE", "isInfinite", "isNaN", "isNegativeZero", "iterate", "last", "lcm", "length", "lex", "lines", "log", "logBase", "lookup", "map", "mapM", "mapM_", "max", "maxBound", "maximum", "maybe", "min", "minBound", "minimum", "mod", "negate", "not", "notElem", "null", "odd", "or", "otherwise", "pi", "pred", "print", "product", "properFraction", "putChar", "putStr", "putStrLn", "quot", "quotRem", "read", "readFile", "readIO", "readList", "readLn", "readParen", "reads", "readsPrec", "realToFrac", "recip", "rem", "repeat", "replicate", "return", "reverse", "round", "scaleFloat", "scanl", "scanl1", "scanr", "scanr1", "seq", "sequence", "sequence_", "show", "showChar", "showList", "showParen", "showString", "shows", "showsPrec", "significand", "signum", "sin", "sinh", "snd", "span", "splitAt", "sqrt", "subtract", "succ", "sum", "tail", "take", "takeWhile", "tan", "tanh", "toEnum", "toInteger", "toRational", "truncate", "uncurry", "undefined", "unlines", "until", "unwords", "unzip", "unzip3", "userError", "words", "writeFile", "zip", "zip3", "zipWith", "zipWith3"), i = t.overrideKeywords, i) for (r in i) i.hasOwnProperty(r) && (u[r] = i[r]); return u }(); return { startState: function () { return { f: i } }, copyState: function (n) { return { f: n.f } }, token: function (n, t) { var r = t.f(n, function (n) { t.f = n }), i = n.current(); return c.hasOwnProperty(i) ? c[i] : r }, blockCommentStart: "{-", blockCommentEnd: "-}", lineComment: "--" } }); n.defineMIME("text/x-haskell", "haskell") });
//# sourceMappingURL=haskell.min.js.map