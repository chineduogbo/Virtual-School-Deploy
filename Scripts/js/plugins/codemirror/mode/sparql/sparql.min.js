(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("sparql", function (n) { function u(n) { return new RegExp("^(?:" + n.join("|") + ")$", "i") } function e(n, i) { var r = n.next(), u; return t = null, r == "$" || r == "?" ? (n.match(/^[\w\d]*/), "variable-2") : r != "<" || n.match(/^[\s\u00a0=]/, !1) ? r == '"' || r == "'" ? (i.tokenize = c(r), i.tokenize(n, i)) : /[{}\(\),\.;\[\]]/.test(r) ? (t = r, null) : r == "#" ? (n.skipToEnd(), "comment") : f.test(r) ? (n.eatWhile(f), null) : r == ":" ? (n.eatWhile(/[\w\d\._\-]/), "atom") : (n.eatWhile(/[_\w\d]/), n.eat(":")) ? (n.eatWhile(/[\w\d_\-]/), "atom") : (u = n.current(), s.test(u) ? null : h.test(u) ? "keyword" : "variable") : (n.match(/^[^\s\u00a0>]*>?/), "atom") } function c(n) { return function (t, i) { for (var r = !1, u; (u = t.next()) != null;) { if (u == n && !r) { i.tokenize = e; break } r = !r && u == "\\" } return "string" } } function i(n, t, i) { n.context = { prev: n.context, indent: n.indent, col: i, type: t } } function r(n) { n.indent = n.context.indent; n.context = n.context.prev } var o = n.indentUnit, t, s = u(["str", "lang", "langmatches", "datatype", "bound", "sameterm", "isiri", "isuri", "isblank", "isliteral", "a"]), h = u(["base", "prefix", "select", "distinct", "reduced", "construct", "describe", "ask", "from", "named", "where", "order", "limit", "offset", "filter", "optional", "graph", "by", "asc", "desc", "as", "having", "undef", "values", "group", "minus", "in", "not", "service", "silent", "using", "insert", "delete", "union", "data", "copy", "to", "move", "add", "create", "drop", "clear", "load"]), f = /[*+\-<>=&|]/; return { startState: function () { return { tokenize: e, context: null, indent: 0, col: 0 } }, token: function (n, u) { if (n.sol() && (u.context && u.context.align == null && (u.context.align = !1), u.indent = n.indentation()), n.eatSpace()) return null; var f = u.tokenize(n, u); if (f != "comment" && u.context && u.context.align == null && u.context.type != "pattern" && (u.context.align = !0), t == "(") i(u, ")", n.column()); else if (t == "[") i(u, "]", n.column()); else if (t == "{") i(u, "}", n.column()); else if (/[\]\}\)]/.test(t)) { while (u.context && u.context.type == "pattern") r(u); u.context && t == u.context.type && r(u) } else t == "." && u.context && u.context.type == "pattern" ? r(u) : /atom|string|variable/.test(f) && u.context && (/[\}\]]/.test(u.context.type) ? i(u, "pattern", n.column()) : u.context.type != "pattern" || u.context.align || (u.context.align = !0, u.context.col = n.column())); return f }, indent: function (n, t) { var u = t && t.charAt(0), i = n.context, r; if (/[\]\}]/.test(u)) while (i && i.type == "pattern") i = i.prev; return r = i && u == i.type, i ? i.type == "pattern" ? i.col : i.align ? i.col + (r ? 0 : 1) : i.indent + (r ? 0 : o) : 0 } } }); n.defineMIME("application/x-sparql-query", "sparql") });
//# sourceMappingURL=sparql.min.js.map