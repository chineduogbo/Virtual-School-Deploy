(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("mllike", function (n, t) { function r(n, i) { var r = n.next(), f; return r === '"' ? (i.tokenize = e, i.tokenize(n, i)) : r === "(" && n.eat("*") ? (i.commentLevel++, i.tokenize = o, i.tokenize(n, i)) : r === "~" ? (n.eatWhile(/\w/), "variable-2") : r === "`" ? (n.eatWhile(/\w/), "quote") : r === "/" && t.slashComments && n.eat("/") ? (n.skipToEnd(), "comment") : /\d/.test(r) ? (n.eatWhile(/[\d]/), n.eat(".") && n.eatWhile(/[\d]/), "number") : /[+\-*&%=<>!?|]/.test(r) ? "operator" : (n.eatWhile(/\w/), f = n.current(), u[f] || "variable") } function e(n, t) { for (var u, f = !1, i = !1; (u = n.next()) != null;) { if (u === '"' && !i) { f = !0; break } i = !i && u === "\\" } return f && !i && (t.tokenize = r), "string" } function o(n, t) { for (var u, i; t.commentLevel > 0 && (i = n.next()) != null;) u === "(" && i === "*" && t.commentLevel++, u === "*" && i === ")" && t.commentLevel--, u = i; return t.commentLevel <= 0 && (t.tokenize = r), "comment" } var u = { "let": "keyword", rec: "keyword", "in": "keyword", of: "keyword", and: "keyword", "if": "keyword", then: "keyword", "else": "keyword", "for": "keyword", to: "keyword", "while": "keyword", "do": "keyword", done: "keyword", fun: "keyword", "function": "keyword", val: "keyword", type: "keyword", mutable: "keyword", match: "keyword", "with": "keyword", "try": "keyword", open: "builtin", ignore: "builtin", begin: "keyword", end: "keyword" }, f = t.extraWords || {}; for (var i in f) f.hasOwnProperty(i) && (u[i] = t.extraWords[i]); return { startState: function () { return { tokenize: r, commentLevel: 0 } }, token: function (n, t) { return n.eatSpace() ? null : t.tokenize(n, t) }, blockCommentStart: "(*", blockCommentEnd: "*)", lineComment: t.slashComments ? "//" : null } }); n.defineMIME("text/x-ocaml", { name: "mllike", extraWords: { succ: "keyword", trace: "builtin", exit: "builtin", print_string: "builtin", print_endline: "builtin", "true": "atom", "false": "atom", raise: "keyword" } }); n.defineMIME("text/x-fsharp", { name: "mllike", extraWords: { abstract: "keyword", as: "keyword", assert: "keyword", base: "keyword", "class": "keyword", "default": "keyword", delegate: "keyword", downcast: "keyword", downto: "keyword", elif: "keyword", exception: "keyword", extern: "keyword", "finally": "keyword", global: "keyword", inherit: "keyword", inline: "keyword", "interface": "keyword", internal: "keyword", lazy: "keyword", "let!": "keyword", member: "keyword", module: "keyword", namespace: "keyword", "new": "keyword", "null": "keyword", override: "keyword", "private": "keyword", "public": "keyword", "return": "keyword", "return!": "keyword", select: "keyword", "static": "keyword", struct: "keyword", upcast: "keyword", use: "keyword", "use!": "keyword", val: "keyword", when: "keyword", "yield": "keyword", "yield!": "keyword", List: "builtin", Seq: "builtin", Map: "builtin", Set: "builtin", int: "builtin", string: "builtin", raise: "builtin", failwith: "builtin", not: "builtin", "true": "builtin", "false": "builtin" }, slashComments: !0 }) });
//# sourceMappingURL=mllike.min.js.map