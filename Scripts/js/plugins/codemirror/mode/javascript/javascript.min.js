(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("javascript", function (t, i) { function wi(n) { for (var r = !1, t, i = !1; (t = n.next()) != null;) { if (!r) { if (t == "/" && !i) return; t == "[" ? i = !0 : i && t == "]" && (i = !1) } r = !r && t == "\\" } } function c(n, t, i) { return nt = n, et = i, t } function w(n, t) { var i = n.next(), r, u; return i == '"' || i == "'" ? (t.tokenize = bi(i), t.tokenize(n, t)) : i == "." && n.match(/^\d+(?:[eE][+\-]?\d+)?/) ? c("number", "number") : i == "." && n.match("..") ? c("spread", "meta") : /[\[\]{}\(\),;\:\.]/.test(i) ? c(i) : i == "=" && n.eat(">") ? c("=>", "operator") : i == "0" && n.eat(/x/i) ? (n.eatWhile(/[\da-f]/i), c("number", "number")) : /\d/.test(i) ? (n.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/), c("number", "number")) : i == "/" ? n.eat("*") ? (t.tokenize = ot, ot(n, t)) : n.eat("/") ? (n.skipToEnd(), c("comment", "comment")) : t.lastType == "operator" || t.lastType == "keyword c" || t.lastType == "sof" || /^[\[{}\(,;:]$/.test(t.lastType) ? (wi(n), n.eatWhile(/[gimy]/), c("regexp", "string-2")) : (n.eatWhile(vt), c("operator", "operator", n.current())) : i == "`" ? (t.tokenize = yt, yt(n, t)) : i == "#" ? (n.skipToEnd(), c("error", "error")) : vt.test(i) ? (n.eatWhile(vt), c("operator", "operator", n.current())) : at.test(i) ? (n.eatWhile(at), r = n.current(), u = ui.propertyIsEnumerable(r) && ui[r], u && t.lastType != "." ? c(u.type, u.style, r) : c("variable", "variable", r)) : void 0 } function bi(n) { return function (t, i) { var r = !1, u; if (ft && t.peek() == "@" && t.match(pi)) return i.tokenize = w, c("jsonld-keyword", "meta"); while ((u = t.next()) != null) { if (u == n && !r) break; r = !r && u == "\\" } return r || (i.tokenize = w), c("string", "string") } } function ot(n, t) { for (var r = !1, i; i = n.next() ;) { if (i == "/" && r) { t.tokenize = w; break } r = i == "*" } return c("comment", "comment") } function yt(n, t) { for (var r = !1, i; (i = n.next()) != null;) { if (!r && (i == "`" || i == "$" && n.eat("{"))) { t.tokenize = w; break } r = !r && i == "\\" } return c("quasi", "string-2", n.current()) } function pt(n, t) { var e, r, f, i, o, u; if (t.fatArrowAt && (t.fatArrowAt = null), e = n.string.indexOf("=>", n.start), !(e < 0)) { for (r = 0, f = !1, i = e - 1; i >= 0; --i) if (o = n.string.charAt(i), u = ki.indexOf(o), u >= 0 && u < 3) { if (!r) { ++i; break } if (--r == 0) break } else if (u >= 3 && u < 6)++r; else if (at.test(o)) f = !0; else if (f && !r) { ++i; break } f && !r && (t.fatArrowAt = i) } } function fi(n, t, i, r, u, f) { this.indented = n; this.column = t; this.type = i; this.prev = u; this.info = f; r != null && (this.align = r) } function gi(n, t) { for (var r, i = n.localVars; i; i = i.next) if (i.name == t) return !0; for (r = n.context; r; r = r.prev) for (i = r.vars; i; i = i.next) if (i.name == t) return !0 } function nr(n, t, i, r, f) { var e = n.cc, o; for (u.state = n, u.stream = f, u.marked = null, u.cc = e, u.style = t, n.lexical.hasOwnProperty("align") || (n.lexical.align = !0) ; ;) if (o = e.length ? e.pop() : p ? h : l, o(i, r)) { while (e.length && e[e.length - 1].lex) e.pop()(); return u.marked ? u.marked : i == "variable" && gi(n, r) ? "variable-2" : t } } function f() { for (var n = arguments.length - 1; n >= 0; n--) u.cc.push(arguments[n]) } function r() { return f.apply(null, arguments), !0 } function b(n) { function r(t) { for (var i = t; i; i = i.next) if (i.name == n) return !0; return !1 } var t = u.state; if (t.context) { if (u.marked = "def", r(t.localVars)) return; t.localVars = { name: n, next: t.localVars } } else { if (r(t.globalVars)) return; i.globalVars && (t.globalVars = { name: n, next: t.globalVars }) } } function k() { u.state.context = { prev: u.state.context, vars: u.state.localVars }; u.state.localVars = tr } function d() { u.state.localVars = u.state.context.vars; u.state.context = u.state.context.prev } function o(n, t) { var i = function () { var r = u.state, f = r.indented, i; if (r.lexical.type == "stat") f = r.lexical.indented; else for (i = r.lexical; i && i.type == ")" && i.align; i = i.prev) f = i.indented; r.lexical = new fi(f, u.stream.column(), n, null, r.lexical, t) }; return i.lex = !0, i } function e() { var n = u.state; n.lexical.prev && (n.lexical.type == ")" && (n.indented = n.lexical.indented), n.lexical = n.lexical.prev) } function s(n) { function t(i) { return i == n ? r() : n == ";" ? f() : r(t) } return t } function l(n, t) { return n == "var" ? r(o("vardef", t.length), dt, s(";"), e) : n == "keyword a" ? r(o("form"), h, l, e) : n == "keyword b" ? r(o("form"), l, e) : n == "{" ? r(o("}"), kt, e) : n == ";" ? r() : n == "if" ? (u.state.lexical.info == "else" && u.state.cc[u.state.cc.length - 1] == e && u.state.cc.pop()(), r(o("form"), h, l, e, ci)) : n == "function" ? r(v) : n == "for" ? r(o("form"), li, l, e) : n == "variable" ? r(o("stat"), ur) : n == "switch" ? r(o("form"), h, o("}", "switch"), s("{"), kt, e, e) : n == "case" ? r(h, s(":")) : n == "default" ? r(s(":")) : n == "catch" ? r(o("form"), k, s("("), ni, s(")"), l, e, d) : n == "module" ? r(o("form"), k, pr, d, e) : n == "class" ? r(o("form"), vr, e) : n == "export" ? r(o("form"), wr, e) : n == "import" ? r(o("form"), br, e) : f(o("stat"), h, s(";"), e) } function h(n) { return ei(n, !1) } function a(n) { return ei(n, !0) } function ei(n, t) { var c, i; if (u.state.fatArrowAt == u.stream.start) { if (c = t ? si : oi, n == "(") return r(k, o(")"), it(g, ")"), e, s("=>"), c, d); if (n == "variable") return f(k, g, s("=>"), c, d) } return (i = t ? bt : st, di.hasOwnProperty(n)) ? r(i) : n == "function" ? r(v, i) : n == "keyword c" ? r(t ? ir : wt) : n == "(" ? r(o(")"), wt, lt, s(")"), e, i) : n == "operator" || n == "spread" ? r(t ? a : h) : n == "[" ? r(o("]"), kr, e, i) : n == "{" ? rt(er, "}", null, i) : n == "quasi" ? f(ht, i) : r() } function wt(n) { return n.match(/[;\}\)\],]/) ? f() : f(h) } function ir(n) { return n.match(/[;\}\)\],]/) ? f() : f(a) } function st(n, t) { return n == "," ? r(h) : bt(n, t, !1) } function bt(n, t, i) { var u = i == !1 ? st : bt, c = i == !1 ? h : a; return t == "=>" ? r(k, i ? si : oi, d) : n == "operator" ? /\+\+|--/.test(t) ? r(u) : t == "?" ? r(h, s(":"), c) : r(c) : n == "quasi" ? f(ht, u) : n == ";" ? void 0 : n == "(" ? rt(a, ")", "call", u) : n == "." ? r(fr, u) : n == "[" ? r(o("]"), wt, s("]"), e, u) : void 0 } function ht(n, t) { return n != "quasi" ? f() : t.slice(t.length - 2) != "${" ? r(ht) : r(h, rr) } function rr(n) { if (n == "}") return u.marked = "string-2", u.state.tokenize = yt, r(ht) } function oi(n) { return (pt(u.stream, u.state), n == "{") ? f(l) : f(h) } function si(n) { return (pt(u.stream, u.state), n == "{") ? f(l) : f(a) } function ur(n) { return n == ":" ? r(e, l) : f(st, s(";"), e) } function fr(n) { if (n == "variable") return u.marked = "property", r() } function er(n, t) { return n == "variable" || u.style == "keyword" ? (u.marked = "property", t == "get" || t == "set") ? r(or) : r(tt) : n == "number" || n == "string" ? (u.marked = ft ? "property" : u.style + " property", r(tt)) : n == "jsonld-keyword" ? r(tt) : n == "[" ? r(h, s("]"), tt) : void 0 } function or(n) { return n != "variable" ? f(tt) : (u.marked = "property", r(v)) } function tt(n) { return n == ":" ? r(a) : n == "(" ? f(v) : void 0 } function it(n, t) { function i(f) { if (f == ",") { var e = u.state.lexical; return e.info == "call" && (e.pos = (e.pos || 0) + 1), r(n, i) } return f == t ? r() : r(s(t)) } return function (u) { return u == t ? r() : f(n, i) } } function rt(n, t, i) { for (var f = 3; f < arguments.length; f++) u.cc.push(arguments[f]); return r(o(t, i), it(n, t), e) } function kt(n) { return n == "}" ? r() : f(l, kt) } function hi(n) { if (ri && n == ":") return r(sr) } function sr(n) { if (n == "variable") return u.marked = "variable-3", r() } function dt() { return f(g, hi, gt, cr) } function g(n, t) { return n == "variable" ? (b(t), r()) : n == "[" ? rt(g, "]") : n == "{" ? rt(hr, "}") : void 0 } function hr(n, t) { return n == "variable" && !u.stream.match(/^\s*:/, !1) ? (b(t), r(gt)) : (n == "variable" && (u.marked = "property"), r(s(":"), g, gt)) } function gt(n, t) { if (t == "=") return r(a) } function cr(n) { if (n == ",") return r(dt) } function ci(n, t) { if (n == "keyword b" && t == "else") return r(o("form", "else"), l, e) } function li(n) { if (n == "(") return r(o(")"), lr, s(")"), e) } function lr(n) { return n == "var" ? r(dt, s(";"), ct) : n == ";" ? r(ct) : n == "variable" ? r(ar) : f(h, s(";"), ct) } function ar(n, t) { return t == "in" || t == "of" ? (u.marked = "keyword", r(h)) : r(st, ct) } function ct(n, t) { return n == ";" ? r(ai) : t == "in" || t == "of" ? (u.marked = "keyword", r(h)) : f(h, s(";"), ai) } function ai(n) { n != ")" && r(h) } function v(n, t) { return t == "*" ? (u.marked = "keyword", r(v)) : n == "variable" ? (b(t), r(v)) : n == "(" ? r(k, o(")"), it(ni, ")"), e, l, d) : void 0 } function ni(n) { return n == "spread" ? r(ni) : f(g, hi) } function vr(n, t) { if (n == "variable") return b(t), r(vi) } function vi(n, t) { return t == "extends" ? r(h, vi) : n == "{" ? r(o("}"), ut, e) : void 0 } function ut(n, t) { return n == "variable" || u.style == "keyword" ? (u.marked = "property", t == "get" || t == "set") ? r(yr, v, ut) : r(v, ut) : t == "*" ? (u.marked = "keyword", r(ut)) : n == ";" ? r(ut) : n == "}" ? r() : void 0 } function yr(n) { return n != "variable" ? f() : (u.marked = "property", r()) } function pr(n, t) { return n == "string" ? r(l) : n == "variable" ? (b(t), r(ti)) : void 0 } function wr(n, t) { return t == "*" ? (u.marked = "keyword", r(ti, s(";"))) : t == "default" ? (u.marked = "keyword", r(h, s(";"))) : f(l) } function br(n) { return n == "string" ? r() : f(yi, ti) } function yi(n, t) { return n == "{" ? rt(yi, "}") : (n == "variable" && b(t), r()) } function ti(n, t) { if (t == "from") return u.marked = "keyword", r(h) } function kr(n) { return n == "]" ? r() : f(a, dr) } function dr(n) { return n == "for" ? f(lt, s("]")) : n == "," ? r(it(a, "]")) : f(it(a, "]")) } function lt(n) { return n == "for" ? r(li, lt) : n == "if" ? r(h, lt) : void 0 } var y = t.indentUnit, ii = i.statementIndent, ft = i.jsonld, p = i.json || ft, ri = i.typescript, at = i.wordCharacters || /[\w$]/, ui = function () { function n(n) { return { type: n, style: "keyword" } } var s = n("keyword a"), u = n("keyword b"), t = n("keyword c"), f = n("operator"), i = { type: "atom", style: "atom" }, h = { "if": n("if"), "while": s, "with": s, "else": u, "do": u, "try": u, "finally": u, "return": t, "break": t, "continue": t, "new": t, "delete": t, "throw": t, "debugger": t, "var": n("var"), "const": n("var"), "let": n("var"), "function": n("function"), "catch": n("catch"), "for": n("for"), "switch": n("switch"), "case": n("case"), "default": n("default"), "in": f, "typeof": f, "instanceof": f, "true": i, "false": i, "null": i, undefined: i, NaN: i, Infinity: i, "this": n("this"), module: n("module"), "class": n("class"), "super": n("atom"), "yield": t, "export": n("export"), "import": n("import"), "extends": t }, r, e, o; if (ri) { r = { type: "variable", style: "variable-3" }; e = { "interface": n("interface"), "extends": n("extends"), constructor: n("constructor"), "public": n("public"), "private": n("private"), "protected": n("protected"), "static": n("static"), string: r, number: r, bool: r, any: r }; for (o in e) h[o] = e[o] } return h }(), vt = /[+\-*&%=<>!?|~^]/, pi = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/, nt, et, ki = "([{}])", di = { atom: !0, number: !0, variable: !0, string: !0, regexp: !0, "this": !0, "jsonld-keyword": !0 }, u = { state: null, column: null, marked: null, cc: null }, tr = { name: "this", next: { name: "arguments" } }; return e.lex = !0, { startState: function (n) { var t = { tokenize: w, lastType: "sof", cc: [], lexical: new fi((n || 0) - y, 0, "block", !1), localVars: i.localVars, context: i.localVars && { vars: i.localVars }, indented: 0 }; return i.globalVars && typeof i.globalVars == "object" && (t.globalVars = i.globalVars), t }, token: function (n, t) { if (n.sol() && (t.lexical.hasOwnProperty("align") || (t.lexical.align = !1), t.indented = n.indentation(), pt(n, t)), t.tokenize != ot && n.eatSpace()) return null; var i = t.tokenize(n, t); return nt == "comment" ? i : (t.lastType = nt == "operator" && (et == "++" || et == "--") ? "incdec" : nt, nr(t, i, nt, et, n)) }, indent: function (t, r) { var o, u, s, c, f, h; if (t.tokenize == ot) return n.Pass; if (t.tokenize != w) return 0; if (o = r && r.charAt(0), u = t.lexical, !/^\s*else\b/.test(r)) for (s = t.cc.length - 1; s >= 0; --s) if (c = t.cc[s], c == e) u = u.prev; else if (c != ci) break; return u.type == "stat" && o == "}" && (u = u.prev), ii && u.type == ")" && u.prev.type == "stat" && (u = u.prev), f = u.type, h = o == f, f == "vardef" ? u.indented + (t.lastType == "operator" || t.lastType == "," ? u.info + 1 : 0) : f == "form" && o == "{" ? u.indented : f == "form" ? u.indented + y : f == "stat" ? u.indented + (t.lastType == "operator" || t.lastType == "," ? ii || y : 0) : u.info != "switch" || h || i.doubleIndentSwitch == !1 ? u.align ? u.column + (h ? 0 : 1) : u.indented + (h ? 0 : y) : u.indented + (/^(?:case|default)\b/.test(r) ? y : 2 * y) }, electricChars: ":{}", blockCommentStart: p ? null : "/*", blockCommentEnd: p ? null : "*/", lineComment: p ? null : "//", fold: "brace", helperType: p ? "json" : "javascript", jsonldMode: ft, jsonMode: p } }); n.registerHelper("wordChars", "javascript", /[\w$]/); n.defineMIME("text/javascript", "javascript"); n.defineMIME("text/ecmascript", "javascript"); n.defineMIME("application/javascript", "javascript"); n.defineMIME("application/x-javascript", "javascript"); n.defineMIME("application/ecmascript", "javascript"); n.defineMIME("application/json", { name: "javascript", json: !0 }); n.defineMIME("application/x-json", { name: "javascript", json: !0 }); n.defineMIME("application/ld+json", { name: "javascript", jsonld: !0 }); n.defineMIME("text/typescript", { name: "javascript", typescript: !0 }); n.defineMIME("application/typescript", { name: "javascript", typescript: !0 }) });
//# sourceMappingURL=javascript.min.js.map