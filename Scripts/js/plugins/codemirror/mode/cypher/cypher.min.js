(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; var t = function (n) { return new RegExp("^(?:" + n.join("|") + ")$", "i") }; n.defineMode("cypher", function (i) { var o = function (n) { var t = n.next(), r = null, i; return t === '"' || t === "'" ? (n.match(/.+?["']/), "string") : /[{}\(\),\.;\[\]]/.test(t) ? (r = t, "node") : t === "/" && n.eat("/") ? (n.skipToEnd(), "comment") : e.test(t) ? (n.eatWhile(e), null) : (n.eatWhile(/[_\w\d]/), n.eat(":")) ? (n.eatWhile(/[\w\d_\-]/), "atom") : (i = n.current(), h.test(i)) ? "builtin" : c.test(i) ? "def" : l.test(i) ? "keyword" : "variable" }, u = function (n, t, i) { return n.context = { prev: n.context, indent: n.indent, col: i, type: t } }, f = function (n) { return n.indent = n.context.indent, n.context = n.context.prev }, s = i.indentUnit, r, h = t(["abs", "acos", "allShortestPaths", "asin", "atan", "atan2", "avg", "ceil", "coalesce", "collect", "cos", "cot", "count", "degrees", "e", "endnode", "exp", "extract", "filter", "floor", "haversin", "head", "id", "labels", "last", "left", "length", "log", "log10", "lower", "ltrim", "max", "min", "node", "nodes", "percentileCont", "percentileDisc", "pi", "radians", "rand", "range", "reduce", "rel", "relationship", "relationships", "replace", "right", "round", "rtrim", "shortestPath", "sign", "sin", "split", "sqrt", "startnode", "stdev", "stdevp", "str", "substring", "sum", "tail", "tan", "timestamp", "toFloat", "toInt", "trim", "type", "upper"]), c = t(["all", "and", "any", "has", "in", "none", "not", "or", "single", "xor"]), l = t(["as", "asc", "ascending", "assert", "by", "case", "commit", "constraint", "create", "csv", "cypher", "delete", "desc", "descending", "distinct", "drop", "else", "end", "false", "fieldterminator", "foreach", "from", "headers", "in", "index", "is", "limit", "load", "match", "merge", "null", "on", "optional", "order", "periodic", "remove", "return", "scan", "set", "skip", "start", "then", "true", "union", "unique", "unwind", "using", "when", "where", "with"]), e = /[*+\-<>=&|~%^]/; return { startState: function () { return { tokenize: o, context: null, indent: 0, col: 0 } }, token: function (n, t) { if (n.sol() && (t.context && t.context.align == null && (t.context.align = !1), t.indent = n.indentation()), n.eatSpace()) return null; var i = t.tokenize(n, t); if (i !== "comment" && t.context && t.context.align == null && t.context.type !== "pattern" && (t.context.align = !0), r === "(") u(t, ")", n.column()); else if (r === "[") u(t, "]", n.column()); else if (r === "{") u(t, "}", n.column()); else if (/[\]\}\)]/.test(r)) { while (t.context && t.context.type === "pattern") f(t); t.context && r === t.context.type && f(t) } else r === "." && t.context && t.context.type === "pattern" ? f(t) : /atom|string|variable/.test(i) && t.context && (/[\}\]]/.test(t.context.type) ? u(t, "pattern", n.column()) : t.context.type !== "pattern" || t.context.align || (t.context.align = !0, t.context.col = n.column())); return i }, indent: function (t, i) { var f = i && i.charAt(0), r = t.context, u; if (/[\]\}]/.test(f)) while (r && r.type === "pattern") r = r.prev; return (u = r && f === r.type, !r) ? 0 : r.type === "keywords" ? n.commands.newlineAndIndent : r.align ? r.col + (u ? 0 : 1) : r.indent + (u ? 0 : s) } } }); n.modeExtensions.cypher = { autoFormatLineBreaks: function (n) { for (var i = n.split("\n"), r = /\s+\b(return|where|order by|match|with|skip|limit|create|delete|set)\b\s/g, t = 0; t < i.length; t++) i[t] = i[t].replace(r, " \n$1 ").trim(); return i.join("\n") } }; n.defineMIME("application/x-cypher-query", "cypher") });
//# sourceMappingURL=cypher.min.js.map