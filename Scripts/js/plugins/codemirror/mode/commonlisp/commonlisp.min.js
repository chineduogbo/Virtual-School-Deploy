(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("commonlisp", function (n) { function r(n) { for (var t; t = n.next() ;) if (t == "\\") n.next(); else if (!e.test(t)) { n.backUp(1); break } return n.current() } function i(n, i) { var u, e; return n.eatSpace() ? (t = "ws", null) : n.match(f) ? "number" : (u = n.next(), u == "\\" && (u = n.next()), u == '"' ? (i.tokenize = o)(n, i) : u == "(" ? (t = "open", "bracket") : u == ")" || u == "]" ? (t = "close", "bracket") : u == ";" ? (n.skipToEnd(), t = "ws", "comment") : /['`,@]/.test(u) ? null : u == "|" ? n.skipTo("|") ? (n.next(), "symbol") : (n.skipToEnd(), "error") : u == "#" ? (u = n.next(), u == "[" ? (t = "open", "bracket") : /[+\-=\.']/.test(u) ? null : /\d/.test(u) && n.match(/^\d*#/) ? null : u == "|" ? (i.tokenize = s)(n, i) : u == ":" ? (r(n), "meta") : "error") : (e = r(n), e == ".") ? null : (t = "symbol", e == "nil" || e == "t") ? "atom" : e.charAt(0) == ":" ? "keyword" : e.charAt(0) == "&" ? "variable-2" : "variable") } function o(n, t) { for (var r = !1, u; u = n.next() ;) { if (u == '"' && !r) { t.tokenize = i; break } r = !r && u == "\\" } return "string" } function s(n, r) { for (var u, f; u = n.next() ;) { if (u == "#" && f == "|") { r.tokenize = i; break } f = u } return t = "ws", "comment" } var u = /^with|^def|^do|^prog|case$|^cond$|bind$|when$|unless$/, f = /^(?:[+\-]?(?:\d+|\d*\.\d+)(?:[efd][+\-]?\d+)?|[+\-]?\d+(?:\/[+\-]?\d+)?|#b[+\-]?[01]+|#o[+\-]?[0-7]+|#x[+\-]?[\da-f]+)/, e = /[^\s'`,@()\[\]";]/, t; return { startState: function () { return { ctx: { prev: null, start: 0, indentTo: 0 }, tokenize: i } }, token: function (i, r) { i.sol() && typeof r.ctx.indentTo != "number" && (r.ctx.indentTo = r.ctx.start + 1); t = null; var f = r.tokenize(i, r); return t != "ws" && (r.ctx.indentTo == null ? r.ctx.indentTo = t == "symbol" && u.test(i.current()) ? r.ctx.start + n.indentUnit : "next" : r.ctx.indentTo == "next" && (r.ctx.indentTo = i.column())), t == "open" ? r.ctx = { prev: r.ctx, start: i.column(), indentTo: null } : t == "close" && (r.ctx = r.ctx.prev || r.ctx), f }, indent: function (n) { var t = n.ctx.indentTo; return typeof t == "number" ? t : n.ctx.start + 1 }, lineComment: ";;", blockCommentStart: "#|", blockCommentEnd: "|#" } }); n.defineMIME("text/x-common-lisp", "commonlisp") });
//# sourceMappingURL=commonlisp.min.js.map