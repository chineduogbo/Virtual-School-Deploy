(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("go", function (n) { function i(n, i) { var r = n.next(), u; if (r == '"' || r == "'" || r == "`") return i.tokenize = l(r), i.tokenize(n, i); if (/[\d\.]/.test(r)) return r == "." ? n.match(/^[0-9]+([eE][\-+]?[0-9]+)?/) : r == "0" ? n.match(/^[xX][0-9a-fA-F]+/) || n.match(/^0[0-7]+/) : n.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/), "number"; if (/[\[\]{}\(\),;\:\.]/.test(r)) return t = r, null; if (r == "/") { if (n.eat("*")) return i.tokenize = e, e(n, i); if (n.eat("/")) return n.skipToEnd(), "comment" } return f.test(r) ? (n.eatWhile(f), "operator") : (n.eatWhile(/[\w\$_]/), u = n.current(), h.propertyIsEnumerable(u)) ? ((u == "case" || u == "default") && (t = "case"), "keyword") : c.propertyIsEnumerable(u) ? "atom" : "variable" } function l(n) { return function (t, r) { for (var u = !1, f, e = !1; (f = t.next()) != null;) { if (f == n && !u) { e = !0; break } u = !u && f == "\\" } return !e && (u || n == "`") || (r.tokenize = i), "string" } } function e(n, t) { for (var u = !1, r; r = n.next() ;) { if (r == "/" && u) { t.tokenize = i; break } u = r == "*" } return "comment" } function o(n, t, i, r, u) { this.indented = n; this.column = t; this.type = i; this.align = r; this.prev = u } function r(n, t, i) { return n.context = new o(n.indented, t, i, null, n.context) } function s(n) { var t = n.context.type; return (t == ")" || t == "]" || t == "}") && (n.indented = n.context.indented), n.context = n.context.prev } var u = n.indentUnit, h = { "break": !0, "case": !0, chan: !0, "const": !0, "continue": !0, "default": !0, defer: !0, "else": !0, fallthrough: !0, "for": !0, func: !0, go: !0, goto: !0, "if": !0, "import": !0, "interface": !0, map: !0, "package": !0, range: !0, "return": !0, select: !0, struct: !0, "switch": !0, type: !0, "var": !0, bool: !0, byte: !0, complex64: !0, complex128: !0, float32: !0, float64: !0, int8: !0, int16: !0, int32: !0, int64: !0, string: !0, uint8: !0, uint16: !0, uint32: !0, uint64: !0, int: !0, uint: !0, uintptr: !0 }, c = { "true": !0, "false": !0, iota: !0, nil: !0, append: !0, cap: !0, close: !0, complex: !0, copy: !0, imag: !0, len: !0, make: !0, "new": !0, panic: !0, print: !0, println: !0, real: !0, recover: !0 }, f = /[+\-*&^%:=<>!|\/]/, t; return { startState: function (n) { return { tokenize: null, context: new o((n || 0) - u, 0, "top", !1), indented: 0, startOfLine: !0 } }, token: function (n, u) { var f = u.context, e; return (n.sol() && (f.align == null && (f.align = !1), u.indented = n.indentation(), u.startOfLine = !0, f.type == "case" && (f.type = "}")), n.eatSpace()) ? null : (t = null, e = (u.tokenize || i)(n, u), e == "comment") ? e : (f.align == null && (f.align = !0), t == "{" ? r(u, n.column(), "}") : t == "[" ? r(u, n.column(), "]") : t == "(" ? r(u, n.column(), ")") : t == "case" ? f.type = "case" : t == "}" && f.type == "}" ? f = s(u) : t == f.type && s(u), u.startOfLine = !1, e) }, indent: function (n, t) { var r, e, f; return n.tokenize != i && n.tokenize != null ? 0 : (r = n.context, e = t && t.charAt(0), r.type == "case" && /^(?:case|default)\b/.test(t)) ? (n.context.type = "}", r.indented) : (f = e == r.type, r.align ? r.column + (f ? 0 : 1) : r.indented + (f ? 0 : u)) }, electricChars: "{}):", fold: "brace", blockCommentStart: "/*", blockCommentEnd: "*/", lineComment: "//" } }); n.defineMIME("text/x-go", "go") });
//# sourceMappingURL=go.min.js.map