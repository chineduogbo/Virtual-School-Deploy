(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror"), require("../htmlmixed/htmlmixed"), require("../smarty/smarty")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror", "../htmlmixed/htmlmixed", "../smarty/smarty"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("smartymixed", function (t) { function c(n) { return n.replace(/[^\s\w]/g, "\\$&") } var r = n.getMode(t, "htmlmixed"), u = n.getMode(t, "smarty"), i = { rightDelimiter: "}", leftDelimiter: "{" }; t.hasOwnProperty("leftDelimiter") && (i.leftDelimiter = t.leftDelimiter); t.hasOwnProperty("rightDelimiter") && (i.rightDelimiter = t.rightDelimiter); var s = c(i.leftDelimiter), h = c(i.rightDelimiter), e = { smartyComment: new RegExp("^" + h + "\\*"), literalOpen: new RegExp(s + "literal" + h), literalClose: new RegExp(s + "/literal" + h), hasLeftDelimeter: new RegExp(".*" + s), htmlHasLeftDelimeter: new RegExp("[^<>]*" + s) }, o = { chain: function (n, t, i) { return t.tokenize = i, i(n, t) }, cleanChain: function (n, t, i) { return t.tokenize = null, t.localState = null, t.localMode = null, typeof i == "string" ? i ? i : null : i(n, t) }, maybeBackup: function (n, t, i) { var r = n.current(), u = r.search(t), f; return u > -1 ? n.backUp(r.length - u) : (f = r.match(/<\/?$/)) && (n.backUp(r.length), n.match(t, !1) || n.match(r[0])), i } }, f = { html: function (n, t) { return !t.inLiteral && n.match(e.htmlHasLeftDelimeter, !1) && t.htmlMixedState.htmlState.tagName === null ? (t.tokenize = f.smarty, t.localMode = u, t.localState = u.startState(r.indent(t.htmlMixedState, "")), o.maybeBackup(n, i.leftDelimiter, u.token(n, t.localState))) : !t.inLiteral && n.match(i.leftDelimiter, !1) ? (t.tokenize = f.smarty, t.localMode = u, t.localState = u.startState(r.indent(t.htmlMixedState, "")), o.maybeBackup(n, i.leftDelimiter, u.token(n, t.localState))) : r.token(n, t.htmlMixedState) }, smarty: function (n, t) { if (n.match(i.leftDelimiter, !1)) { if (n.match(e.smartyComment, !1)) return o.chain(n, t, f.inBlock("comment", "*" + i.rightDelimiter)) } else if (n.match(i.rightDelimiter, !1)) return n.eat(i.rightDelimiter), t.tokenize = f.html, t.localMode = r, t.localState = t.htmlMixedState, "tag"; return o.maybeBackup(n, i.rightDelimiter, u.token(n, t.localState)) }, inBlock: function (n, t) { return function (i, r) { while (!i.eol()) { if (i.match(t)) { o.cleanChain(i, r, ""); break } i.next() } return n } } }; return { startState: function () { var n = r.startState(); return { token: f.html, localMode: null, localState: null, htmlMixedState: n, tokenize: null, inLiteral: !1 } }, copyState: function (t) { var i = null, e = t.tokenize || t.token; return t.localState && (i = n.copyState(e != f.html ? u : r, t.localState)), { token: t.token, tokenize: t.tokenize, localMode: t.localMode, localState: i, htmlMixedState: n.copyState(r, t.htmlMixedState), inLiteral: t.inLiteral } }, token: function (n, t) { if (n.match(i.leftDelimiter, !1)) { if (!t.inLiteral && n.match(e.literalOpen, !0)) return t.inLiteral = !0, "keyword"; if (t.inLiteral && n.match(e.literalClose, !0)) return t.inLiteral = !1, "keyword" } t.inLiteral && t.localState != t.htmlMixedState && (t.tokenize = f.html, t.localMode = r, t.localState = t.htmlMixedState); return (t.tokenize || t.token)(n, t) }, indent: function (t, i) { return t.localMode == u || t.inLiteral && !t.localMode || e.hasLeftDelimeter.test(i) ? n.Pass : r.indent(t.htmlMixedState, i) }, innerMode: function (n) { return { state: n.localState || n.htmlMixedState, mode: n.localMode || r } } } }, "htmlmixed", "smarty"); n.defineMIME("text/x-smarty", "smartymixed") });
//# sourceMappingURL=smartymixed.min.js.map