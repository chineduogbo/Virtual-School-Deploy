(function (n) { typeof exports == "object" && typeof module == "object" ? n(require("../../lib/codemirror")) : typeof define == "function" && define.amd ? define(["../../lib/codemirror"], n) : n(CodeMirror) })(function (n) { "use strict"; n.defineMode("tiki", function (n) { function u(n, t, i) { return function (u, f) { while (!u.eol()) { if (u.match(t)) { f.tokenize = r; break } u.next() } return i && (f.tokenize = i), n } } function f(n) { return function (t, i) { while (!t.eol()) t.next(); return i.tokenize = r, n } } function r(n, t) { function i(i) { return t.tokenize = i, i(n, t) } var h = n.sol(), e = n.next(), o, s; switch (e) { case "{": for (n.eat("/"), n.eatSpace(), o = ""; s = n.eat(/[^\s\u00a0=\"\'\/?(}]/) ;) o += s; return t.tokenize = c, "tag"; case "_": if (n.eat("_")) return i(u("strong", "__", r)); break; case "'": if (n.eat("'")) return i(u("em", "''", r)); break; case "(": if (n.eat("(")) return i(u("variable-2", "))", r)); break; case "[": return i(u("variable-3", "]", r)); case "|": if (n.eat("|")) return i(u("comment", "||")); break; case "-": if (n.eat("=")) return i(u("header string", "=-", r)); if (n.eat("-")) return i(u("error tw-deleted", "--", r)); break; case "=": if (n.match("==")) return i(u("tw-underline", "===", r)); break; case ":": if (n.eat(":")) return i(u("comment", "::")); break; case "^": return i(u("tw-box", "^")); case "~": if (n.match("np~")) return i(u("meta", "~/np~")) } if (h) switch (e) { case "!": return n.match("!!!!!") ? i(f("header string")) : n.match("!!!!") ? i(f("header string")) : n.match("!!!") ? i(f("header string")) : n.match("!!") ? i(f("header string")) : i(f("header string")); case "*": case "#": case "+": return i(f("tw-listitem bracket")) } return null } function c(n, t) { var i = n.next(), u = n.peek(); return i == "}" ? (t.tokenize = r, "tag") : i == "(" || i == ")" ? "bracket" : i == "=" ? (s = "equals", u == ">" && (i = n.next(), u = n.peek()), /[\'\"]/.test(u) || (t.tokenize = b()), "operator") : /[\'\"]/.test(i) ? (t.tokenize = w(i), t.tokenize(n, t)) : (n.eatWhile(/[^\s\u00a0=\"\'\/?]/), "keyword") } function w(n) { return function (t, i) { while (!t.eol()) if (t.next() == n) { i.tokenize = c; break } return "string" } } function b() { return function (n, t) { while (!n.eol()) { var i = n.next(), r = n.peek(); if (i == " " || i == "," || /[ )}]/.test(r)) { t.tokenize = c; break } } return "string" } } function o() { for (var n = arguments.length - 1; n >= 0; n--) t.cc.push(arguments[n]) } function i() { return o.apply(null, arguments), !0 } function a(n, i) { var r = t.context && t.context.noIndent; t.context = { prev: t.context, pluginName: n, indent: t.indented, startOfLine: i, noIndent: r } } function v() { t.context && (t.context = t.context.prev) } function k(n) { if (n == "openPlugin") return t.pluginName = h, i(l, d(t.startOfLine)); if (n == "closePlugin") { var u = !1; return t.context ? (u = t.context.pluginName != h, v()) : u = !0, u && (e = "error"), i(g(u)) } return n == "string" ? (t.context && t.context.name == "!cdata" || a("!cdata"), t.tokenize == r && v(), i()) : i() } function d(n) { return function (r) { return r == "selfclosePlugin" || r == "endPlugin" ? i() : r == "endPlugin" ? (a(t.pluginName, n), i()) : i() } } function g(n) { return function (t) { return (n && (e = "error"), t == "endPlugin") ? i() : o() } } function l(n) { return n == "keyword" ? (e = "attribute", i(l)) : n == "equals" ? i(nt, l) : o() } function nt(n) { return n == "keyword" ? (e = "string", i()) : n == "string" ? i(y) : o() } function y(n) { return n == "string" ? i(y) : o() } var p = n.indentUnit, h, s, t, e; return { startState: function () { return { tokenize: r, cc: [], indented: 0, startOfLine: !0, pluginName: null, context: null } }, token: function (n, i) { var r, u; if (n.sol() && (i.startOfLine = !0, i.indented = n.indentation()), n.eatSpace()) return null; if (e = s = h = null, r = i.tokenize(n, i), (r || s) && r != "comment") for (t = i; ;) if (u = i.cc.pop() || k, u(s || r)) break; return i.startOfLine = !1, e || r }, indent: function (n, t) { var i = n.context; if (i && i.noIndent) return 0; for (i && /^{\//.test(t) && (i = i.prev) ; i && !i.startOfLine;) i = i.prev; return i ? i.indent + p : 0 }, electricChars: "/" } }); n.defineMIME("text/tiki", "tiki") });
//# sourceMappingURL=tiki.min.js.map