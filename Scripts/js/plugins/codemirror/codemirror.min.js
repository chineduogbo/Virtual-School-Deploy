(function (n) { if (typeof exports == "object" && typeof module == "object") module.exports = n(); else { if (typeof define == "function" && define.amd) return define([], n); this.CodeMirror = n() } })(function () { "use strict"; function t(n, i) { var u, f, r; if (!(this instanceof t)) return new t(n, i); this.options = i = i || {}; vf(ev, i, !1); go(i); u = i.value; typeof u == "string" && (u = new tt(u, i.mode)); this.doc = u; f = this.display = new gp(n, u); f.wrapper.CodeMirror = this; dc(this); kc(this); i.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"); i.autofocus && !vo && it(this); this.state = { keyMaps: [], overlays: [], modeGen: 0, overwrite: !1, focused: !1, suppressEdits: !1, pasteIncoming: !1, cutIncoming: !1, draggingText: !1, highlight: new dh }; s && h < 11 && setTimeout(kt(lt, this, !0), 20); sb(this); od(); r = this; ni(this, function () { var n, t; r.curOp.forceUpdate = !0; ay(r, u); i.autofocus && !vo || vi() == f.input ? setTimeout(kt(th, r), 20) : ye(r); for (n in nr) nr.hasOwnProperty(n) && nr[n](r, i[n], eh); for (nl(r), t = 0; t < ge.length; ++t) ge[t](r) }) } function gp(n, t) { var r = this, u = r.input = i("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none"); p ? u.style.width = "1000px" : u.setAttribute("wrap", "off"); tu && (u.style.border = "1px solid black"); u.setAttribute("autocorrect", "off"); u.setAttribute("autocapitalize", "off"); u.setAttribute("spellcheck", "false"); r.inputDiv = i("div", [u], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"); r.scrollbarH = i("div", [i("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar"); r.scrollbarV = i("div", [i("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"); r.scrollbarFiller = i("div", null, "CodeMirror-scrollbar-filler"); r.gutterFiller = i("div", null, "CodeMirror-gutter-filler"); r.lineDiv = i("div", null, "CodeMirror-code"); r.selectionDiv = i("div", null, null, "position: relative; z-index: 1"); r.cursorDiv = i("div", null, "CodeMirror-cursors"); r.measure = i("div", null, "CodeMirror-measure"); r.lineMeasure = i("div", null, "CodeMirror-measure"); r.lineSpace = i("div", [r.measure, r.lineMeasure, r.selectionDiv, r.cursorDiv, r.lineDiv], null, "position: relative; outline: none"); r.mover = i("div", [i("div", [r.lineSpace], "CodeMirror-lines")], null, "position: relative"); r.sizer = i("div", [r.mover], "CodeMirror-sizer"); r.heightForcer = i("div", null, null, "position: absolute; height: " + bt + "px; width: 1px;"); r.gutters = i("div", null, "CodeMirror-gutters"); r.lineGutter = null; r.scroller = i("div", [r.sizer, r.heightForcer, r.gutters], "CodeMirror-scroll"); r.scroller.setAttribute("tabIndex", "-1"); r.wrapper = i("div", [r.inputDiv, r.scrollbarH, r.scrollbarV, r.scrollbarFiller, r.gutterFiller, r.scroller], "CodeMirror"); s && h < 8 && (r.gutters.style.zIndex = -1, r.scroller.style.paddingRight = 0); tu && (u.style.width = "0px"); p || (r.scroller.draggable = !0); ao && (r.inputDiv.style.height = "1px", r.inputDiv.style.position = "absolute"); s && h < 8 && (r.scrollbarH.style.minHeight = r.scrollbarV.style.minWidth = "18px"); n.appendChild ? n.appendChild(r.wrapper) : n(r.wrapper); r.viewFrom = r.viewTo = t.first; r.view = []; r.externalMeasured = null; r.viewOffset = 0; r.lastSizeC = 0; r.updateLineNumbers = null; r.lineNumWidth = r.lineNumInnerWidth = r.lineNumChars = null; r.prevInput = ""; r.alignWidgets = !1; r.pollingFast = !1; r.poll = new dh; r.cachedCharWidth = r.cachedTextHeight = r.cachedPaddingH = null; r.inaccurateSelection = !1; r.maxLine = null; r.maxLineLength = 0; r.maxLineChanged = !1; r.wheelDX = r.wheelDY = r.wheelStartX = r.wheelStartY = null; r.shift = !1; r.selForContextMenu = null } function po(n) { n.doc.mode = t.getMode(n.options, n.doc.modeOption); iu(n) } function iu(n) { n.doc.iter(function (n) { n.stateAfter && (n.stateAfter = null); n.styles && (n.styles = null) }); n.doc.frontier = n.doc.first; ou(n, 100); n.state.modeGen++; n.curOp && rt(n) } function nw(n) { n.options.lineWrapping ? (ho(n.display.wrapper, "CodeMirror-wrap"), n.display.sizer.style.minWidth = "") : (so(n.display.wrapper, "CodeMirror-wrap"), ko(n)); wo(n); rt(n); hu(n); setTimeout(function () { pi(n) }, 100) } function wc(n) { var t = ki(n.display), i = n.options.lineWrapping, r = i && Math.max(5, n.display.scroller.clientWidth / cu(n.display) - 3); return function (u) { var e, f; if (tr(n.doc, u)) return 0; if (e = 0, u.widgets) for (f = 0; f < u.widgets.length; f++) u.widgets[f].height && (e += u.widgets[f].height); return i ? e + (Math.ceil(u.text.length / r) || 1) * t : e + t } } function wo(n) { var t = n.doc, i = wc(n); t.iter(function (n) { var t = i(n); t != n.height && yt(n, t) }) } function bc(n) { var i = at[n.options.keyMap], t = i.style; n.display.wrapper.className = n.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") + (t ? " cm-keymap-" + t : "") } function kc(n) { n.display.wrapper.className = n.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + n.options.theme.replace(/(^|\s)\s*/g, " cm-s-"); hu(n) } function ru(n) { dc(n); rt(n); setTimeout(function () { ts(n) }, 20) } function dc(n) { var r = n.display.gutters, e = n.options.gutters, t, u, f; for (ur(r), t = 0; t < e.length; ++t) u = e[t], f = r.appendChild(i("div", null, "CodeMirror-gutter " + u)), u == "CodeMirror-linenumbers" && (n.display.lineGutter = f, f.style.width = (n.display.lineNumWidth || 1) + "px"); r.style.display = t ? "" : "none"; bo(n) } function bo(n) { var t = n.display.gutters.offsetWidth; n.display.sizer.style.marginLeft = t + "px"; n.display.scrollbarH.style.left = n.options.fixedGutter ? t + "px" : 0 } function bf(n) { var r, u, t, i; if (n.height == 0) return 0; for (r = n.text.length, t = n; u = wv(t) ;) i = u.find(0, !0), t = i.from.line, r += i.from.ch - i.to.ch; for (t = n; u = nf(t) ;) i = u.find(0, !0), r -= t.text.length - i.from.ch, t = i.to.line, r += t.text.length - i.to.ch; return r } function ko(n) { var t = n.display, i = n.doc; t.maxLine = r(i, i.first); t.maxLineLength = bf(t.maxLine); t.maxLineChanged = !0; i.iter(function (n) { var i = bf(n); i > t.maxLineLength && (t.maxLineLength = i, t.maxLine = n) }) } function go(n) { var t = k(n.gutters, "CodeMirror-linenumbers"); t == -1 && n.lineNumbers ? n.gutters = n.gutters.concat(["CodeMirror-linenumbers"]) : t > -1 && !n.lineNumbers && (n.gutters = n.gutters.slice(0), n.gutters.splice(t, 1)) } function gc(n) { return n.display.scroller.clientHeight - n.display.wrapper.clientHeight < bt - 3 } function kf(n) { var t = n.display.scroller; return { clientHeight: t.clientHeight, barHeight: n.display.scrollbarV.clientHeight, scrollWidth: t.scrollWidth, clientWidth: t.clientWidth, hScrollbarTakesSpace: gc(n), barWidth: n.display.scrollbarH.clientWidth, docHeight: Math.round(n.doc.height + ys(n.display)) } } function pi(n, t) { var f, h, o; t || (t = kf(n)); var i = n.display, r = hd(i.measure), s = t.docHeight + bt, u = t.scrollWidth > t.clientWidth; u && t.scrollWidth <= t.clientWidth + 1 && r > 0 && !t.hScrollbarTakesSpace && (u = !1); f = s > t.clientHeight; f ? (i.scrollbarV.style.display = "block", i.scrollbarV.style.bottom = u ? r + "px" : "0", i.scrollbarV.firstChild.style.height = Math.max(0, s - t.clientHeight + (t.barHeight || i.scrollbarV.clientHeight)) + "px") : (i.scrollbarV.style.display = "", i.scrollbarV.firstChild.style.height = "0"); u ? (i.scrollbarH.style.display = "block", i.scrollbarH.style.right = f ? r + "px" : "0", i.scrollbarH.firstChild.style.width = t.scrollWidth - t.clientWidth + (t.barWidth || i.scrollbarH.clientWidth) + "px") : (i.scrollbarH.style.display = "", i.scrollbarH.firstChild.style.width = "0"); u && f ? (i.scrollbarFiller.style.display = "block", i.scrollbarFiller.style.height = i.scrollbarFiller.style.width = r + "px") : i.scrollbarFiller.style.display = ""; u && n.options.coverGutterNextToScrollbar && n.options.fixedGutter ? (i.gutterFiller.style.display = "block", i.gutterFiller.style.height = r + "px", i.gutterFiller.style.width = i.gutters.offsetWidth + "px") : i.gutterFiller.style.display = ""; !n.state.checkedOverlayScrollbar && t.clientHeight > 0 && (r === 0 && (h = ot && !bp ? "12px" : "18px", i.scrollbarV.style.minWidth = i.scrollbarH.style.minHeight = h, o = function (t) { sf(t) != i.scrollbarV && sf(t) != i.scrollbarH && v(n, ca)(t) }, e(i.scrollbarV, "mousedown", o), e(i.scrollbarH, "mousedown", o)), n.state.checkedOverlayScrollbar = !0) } function ns(n, t, i) { var u = i && i.top != null ? Math.max(0, i.top) : n.scroller.scrollTop, f, e; u = Math.floor(u - re(n)); var h = i && i.bottom != null ? i.bottom : u + n.wrapper.clientHeight, o = rr(t, u), s = rr(t, h); if (i && i.ensure) { if (f = i.ensure.from.line, e = i.ensure.to.line, f < o) return { from: f, to: rr(t, ri(r(t, f)) + n.wrapper.clientHeight) }; if (Math.min(e, t.lastLine()) >= s) return { from: rr(t, ri(r(t, e)) - n.wrapper.clientHeight), to: e } } return { from: o, to: Math.max(s, o + 1) } } function ts(n) { var t = n.display, r = t.view, i, u, f; if (t.alignWidgets || t.gutters.firstChild && n.options.fixedGutter) { var e = rs(t) - t.scroller.scrollLeft + n.doc.scrollLeft, s = t.gutters.offsetWidth, o = e + "px"; for (i = 0; i < r.length; i++) if (!r[i].hidden && (n.options.fixedGutter && r[i].gutter && (r[i].gutter.style.left = o), u = r[i].alignable, u)) for (f = 0; f < u.length; f++) u[f].style.left = o; n.options.fixedGutter && (t.gutters.style.left = e + s + "px") } } function nl(n) { if (!n.options.lineNumbers) return !1; var u = n.doc, r = is(n.options, u.first + u.size - 1), t = n.display; if (r.length != t.lineNumChars) { var f = t.measure.appendChild(i("div", [i("div", r)], "CodeMirror-linenumber CodeMirror-gutter-elt")), e = f.firstChild.offsetWidth, o = f.offsetWidth - e; return t.lineGutter.style.width = "", t.lineNumInnerWidth = Math.max(e, t.lineGutter.offsetWidth - o), t.lineNumWidth = t.lineNumInnerWidth + o, t.lineNumChars = t.lineNumInnerWidth ? r.length : -1, t.lineGutter.style.width = t.lineNumWidth + "px", bo(n), !0 } return !1 } function is(n, t) { return String(n.lineNumberFormatter(t + n.firstLineNumber)) } function rs(n) { return n.scroller.getBoundingClientRect().left - n.sizer.getBoundingClientRect().left } function tl(n, t, i) { var r = n.display; this.viewport = t; this.visible = ns(r, n.doc, t); this.editorIsHidden = !r.wrapper.offsetWidth; this.wrapperHeight = r.wrapper.clientHeight; this.oldViewFrom = r.viewFrom; this.oldViewTo = r.viewTo; this.oldScrollerWidth = r.scroller.clientWidth; this.force = i; this.dims = ss(n) } function us(n, t) { var i = n.display, o = n.doc, h, s, e; if (t.editorIsHidden) return oi(n), !1; if (!t.force && t.visible.from >= i.viewFrom && t.visible.to <= i.viewTo && (i.updateLineNumbers == null || i.updateLineNumbers >= i.viewTo) && ha(n) == 0) return !1; nl(n) && (oi(n), t.dims = ss(n)); var c = o.first + o.size, u = Math.max(t.visible.from - n.options.viewportMargin, o.first), f = Math.min(c, t.visible.to + n.options.viewportMargin); return (i.viewFrom < u && u - i.viewFrom < 20 && (u = Math.max(o.first, i.viewFrom)), i.viewTo > f && i.viewTo - f < 20 && (f = Math.min(c, i.viewTo)), ei && (u = ch(n.doc, u), f = kv(n.doc, f)), h = u != i.viewFrom || f != i.viewTo || i.lastSizeC != t.wrapperHeight, ob(n, u, f), i.viewOffset = ri(r(n.doc, i.viewFrom)), n.display.mover.style.top = i.viewOffset + "px", s = ha(n), !h && s == 0 && !t.force && (i.updateLineNumbers == null || i.updateLineNumbers >= i.viewTo)) ? !1 : (e = vi(), s > 4 && (i.lineDiv.style.display = "none"), iw(n, i.updateLineNumbers, t.dims), s > 4 && (i.lineDiv.style.display = ""), e && vi() != e && e.offsetHeight && e.focus(), ur(i.cursorDiv), ur(i.selectionDiv), h && (i.lastSizeC = t.wrapperHeight, ou(n, 400)), i.updateLineNumbers = null, !0) } function il(n, t) { for (var r, u = t.force, i = t.viewport, f = !0; ; f = !1) { if (f && n.options.lineWrapping && t.oldScrollerWidth != n.display.scroller.clientWidth) u = !0; else if (u = !1, i && i.top != null && (i = { top: Math.min(n.doc.height + ys(n.display) - bt - n.display.scroller.clientHeight, i.top) }), t.visible = ns(n.display, n.doc, i), t.visible.from >= n.display.viewFrom && t.visible.to <= n.display.viewTo) break; if (!us(n, t)) break; os(n); r = kf(n); eu(n); es(n, r); pi(n, r) } b(n, "update", n); (n.display.viewFrom != t.oldViewFrom || n.display.viewTo != t.oldViewTo) && b(n, "viewportChange", n, n.display.viewFrom, n.display.viewTo) } function fs(n, t) { var r = new tl(n, t), i; us(n, r) && (os(n), il(n, r), i = kf(n), eu(n), es(n, i), pi(n, i)) } function es(n, t) { n.display.sizer.style.minHeight = n.display.heightForcer.style.top = t.docHeight + "px"; n.display.gutters.style.height = Math.max(t.docHeight, t.clientHeight - bt) + "px" } function tw(n, t) { n.display.sizer.offsetWidth + n.display.gutters.offsetWidth < n.display.scroller.clientWidth - 1 && (n.display.sizer.style.minHeight = n.display.heightForcer.style.top = "0px", n.display.gutters.style.height = t.docHeight + "px") } function os(n) { for (var t, i, e, o, c, u, r = n.display, l = r.lineDiv.offsetTop, f = 0; f < r.view.length; f++) if ((t = r.view[f], !t.hidden) && (s && h < 8 ? (e = t.node.offsetTop + t.node.offsetHeight, i = e - l, l = e) : (o = t.node.getBoundingClientRect(), i = o.bottom - o.top), c = t.line.height - i, i < 2 && (i = ki(r)), (c > .001 || c < -.001) && (yt(t.line, i), rl(t.line), t.rest))) for (u = 0; u < t.rest.length; u++) rl(t.rest[u]) } function rl(n) { if (n.widgets) for (var t = 0; t < n.widgets.length; ++t) n.widgets[t].height = n.widgets[t].node.offsetHeight } function ss(n) { for (var i = n.display, u = {}, f = {}, t = i.gutters.firstChild, r = 0; t; t = t.nextSibling, ++r) u[n.options.gutters[r]] = t.offsetLeft, f[n.options.gutters[r]] = t.offsetWidth; return { fixedPos: rs(i), gutterTotalWidth: i.gutters.offsetWidth, gutterLeft: u, gutterWidth: f, wrapperWidth: i.wrapper.clientWidth } } function iw(n, t, i) { function c(t) { var i = t.nextSibling; return p && ot && n.display.currentWheelTarget == t ? t.style.display = "none" : t.parentNode.removeChild(t), i } for (var r, a, s, e = n.display, v = n.options.lineNumbers, h = e.lineDiv, u = h.firstChild, l = e.view, f = e.viewFrom, o = 0; o < l.length; o++) { if (r = l[o], !r.hidden) if (r.node) { while (u != r.node) u = c(u); s = v && t != null && t <= f && r.lineNumber; r.changes && (k(r.changes, "gutter") > -1 && (s = !1), ul(n, r, f, i)); s && (ur(r.lineNumber), r.lineNumber.appendChild(document.createTextNode(is(n.options, f)))); u = r.node.nextSibling } else a = ew(n, r, f, i), h.insertBefore(a, u); f += r.size } while (u) u = c(u) } function ul(n, t, i, r) { for (var u, f = 0; f < t.changes.length; f++) u = t.changes[f], u == "text" ? uw(n, t) : u == "gutter" ? el(n, t, i, r) : u == "class" ? hs(t) : u == "widget" && fw(t, r); t.changes = null } function df(n) { return n.node == n.text && (n.node = i("div", null, null, "position: relative"), n.text.parentNode && n.text.parentNode.replaceChild(n.node, n.text), n.node.appendChild(n.text), s && h < 8 && (n.node.style.zIndex = 2)), n.node } function rw(n) { var t = n.bgClass ? n.bgClass + " " + (n.line.bgClass || "") : n.line.bgClass, r; t && (t += " CodeMirror-linebackground"); n.background ? t ? n.background.className = t : (n.background.parentNode.removeChild(n.background), n.background = null) : t && (r = df(n), n.background = r.insertBefore(i("div", null, t), r.firstChild)) } function fl(n, t) { var i = n.display.externalMeasured; return i && i.line == t.line ? (n.display.externalMeasured = null, t.measure = i.measure, i.built) : oy(n, t) } function uw(n, t) { var r = t.text.className, i = fl(n, t); t.text == t.node && (t.node = i.pre); t.text.parentNode.replaceChild(i.pre, t.text); t.text = i.pre; i.bgClass != t.bgClass || i.textClass != t.textClass ? (t.bgClass = i.bgClass, t.textClass = i.textClass, hs(t)) : r && (t.text.className = r) } function hs(n) { rw(n); n.line.wrapClass ? df(n).className = n.line.wrapClass : n.node != n.text && (n.node.className = ""); var t = n.textClass ? n.textClass + " " + (n.line.textClass || "") : n.line.textClass; n.text.className = t || "" } function el(n, t, r, u) { var f, c, s, o, e, h; if (t.gutter && (t.node.removeChild(t.gutter), t.gutter = null), f = t.line.gutterMarkers, (n.options.lineNumbers || f) && (c = df(t), s = t.gutter = c.insertBefore(i("div", null, "CodeMirror-gutter-wrapper", "position: absolute; left: " + (n.options.fixedGutter ? u.fixedPos : -u.gutterTotalWidth) + "px"), t.text), !n.options.lineNumbers || f && f["CodeMirror-linenumbers"] || (t.lineNumber = s.appendChild(i("div", is(n.options, r), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + u.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + n.display.lineNumInnerWidth + "px"))), f)) for (o = 0; o < n.options.gutters.length; ++o) e = n.options.gutters[o], h = f.hasOwnProperty(e) && f[e], h && s.appendChild(i("div", [h], "CodeMirror-gutter-elt", "left: " + u.gutterLeft[e] + "px; width: " + u.gutterWidth[e] + "px")) } function fw(n, t) { var i, r; for (n.alignable && (n.alignable = null), i = n.node.firstChild; i; i = r) r = i.nextSibling, i.className == "CodeMirror-linewidget" && n.node.removeChild(i); ol(n, t) } function ew(n, t, i, r) { var u = fl(n, t); return t.text = t.node = u.pre, u.bgClass && (t.bgClass = u.bgClass), u.textClass && (t.textClass = u.textClass), hs(t), el(n, t, i, r), ol(t, r), t.node } function ol(n, t) { if (sl(n.line, n, t, !0), n.rest) for (var i = 0; i < n.rest.length; i++) sl(n.rest[i], n, t, !1) } function sl(n, t, r, u) { var s, o, h, f, e; if (n.widgets) for (s = df(t), o = 0, h = n.widgets; o < h.length; ++o) f = h[o], e = i("div", [f.node], "CodeMirror-linewidget"), f.handleMouseEvents || (e.ignoreEvents = !0), ow(f, e, t, r), u && f.above ? s.insertBefore(e, t.gutter || t.text) : s.appendChild(e), b(f, "redraw") } function ow(n, t, i, r) { if (n.noHScroll) { (i.alignable || (i.alignable = [])).push(t); var u = r.wrapperWidth; t.style.left = r.fixedPos + "px"; n.coverGutter || (u -= r.gutterTotalWidth, t.style.paddingLeft = r.gutterTotalWidth + "px"); t.style.width = u + "px" } n.coverGutter && (t.style.zIndex = 5, t.style.position = "relative", n.noHScroll || (t.style.marginLeft = -r.gutterTotalWidth + "px")) } function cs(t) { return n(t.line, t.ch) } function ls(n, t) { return o(n, t) < 0 ? t : n } function as(n, t) { return o(n, t) < 0 ? n : t } function dt(n, t) { this.ranges = n; this.primIndex = t } function c(n, t) { this.anchor = n; this.head = t } function ct(n, t) { var h = n[t], i, u, r; for (n.sort(function (n, t) { return o(n.from(), t.from()) }), t = k(n, h), i = 1; i < n.length; i++) if (u = n[i], r = n[i - 1], o(r.to(), u.from()) >= 0) { var f = as(r.from(), u.from()), e = ls(r.to(), u.to()), s = r.empty() ? u.from() == u.head : r.from() == r.head; i <= t && --t; n.splice(--i, 2, new c(s ? e : f, s ? f : e)) } return new dt(n, t) } function wi(n, t) { return new dt([new c(n, t || n)], 0) } function hl(n, t) { return Math.max(n.first, Math.min(t, n.first + n.size - 1)) } function u(t, i) { if (i.line < t.first) return n(t.first, 0); var u = t.first + t.size - 1; return i.line > u ? n(u, r(t, u).text.length) : sw(i, r(t, i.line).text.length) } function sw(t, i) { var r = t.ch; return r == null || r > i ? n(t.line, i) : r < 0 ? n(t.line, 0) : t } function uu(n, t) { return t >= n.first && t < n.first + n.size } function hw(n, t) { for (var r = [], i = 0; i < t.length; i++) r[i] = u(n, t[i]); return r } function fu(n, t, i, r) { var u, f; return n.cm && n.cm.display.shift || n.extend ? (u = t.anchor, r && (f = o(i, u) < 0, f != o(r, u) < 0 ? (u = i, i = r) : f != o(i, r) < 0 && (i = r)), new c(u, i)) : new c(r || i, i) } function gf(n, t, i, r) { g(n, new dt([fu(n, n.sel.primary(), t, i)], 0), r) } function cl(n, t, i) { for (var f, u = [], r = 0; r < n.sel.ranges.length; r++) u[r] = fu(n, n.sel.ranges[r], t[r], null); f = ct(u, n.sel.primIndex); g(n, f, i) } function vs(n, t, i, r) { var u = n.sel.ranges.slice(0); u[t] = i; g(n, ct(u, n.sel.primIndex), r) } function ll(n, t, i, r) { g(n, wi(t, i), r) } function cw(n, t) { var i = { ranges: t.ranges, update: function (t) { this.ranges = []; for (var i = 0; i < t.length; i++) this.ranges[i] = new c(u(n, t[i].anchor), u(n, t[i].head)) } }; return y(n, "beforeSelectionChange", n, i), n.cm && y(n.cm, "beforeSelectionChange", n.cm, i), i.ranges != t.ranges ? ct(i.ranges, i.ranges.length - 1) : t } function al(n, t, i) { var r = n.history.done, u = l(r); u && u.ranges ? (r[r.length - 1] = t, ne(n, t, i)) : g(n, t, i) } function g(n, t, i) { ne(n, t, i); id(n, n.sel, n.cm ? n.cm.curOp.id : NaN, i) } function ne(n, t, i) { (st(n, "beforeSelectionChange") || n.cm && st(n.cm, "beforeSelectionChange")) && (t = cw(n, t)); var r = i && i.bias || (o(t.primary().head, n.sel.primary().head) < 0 ? -1 : 1); vl(n, pl(n, t, r, !0)); i && i.scroll === !1 || !n.cm || lr(n.cm) } function vl(n, t) { t.equals(n.sel) || (n.sel = t, n.cm && (n.cm.curOp.updateInput = n.cm.curOp.selectionChanged = !0, np(n.cm)), b(n, "cursorActivity", n)) } function yl(n) { vl(n, pl(n, n.sel, null, !1), ai) } function pl(n, t, i, r) { for (var u, f = 0; f < t.ranges.length; f++) { var e = t.ranges[f], o = te(n, e.anchor, i, r), s = te(n, e.head, i, r); (u || o != e.anchor || s != e.head) && (u || (u = t.ranges.slice(0, f)), u[f] = new c(o, s)) } return u ? ct(u, t.primIndex) : t } function te(t, i, f, e) { var w = !1, h = i, p = f || 1, a, v, c, l, s; t.cantEdit = !1; n: for (; ;) { if (a = r(t, h.line), a.markedSpans) for (v = 0; v < a.markedSpans.length; ++v) if (c = a.markedSpans[v], l = c.marker, (c.from == null || (l.inclusiveLeft ? c.from <= h.ch : c.from < h.ch)) && (c.to == null || (l.inclusiveRight ? c.to >= h.ch : c.to > h.ch))) { if (e && (y(l, "beforeCursorEnter"), l.explicitlyCleared)) if (a.markedSpans) { --v; continue } else break; if (!l.atomic) continue; if (s = l.find(p < 0 ? -1 : 1), o(s, h) == 0 && (s.ch += p, s.ch < 0 ? s = s.line > t.first ? u(t, n(s.line - 1)) : null : s.ch > a.text.length && (s = s.line < t.first + t.size - 1 ? n(s.line + 1, 0) : null), !s)) { if (w) return e ? (t.cantEdit = !0, n(t.first, 0)) : te(t, i, f, !0); w = !0; s = i; p = -p } h = s; continue n } return h } } function wl(n) { for (var r, e, i = n.display, u = n.doc, t = {}, c = t.cursors = document.createDocumentFragment(), l = t.selection = document.createDocumentFragment(), f = 0; f < u.sel.ranges.length; f++) r = u.sel.ranges[f], e = r.empty(), (e || n.options.showCursorWhenSelecting) && lw(n, r, c), e || aw(n, r, l); if (n.options.moveInputWithCursor) { var o = gt(n, u.sel.primary().head, "div"), s = i.wrapper.getBoundingClientRect(), h = i.lineDiv.getBoundingClientRect(); t.teTop = Math.max(0, Math.min(i.wrapper.clientHeight - 10, o.top + h.top - s.top)); t.teLeft = Math.max(0, Math.min(i.wrapper.clientWidth - 10, o.left + h.left - s.left)) } return t } function bl(n, t) { ht(n.display.cursorDiv, t.cursors); ht(n.display.selectionDiv, t.selection); t.teTop != null && (n.display.inputDiv.style.top = t.teTop + "px", n.display.inputDiv.style.left = t.teLeft + "px") } function eu(n) { bl(n, wl(n)) } function lw(n, t, r) { var u = gt(n, t.head, "div", null, null, !n.options.singleCursorHeightPerLine), e = r.appendChild(i("div", " ", "CodeMirror-cursor")), f; e.style.left = u.left + "px"; e.style.top = u.top + "px"; e.style.height = Math.max(0, u.bottom - u.top) * n.options.cursorHeight + "px"; u.other && (f = r.appendChild(i("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor")), f.style.display = "", f.style.left = u.other.left + "px", f.style.top = u.other.top + "px", f.style.height = (u.other.bottom - u.other.top) * .85 + "px") } function aw(t, u, f) { function o(n, t, r, u) { t < 0 && (t = 0); t = Math.round(t); u = Math.round(u); p.appendChild(i("div", null, "CodeMirror-selected", "position: absolute; left: " + n + "px; top: " + t + "px; width: " + (r == null ? b - n : r) + "px; height: " + (u - t) + "px")) } function v(i, u, f) { function v(r, u) { return bs(t, n(i, r), "div", c, u) } var c = r(a, i), l = c.text.length, e, s; return yd(pt(c), u || 0, f == null ? l : f, function (n, t, i) { var r = v(n, "left"), c, a, y, p; n == t ? (c = r, a = y = r.left) : (c = v(t - 1, "right"), i == "rtl" && (p = r, r = c, c = p), a = r.left, y = c.right); u == null && n == 0 && (a = h); c.top - r.top > 3 && (o(a, r.top, null, r.bottom), a = h, r.bottom < c.top && o(a, r.bottom, null, c.top)); f == null && t == l && (y = b); (!e || r.top < e.top || r.top == e.top && r.left < e.left) && (e = r); (!s || c.bottom > s.bottom || c.bottom == s.bottom && c.right > s.right) && (s = c); a < h + 1 && (a = h); o(a, c.top, y - a, c.bottom) }), { start: e, end: s } } var d = t.display, a = t.doc, p = document.createDocumentFragment(), w = kl(t.display), h = w.left, b = d.lineSpace.offsetWidth - w.right, c = u.from(), l = u.to(); if (c.line == l.line) v(c.line, c.ch, l.ch); else { var k = r(a, c.line), g = r(a, l.line), y = vt(k) == vt(g), e = v(c.line, c.ch, y ? k.text.length + 1 : null).end, s = v(l.line, y ? 0 : null, l.ch).start; y && (e.top < s.top - 2 ? (o(e.right, e.top, null, e.bottom), o(h, s.top, s.left, s.bottom)) : o(e.right, e.top, s.left - e.right, e.bottom)); e.bottom < s.top && o(h, e.bottom, null, s.top) } f.appendChild(p) } function ie(n) { var t, i; n.state.focused && (t = n.display, clearInterval(t.blinker), i = !0, t.cursorDiv.style.visibility = "", n.options.cursorBlinkRate > 0 ? t.blinker = setInterval(function () { t.cursorDiv.style.visibility = (i = !i) ? "" : "hidden" }, n.options.cursorBlinkRate) : n.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = "hidden")) } function ou(n, t) { n.doc.mode.startState && n.doc.frontier < n.display.viewTo && n.state.highlight.set(t, kt(vw, n)) } function vw(n) { var t = n.doc; if (t.frontier < t.first && (t.frontier = t.first), !(t.frontier >= n.display.viewTo)) { var u = +new Date + n.options.workTime, i = pr(t.mode, su(n, t.frontier)), r = []; t.iter(t.frontier, Math.min(t.first + t.size, n.display.viewTo + 500), function (f) { var s, l, o, e, c, h; if (t.frontier >= n.display.viewFrom) { for (s = f.styles, l = iy(n, f, i, !0), f.styles = l.styles, o = f.styleClasses, e = l.classes, e ? f.styleClasses = e : o && (f.styleClasses = null), c = !s || s.length != f.styles.length || o != e && (!o || !e || o.bgClass != e.bgClass || o.textClass != e.textClass), h = 0; !c && h < s.length; ++h) c = s[h] != f.styles[h]; c && r.push(t.frontier); f.stateAfter = pr(t.mode, i) } else vh(n, f.text, i), f.stateAfter = t.frontier % 5 == 0 ? pr(t.mode, i) : null; return ++t.frontier, +new Date > u ? (ou(n, n.options.workDelay), !0) : void 0 }); r.length && ni(n, function () { for (var t = 0; t < r.length; t++) ti(n, r[t], "text") }) } } function yw(n, t, i) { for (var o, s, h, e, f = n.doc, c = i ? -1 : t - (n.doc.mode.innerMode ? 1e3 : 100), u = t; u > c; --u) { if (u <= f.first) return f.first; if (o = r(f, u - 1), o.stateAfter && (!i || u <= f.frontier)) return u; s = ft(o.text, null, n.options.tabSize); (e == null || h > s) && (e = u - 1, h = s) } return e } function su(n, t, i) { var f = n.doc, o = n.display, u, e; return f.mode.startState ? (u = yw(n, t, i), e = u > f.first && r(f, u - 1).stateAfter, e = e ? pr(f.mode, e) : ov(f.mode), f.iter(u, t, function (i) { vh(n, i.text, e); var r = u == t - 1 || u % 5 == 0 || u >= o.viewFrom && u < o.viewTo; i.stateAfter = r ? pr(f.mode, e) : null; ++u }), i && (f.frontier = u), e) : !0 } function re(n) { return n.lineSpace.offsetTop } function ys(n) { return n.mover.offsetHeight - n.lineSpace.offsetHeight } function kl(n) { if (n.cachedPaddingH) return n.cachedPaddingH; var r = ht(n.measure, i("pre", "x")), u = window.getComputedStyle ? window.getComputedStyle(r) : r.currentStyle, t = { left: parseInt(u.paddingLeft), right: parseInt(u.paddingRight) }; return isNaN(t.left) || isNaN(t.right) || (n.cachedPaddingH = t), t } function pw(n, t, i) { var f = n.options.lineWrapping, h = f && n.display.scroller.clientWidth, e, u, r, o, s; if (!t.measure.heights || f && t.measure.width != h) { if (e = t.measure.heights = [], f) for (t.measure.width = h, u = t.text.firstChild.getClientRects(), r = 0; r < u.length - 1; r++) o = u[r], s = u[r + 1], Math.abs(o.bottom - s.bottom) > 2 && e.push((o.bottom + s.top) / 2 - i.top); e.push(i.bottom - i.top) } } function ww(n, t, i) { var r; if (n.line == t) return { map: n.measure.map, cache: n.measure.cache }; for (r = 0; r < n.rest.length; r++) if (n.rest[r] == t) return { map: n.measure.maps[r], cache: n.measure.caches[r] }; for (r = 0; r < n.rest.length; r++) if (a(n.rest[r]) > i) return { map: n.measure.maps[r], cache: n.measure.caches[r], before: !0 } } function bw(n, t) { var r, i, u; return t = vt(t), r = a(t), i = n.display.externalMeasured = new sa(n.doc, t, r), i.lineN = r, u = i.built = oy(n, i), i.text = u.pre, ht(n.display.lineMeasure, u.pre), i } function dl(n, t, i, r) { return na(n, ps(n, t), i, r) } function gl(n, t) { if (t >= n.display.viewFrom && t < n.display.viewTo) return n.display.view[lu(n, t)]; var i = n.display.externalMeasured; if (i && t >= i.lineN && t < i.lineN + i.size) return i } function ps(n, t) { var u = a(t), i = gl(n, u), r; return i && !i.text ? i = null : i && i.changes && ul(n, i, u, ss(n)), i || (i = bw(n, t)), r = ww(i, t, u), { line: t, view: i, rect: null, map: r.map, cache: r.cache, before: r.before, hasHeights: !1 } } function na(n, t, i, r, u) { t.before && (i = -1); var e = i + (r || ""), f; return t.cache.hasOwnProperty(e) ? f = t.cache[e] : (t.rect || (t.rect = t.view.text.getBoundingClientRect()), t.hasHeights || (pw(n, t.view, t.rect), t.hasHeights = !0), f = kw(n, t, i, r), f.bogus || (t.cache[e] = f)), { left: f.left, right: f.right, top: u ? f.rtop : f.top, bottom: u ? f.rbottom : f.bottom } } function kw(n, t, i, r) { for (var a, y, f, p, w, o = t.map, c, e, l, v, u = 0; u < o.length; u += 3) if (a = o[u], y = o[u + 1], i < a ? (e = 0, l = 1, v = "left") : i < y ? (e = i - a, l = e + 1) : (u == o.length - 3 || i == y && o[u + 3] > i) && (l = y - a, e = l - 1, i >= y && (v = "right")), e != null) { if (c = o[u + 2], a == y && r == (c.insertLeft ? "left" : "right") && (v = r), r == "left" && e == 0) while (u && o[u - 2] == o[u - 3] && o[u - 1].insertLeft) c = o[(u -= 3) + 2], v = "left"; if (r == "right" && e == y - a) while (u < o.length - 3 && o[u + 3] == o[u + 4] && !o[u + 5].insertLeft) c = o[(u += 3) + 2], v = "right"; break } if (c.nodeType == 3) for (; ;) { while (e && yf(t.line.text.charAt(a + e)))--e; while (a + l < y && yf(t.line.text.charAt(a + l)))++l; if (s && h < 9 && e == 0 && l == y - a ? f = c.parentNode.getBoundingClientRect() : s && n.options.lineWrapping ? (p = gr(c, e, l).getClientRects(), f = p.length ? p[r == "right" ? p.length - 1 : 0] : ue) : f = gr(c, e, l).getBoundingClientRect() || ue, f.left || f.right || e == 0) break; l = e; e = e - 1; v = "right" } else e > 0 && (v = r = "right"), f = n.options.lineWrapping && (p = c.getClientRects()).length > 1 ? p[r == "right" ? p.length - 1 : 0] : c.getBoundingClientRect(); s && h < 9 && !e && (!f || !f.left && !f.right) && (w = c.parentNode.getClientRects()[0], f = w ? { left: w.left, right: w.left + cu(n.display), top: w.top, bottom: w.bottom } : ue); s && h < 11 && (f = dw(n.display.measure, f)); var d = f.top - t.rect.top, g = f.bottom - t.rect.top, nt = (d + g) / 2, b = t.view.measure.heights; for (u = 0; u < b.length - 1; u++) if (nt < b[u]) break; var tt = u ? b[u - 1] : 0, it = b[u], k = { left: (v == "right" ? f.right : f.left) - t.rect.left, right: (v == "left" ? f.left : f.right) - t.rect.left, top: tt, bottom: it }; return f.left || f.right || (k.bogus = !0), n.options.singleCursorHeightPerLine || (k.rtop = d, k.rbottom = g), k } function dw(n, t) { if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !vd(n)) return t; var i = screen.logicalXDPI / screen.deviceXDPI, r = screen.logicalYDPI / screen.deviceYDPI; return { left: t.left * i, right: t.right * i, top: t.top * r, bottom: t.bottom * r } } function ta(n) { if (n.measure && (n.measure.cache = {}, n.measure.heights = null, n.rest)) for (var t = 0; t < n.rest.length; t++) n.measure.caches[t] = {} } function ia(n) { n.display.externalMeasure = null; ur(n.display.lineMeasure); for (var t = 0; t < n.display.view.length; t++) ta(n.display.view[t]) } function hu(n) { ia(n); n.display.cachedCharWidth = n.display.cachedTextHeight = n.display.cachedPaddingH = null; n.options.lineWrapping || (n.display.maxLineChanged = !0); n.display.lineNumChars = null } function ra() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft } function ua() { return window.pageYOffset || (document.documentElement || document.body).scrollTop } function ws(n, t, i, r) { var f, e, u, o, s; if (t.widgets) for (f = 0; f < t.widgets.length; ++f) t.widgets[f].above && (e = rf(t.widgets[f]), i.top += e, i.bottom += e); return r == "line" ? i : (r || (r = "local"), u = ri(t), r == "local" ? u += re(n.display) : u -= n.display.viewOffset, (r == "page" || r == "window") && (o = n.display.lineSpace.getBoundingClientRect(), u += o.top + (r == "window" ? 0 : ua()), s = o.left + (r == "window" ? 0 : ra()), i.left += s, i.right += s), i.top += u, i.bottom += u, i) } function fa(n, t, i) { var r, u, f, e; return i == "div" ? t : (r = t.left, u = t.top, i == "page" ? (r -= ra(), u -= ua()) : i != "local" && i || (f = n.display.sizer.getBoundingClientRect(), r += f.left, u += f.top), e = n.display.lineSpace.getBoundingClientRect(), { left: r - e.left, top: u - e.top }) } function bs(n, t, i, u, f) { return u || (u = r(n.doc, t.line)), ws(n, u, dl(n, u, t.ch, f), i) } function gt(n, t, i, u, f, e) { function h(t, r) { var o = na(n, f, t, r ? "right" : "left", e); return r ? o.left = o.right : o.right = o.left, ws(n, u, o, i) } function l(n, t) { var i = o[t], r = i.level % 2; return (n == ec(i) && t && i.level < o[t - 1].level ? (i = o[--t], n = oc(i) - (i.level % 2 ? 0 : 1), r = !0) : n == oc(i) && t < o.length - 1 && i.level < o[t + 1].level && (i = o[++t], n = ec(i) - i.level % 2, r = !1), r && n == i.to && n > i.from) ? h(n - 1) : h(n, r) } var o, s, a, c; return (u = u || r(n.doc, t.line), f || (f = ps(n, u)), o = pt(u), s = t.ch, !o) ? h(s) : (a = sc(o, s), c = l(s, a), wf != null && (c.other = l(s, wf)), c) } function ea(n, t) { var i = 0, t = u(n.doc, t), f, e; return n.options.lineWrapping || (i = cu(n.display) * t.ch), f = r(n.doc, t.line), e = ri(f) + re(n.display), { left: i, right: i, top: e, bottom: e + f.height } } function fe(t, i, r, u) { var f = n(t, i); return f.xRel = u, r && (f.outside = !0), f } function ks(n, t, i) { var u = n.doc, f, s, e; if (i += n.display.viewOffset, i < 0) return fe(u.first, 0, !0, -1); if (f = rr(u, i), s = u.first + u.size - 1, f > s) return fe(u.first + u.size - 1, r(u, s).text.length, !0, 1); for (t < 0 && (t = 0), e = r(u, f) ; ;) { var o = gw(n, e, f, t, i), h = nf(e), c = h && h.find(0, !0); if (h && (o.ch > c.from.ch || o.ch == c.from.ch && o.xRel > 0)) f = a(e = c.to.line); else return o } } function gw(t, i, r, u, f) { function p(u) { var f = gt(t, n(r, u), "line", i, rt); return (h = !0, g > f.bottom) ? f.left - nt : g < f.top ? f.left + nt : (h = !1, f.left) } var g = f - ri(i), h = !1, nt = 2 * t.display.wrapper.clientWidth, rt = ps(t, i), tt = pt(i), w = i.text.length, e = co(i), o = lo(i), v = p(e), it = h, l = p(o), b = h, c, k, a, s, d, y; if (u > l) return fe(r, o, b, 1); for (; ;) { if (tt ? o == e || o == cc(i, e, 1) : o - e <= 1) { for (c = u < v || u - v <= l - u ? e : o, k = u - (c == e ? v : l) ; yf(i.text.charAt(c)) ;)++c; return fe(r, c, c == e ? it : b, k < -1 ? -1 : k > 1 ? 1 : 0) } if (a = Math.ceil(w / 2), s = e + a, tt) for (s = e, d = 0; d < a; ++d) s = cc(i, s, 1); y = p(s); y > u ? (o = s, l = y, (b = h) && (l += 1e3), w = a) : (e = s, v = y, it = h, w -= a) } } function ki(n) { var r, t; if (n.cachedTextHeight != null) return n.cachedTextHeight; if (bi == null) { for (bi = i("pre"), r = 0; r < 49; ++r) bi.appendChild(document.createTextNode("x")), bi.appendChild(i("br")); bi.appendChild(document.createTextNode("x")) } return ht(n.measure, bi), t = bi.offsetHeight / 50, t > 3 && (n.cachedTextHeight = t), ur(n.measure), t || 1 } function cu(n) { var r, f, u, t; return n.cachedCharWidth != null ? n.cachedCharWidth : (r = i("span", "xxxxxxxxxx"), f = i("pre", [r]), ht(n.measure, f), u = r.getBoundingClientRect(), t = (u.right - u.left) / 10, t > 2 && (n.cachedCharWidth = t), t || 10) } function er(n) { n.curOp = { cm: n, viewChanged: !1, startHeight: n.doc.height, forceUpdate: !1, updateInput: null, typing: !1, changeObjs: null, cursorActivityHandlers: null, cursorActivityCalled: 0, selectionChanged: !1, updateMaxLine: !1, scrollLeft: null, scrollTop: null, scrollToPos: null, id: ++oa }; di ? di.ops.push(n.curOp) : n.curOp.ownsGroup = di = { ops: [n.curOp], delayedCallbacks: [] } } function nb(n) { var u = n.delayedCallbacks, i = 0, r, t; do { for (; i < u.length; i++) u[i](); for (r = 0; r < n.ops.length; r++) if (t = n.ops[r], t.cursorActivityHandlers) while (t.cursorActivityCalled < t.cursorActivityHandlers.length) t.cursorActivityHandlers[t.cursorActivityCalled++](t.cm) } while (i < u.length) } function or(n) { var r = n.curOp, t = r.ownsGroup, i; if (t) try { nb(t) } finally { for (di = null, i = 0; i < t.ops.length; i++) t.ops[i].cm.curOp = null; tb(t) } } function tb(n) { for (var i = n.ops, t = 0; t < i.length; t++) ib(i[t]); for (t = 0; t < i.length; t++) rb(i[t]); for (t = 0; t < i.length; t++) ub(i[t]); for (t = 0; t < i.length; t++) fb(i[t]); for (t = 0; t < i.length; t++) eb(i[t]) } function ib(n) { var t = n.cm, i = t.display; n.updateMaxLine && ko(t); n.mustUpdate = n.viewChanged || n.forceUpdate || n.scrollTop != null || n.scrollToPos && (n.scrollToPos.from.line < i.viewFrom || n.scrollToPos.to.line >= i.viewTo) || i.maxLineChanged && t.options.lineWrapping; n.update = n.mustUpdate && new tl(t, n.mustUpdate && { top: n.scrollTop, ensure: n.scrollToPos }, n.forceUpdate) } function rb(n) { n.updatedDisplay = n.mustUpdate && us(n.cm, n.update) } function ub(n) { var t = n.cm, i = t.display; n.updatedDisplay && os(t); n.barMeasure = kf(t); i.maxLineChanged && !t.options.lineWrapping && (n.adjustWidthTo = dl(t, i.maxLine, i.maxLine.text.length).left + 3, n.maxScrollLeft = Math.max(0, i.sizer.offsetLeft + n.adjustWidthTo + bt - i.scroller.clientWidth)); (n.updatedDisplay || n.selectionChanged) && (n.newSelectionNodes = wl(t)) } function fb(n) { var t = n.cm; n.adjustWidthTo != null && (t.display.sizer.style.minWidth = n.adjustWidthTo + "px", n.maxScrollLeft < t.doc.scrollLeft && hr(t, Math.min(t.display.scroller.scrollLeft, n.maxScrollLeft), !0), t.display.maxLineChanged = !1); n.newSelectionNodes && bl(t, n.newSelectionNodes); n.updatedDisplay && es(t, n.barMeasure); (n.updatedDisplay || n.startHeight != t.doc.height) && pi(t, n.barMeasure); n.selectionChanged && ie(t); t.state.focused && n.updateInput && lt(t, n.typing) } function eb(n) { var t = n.cm, i = t.display, f = t.doc, s, h, c, e, o, r; if (n.adjustWidthTo != null && Math.abs(n.barMeasure.scrollWidth - t.display.scroller.scrollWidth) > 1 && pi(t), n.updatedDisplay && il(t, n.update), i.wheelStartX != null && (n.scrollTop != null || n.scrollLeft != null || n.scrollToPos) && (i.wheelStartX = i.wheelStartY = null), n.scrollTop != null && i.scroller.scrollTop != n.scrollTop && (s = Math.max(0, Math.min(i.scroller.scrollHeight - i.scroller.clientHeight, n.scrollTop)), i.scroller.scrollTop = i.scrollbarV.scrollTop = f.scrollTop = s), n.scrollLeft != null && i.scroller.scrollLeft != n.scrollLeft && (h = Math.max(0, Math.min(i.scroller.scrollWidth - i.scroller.clientWidth, n.scrollLeft)), i.scroller.scrollLeft = i.scrollbarH.scrollLeft = f.scrollLeft = h, ts(t)), n.scrollToPos && (c = nk(t, u(f, n.scrollToPos.from), u(f, n.scrollToPos.to), n.scrollToPos.margin), n.scrollToPos.isCursor && t.state.focused && gb(t, c)), e = n.maybeHiddenMarkers, o = n.maybeUnhiddenMarkers, e) for (r = 0; r < e.length; ++r) e[r].lines.length || y(e[r], "hide"); if (o) for (r = 0; r < o.length; ++r) o[r].lines.length && y(o[r], "unhide"); i.wrapper.offsetHeight && (f.scrollTop = t.display.scroller.scrollTop); n.updatedDisplay && p && (t.options.lineWrapping && tw(t, n.barMeasure), n.barMeasure.scrollWidth > n.barMeasure.clientWidth && n.barMeasure.scrollWidth < n.barMeasure.clientWidth + 1 && !gc(t) && pi(t)); n.changeObjs && y(t, "changes", t, n.changeObjs) } function ni(n, t) { if (n.curOp) return t(); er(n); try { return t() } finally { or(n) } } function v(n, t) { return function () { if (n.curOp) return t.apply(n, arguments); er(n); try { return t.apply(n, arguments) } finally { or(n) } } } function w(n) { return function () { if (this.curOp) return n.apply(this, arguments); er(this); try { return n.apply(this, arguments) } finally { or(this) } } } function nt(n) { return function () { var t = this.cm; if (!t || t.curOp) return n.apply(this, arguments); er(t); try { return n.apply(this, arguments) } finally { or(t) } } } function sa(n, t, i) { this.line = t; this.rest = ak(t); this.size = this.rest ? a(l(this.rest)) - i + 1 : 1; this.node = this.text = null; this.hidden = tr(n, t) } function ee(n, t, i) { for (var f, e = [], o, u = t; u < i; u = o) f = new sa(n.doc, r(n.doc, u), u), o = u + f.size, e.push(f); return e } function rt(n, t, i, r) { var u, f, o, s, e; t == null && (t = n.doc.first); i == null && (i = n.doc.first + n.doc.size); r || (r = 0); u = n.display; r && i < u.viewTo && (u.updateLineNumbers == null || u.updateLineNumbers > t) && (u.updateLineNumbers = t); n.curOp.viewChanged = !0; t >= u.viewTo ? ei && ch(n.doc, t) < u.viewTo && oi(n) : i <= u.viewFrom ? ei && kv(n.doc, i + r) > u.viewFrom ? oi(n) : (u.viewFrom += r, u.viewTo += r) : t <= u.viewFrom && i >= u.viewTo ? oi(n) : t <= u.viewFrom ? (f = oe(n, i, i + r, 1), f ? (u.view = u.view.slice(f.index), u.viewFrom = f.lineN, u.viewTo += r) : oi(n)) : i >= u.viewTo ? (f = oe(n, t, t, -1), f ? (u.view = u.view.slice(0, f.index), u.viewTo = f.lineN) : oi(n)) : (o = oe(n, t, t, -1), s = oe(n, i, i + r, 1), o && s ? (u.view = u.view.slice(0, o.index).concat(ee(n, o.lineN, s.lineN)).concat(u.view.slice(s.index)), u.viewTo += r) : oi(n)); e = u.externalMeasured; e && (i < e.lineN ? e.lineN += r : t < e.lineN + e.size && (u.externalMeasured = null)) } function ti(n, t, i) { var r, u, f, e; (n.curOp.viewChanged = !0, r = n.display, u = n.display.externalMeasured, u && t >= u.lineN && t < u.lineN + u.size && (r.externalMeasured = null), t < r.viewFrom || t >= r.viewTo) || (f = r.view[lu(n, t)], f.node != null) && (e = f.changes || (f.changes = []), k(e, i) == -1 && e.push(i)) } function oi(n) { n.display.viewFrom = n.display.viewTo = n.doc.first; n.display.view = []; n.display.viewOffset = 0 } function lu(n, t) { var r, i; if (t >= n.display.viewTo || (t -= n.display.viewFrom, t < 0)) return null; for (r = n.display.view, i = 0; i < r.length; i++) if (t -= r[i].size, t < 0) return i } function oe(n, t, i, r) { var u = lu(n, t), o, f = n.display.view, s, e; if (!ei || i == n.doc.first + n.doc.size) return { index: u, lineN: i }; for (s = 0, e = n.display.viewFrom; s < u; s++) e += f[s].size; if (e != t) { if (r > 0) { if (u == f.length - 1) return null; o = e + f[u].size - t; u++ } else o = e - t; t += o; i += o } while (ch(n.doc, i) != i) { if (u == (r < 0 ? 0 : f.length - 1)) return null; i += r * f[u - (r < 0 ? 1 : 0)].size; u += r } return { index: u, lineN: i } } function ob(n, t, i) { var r = n.display, u = r.view; u.length == 0 || t >= r.viewTo || i <= r.viewFrom ? (r.view = ee(n, t, i), r.viewFrom = t) : (r.viewFrom > t ? r.view = ee(n, t, r.viewFrom).concat(r.view) : r.viewFrom < t && (r.view = r.view.slice(lu(n, t))), r.viewFrom = t, r.viewTo < i ? r.view = r.view.concat(ee(n, r.viewTo, i)) : r.viewTo > i && (r.view = r.view.slice(0, lu(n, i)))); r.viewTo = i } function ha(n) { for (var t, r = n.display.view, u = 0, i = 0; i < r.length; i++) t = r[i], t.hidden || t.node && !t.changes || ++u; return u } function se(n) { n.display.pollingFast || n.display.poll.set(n.options.pollInterval, function () { ds(n); n.state.focused && se(n) }) } function au(n) { function i() { var r = ds(n); r || t ? (n.display.pollingFast = !1, se(n)) : (t = !0, n.display.poll.set(60, i)) } var t = !1; n.display.pollingFast = !0; n.display.poll.set(20, i) } function ds(t) { var a = t.display.input, f = t.display.prevInput, u = t.doc, i, tt, e, rt, c, ut, g, v, nt, it; if (!t.state.focused || ad(a) && !f || he(t) || t.options.disableInput || (t.state.pasteIncoming && t.state.fakedLastChar && (a.value = a.value.substring(0, a.value.length - 1), t.state.fakedLastChar = !1), i = a.value, i == f && !t.somethingSelected())) return !1; if (s && h >= 9 && t.display.inputHasSelection === i || ot && /[\uf700-\uf7ff]/.test(i)) return lt(t), !1; for (tt = !t.curOp, tt && er(t), t.display.shift = !1, i.charCodeAt(0) != 8203 || u.sel != t.display.selForContextMenu || f || (f = "​"), e = 0, rt = Math.min(f.length, i.length) ; e < rt && f.charCodeAt(e) == i.charCodeAt(e) ;)++e; var w = i.slice(e), k = fr(w), y = null; for (t.state.pasteIncoming && u.sel.ranges.length > 1 && (si && si.join("\n") == w ? y = u.sel.ranges.length % si.length == 0 && af(si, fr) : k.length == u.sel.ranges.length && (y = af(k, function (n) { return [n] }))), c = u.sel.ranges.length - 1; c >= 0; c--) { var o = u.sel.ranges[c], d = o.from(), p = o.to(); if (e < f.length ? d = n(d.line, d.ch - (f.length - e)) : t.state.overwrite && o.empty() && !t.state.pasteIncoming && (p = n(p.line, Math.min(r(u, p.line).text.length, p.ch + l(k).length))), ut = t.curOp.updateInput, g = { from: d, to: p, text: y ? y[c % y.length] : k, origin: t.state.pasteIncoming ? "paste" : t.state.cutIncoming ? "cut" : "+input" }, cr(t.doc, g), b(t, "inputRead", t, g), w && !t.state.pasteIncoming && t.options.electricChars && t.options.smartIndent && o.head.ch < 100 && (!c || u.sel.ranges[c - 1].head.line != o.head.line)) if (v = t.getModeAt(o.head), v.electricChars) { for (nt = 0; nt < v.electricChars.length; nt++) if (w.indexOf(v.electricChars.charAt(nt)) > -1) { wu(t, o.head.line, "smart"); break } } else v.electricInput && (it = ii(g), v.electricInput.test(r(u, it.line).text.slice(0, it.ch)) && wu(t, o.head.line, "smart")) } return lr(t), t.curOp.updateInput = ut, t.curOp.typing = !0, i.length > 1e3 || i.indexOf("\n") > -1 ? a.value = t.display.prevInput = "" : t.display.prevInput = i, tt && or(t), t.state.pasteIncoming = t.state.cutIncoming = !1, !0 } function lt(n, t) { var i, f, e = n.doc, r, u; n.somethingSelected() ? (n.display.prevInput = "", r = e.sel.primary(), i = cp && (r.to().line - r.from().line > 100 || (f = n.getSelection()).length > 1e3), u = i ? "-" : f || n.getSelection(), n.display.input.value = u, n.state.focused && dr(n.display.input), s && h >= 9 && (n.display.inputHasSelection = u)) : t || (n.display.prevInput = n.display.input.value = "", s && h >= 9 && (n.display.inputHasSelection = null)); n.display.inaccurateSelection = i } function it(n) { n.options.readOnly == "nocursor" || vo && vi() == n.display.input || n.display.input.focus() } function gs(n) { n.state.focused || (it(n), th(n)) } function he(n) { return n.options.readOnly || n.doc.cantEdit } function sb(t) { function r() { t.state.focused && setTimeout(kt(it, t), 0) } function u(n) { wt(t, n) || eo(n) } function f(r) { var u, o, f, s, e; if (t.somethingSelected()) si = t.getSelections(), i.inaccurateSelection && (i.prevInput = "", i.inaccurateSelection = !1, i.input.value = si.join("\n"), dr(i.input)); else { for (u = [], o = [], f = 0; f < t.doc.sel.ranges.length; f++) s = t.doc.sel.ranges[f].head.line, e = { anchor: n(s, 0), head: n(s + 1, 0) }, o.push(e), u.push(t.getRange(e.anchor, e.head)); r.type == "cut" ? t.setSelections(o, null, ai) : (i.prevInput = "", i.input.value = u.join("\n"), dr(i.input)); si = u } r.type == "cut" && (t.state.cutIncoming = !0) } var i = t.display; e(i.scroller, "mousedown", v(t, ca)); s && h < 11 ? e(i.scroller, "dblclick", v(t, function (n) { var i, r; wt(t, n) || (i = sr(t, n), !i || aa(t, n) || gi(t.display, n)) || (d(n), r = fh(t, i), gf(t.doc, r.anchor, r.head)) })) : e(i.scroller, "dblclick", function (n) { wt(t, n) || d(n) }); e(i.lineSpace, "selectstart", function (n) { gi(i, n) || d(n) }); yo || e(i.scroller, "contextmenu", function (n) { ga(t, n) }); e(i.scroller, "scroll", function () { i.scroller.clientHeight && (vu(t, i.scroller.scrollTop), hr(t, i.scroller.scrollLeft, !0), y(t, "scroll", t)) }); e(i.scrollbarV, "scroll", function () { i.scroller.clientHeight && vu(t, i.scrollbarV.scrollTop) }); e(i.scrollbarH, "scroll", function () { i.scroller.clientHeight && hr(t, i.scrollbarH.scrollLeft) }); e(i.scroller, "mousewheel", function (n) { va(t, n) }); e(i.scroller, "DOMMouseScroll", function (n) { va(t, n) }); e(i.scrollbarH, "mousedown", r); e(i.scrollbarV, "mousedown", r); e(i.wrapper, "scroll", function () { i.wrapper.scrollTop = i.wrapper.scrollLeft = 0 }); e(i.input, "keyup", function (n) { ka.call(t, n) }); e(i.input, "input", function () { s && h >= 9 && t.display.inputHasSelection && (t.display.inputHasSelection = null); au(t) }); e(i.input, "keydown", v(t, ba)); e(i.input, "keypress", v(t, da)); e(i.input, "focus", kt(th, t)); e(i.input, "blur", kt(ye, t)); t.options.dragDrop && (e(i.scroller, "dragstart", function (n) { yb(t, n) }), e(i.scroller, "dragenter", u), e(i.scroller, "dragover", u), e(i.scroller, "drop", v(t, vb))); e(i.scroller, "paste", function (n) { gi(i, n) || (t.state.pasteIncoming = !0, it(t), au(t)) }); e(i.input, "paste", function () { if (p && !t.state.fakedLastChar && !(new Date - t.state.lastMiddleDown < 200)) { var n = i.input.selectionStart, r = i.input.selectionEnd; i.input.value += "$"; i.input.selectionEnd = r; i.input.selectionStart = n; t.state.fakedLastChar = !0 } t.state.pasteIncoming = !0; au(t) }); e(i.input, "cut", f); e(i.input, "copy", f); ao && e(i.sizer, "mouseup", function () { vi() == i.input && i.input.blur(); it(t) }) } function hb(n) { var t = n.display; t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null; n.setSize() } function gi(n, t) { for (var i = sf(t) ; i != n.wrapper; i = i.parentNode) if (!i || i.ignoreEvents || i.parentNode == n.sizer && i != n.mover) return !0 } function sr(t, i, u, f) { var o = t.display, s, c, a, l, e, h, v; if (!u && (s = sf(i), s == o.scrollbarH || s == o.scrollbarV || s == o.scrollbarFiller || s == o.gutterFiller)) return null; l = o.lineSpace.getBoundingClientRect(); try { c = i.clientX - l.left; a = i.clientY - l.top } catch (i) { return null } return e = ks(t, c, a), f && e.xRel == 1 && (h = r(t.doc, e.line).text).length == e.ch && (v = ft(h, h.length, t.options.tabSize) - h.length, e = n(e.line, Math.max(0, Math.round((c - kl(t.display).left) / cu(t.display)) - v))), e } function ca(n) { var t, i, r; if (!wt(this, n)) { if (t = this, i = t.display, i.shift = n.shiftKey, gi(i, n)) { p || (i.scroller.draggable = !1, setTimeout(function () { i.scroller.draggable = !0 }, 100)); return } if (!aa(t, n)) { r = sr(t, n); window.focus(); switch (gy(n)) { case 1: r ? cb(t, n, r) : sf(n) == i.scroller && d(n); break; case 2: p && (t.state.lastMiddleDown = +new Date); r && gf(t.doc, r); setTimeout(kt(it, t), 20); d(n); break; case 3: yo && ga(t, n) } } } } function cb(n, t, i) { var r, u, f, e; setTimeout(kt(gs, n), 0); r = +new Date; le && le.time > r - 400 && o(le.pos, i) == 0 ? u = "triple" : ce && ce.time > r - 400 && o(ce.pos, i) == 0 ? (u = "double", le = { time: r, pos: i }) : (u = "single", ce = { time: r, pos: i }); f = n.doc.sel; e = ot ? t.metaKey : t.ctrlKey; n.options.dragDrop && hp && !he(n) && u == "single" && f.contains(i) > -1 && f.somethingSelected() ? lb(n, t, i, e) : ab(n, t, i, u, e) } function lb(n, t, i, r) { var u = n.display, f = v(n, function (e) { p && (u.scroller.draggable = !1); n.state.draggingText = !1; ui(document, "mouseup", f); ui(u.scroller, "drop", f); Math.abs(t.clientX - e.clientX) + Math.abs(t.clientY - e.clientY) < 10 && (d(e), r || gf(n.doc, i), it(n), s && h == 9 && setTimeout(function () { document.body.focus(); it(n) }, 20)) }); p && (u.scroller.draggable = !0); n.state.draggingText = f; u.scroller.dragDrop && u.scroller.dragDrop(); e(document, "mouseup", f); e(u.scroller, "drop", f) } function ab(t, i, f, s, h) { function ht(i) { var h, st, k, p, v, e; if (o(nt, i) != 0) if (nt = i, s == "rect") { var e = [], b = t.options.tabSize, rt = ft(r(l, f.line).text, f.ch, b), ut = ft(r(l, i.line).text, i.ch, b), et = Math.min(rt, ut), ot = Math.max(rt, ut); for (h = Math.min(f.line, i.line), st = Math.min(t.lastLine(), Math.max(f.line, i.line)) ; h <= st; h++) k = r(l, h).text, p = ip(k, et, b), et == ot ? e.push(new c(n(h, p), n(h, p))) : k.length > p && e.push(new c(n(h, p), n(h, ip(k, ot, b)))); e.length || e.push(new c(f, f)); g(l, ct(w.ranges.slice(0, y).concat(e), y), { origin: "*mouse", scroll: !1 }); t.scrollIntoView(i) } else { var tt = a, d = tt.anchor, it = i; s != "single" && (v = s == "double" ? fh(t, i) : new c(n(i.line, 0), u(l, n(i.line + 1, 0))), o(v.anchor, d) > 0 ? (it = v.head, d = as(tt.from(), v.anchor)) : (it = v.anchor, d = ls(tt.to(), v.head))); e = w.ranges.slice(0); e[y] = new c(u(l, d), it); g(l, ct(e, y), kh) } } function ut(n) { var f = ++p, i = sr(t, n, !0, s == "rect"), r, u; i && (o(i, nt) != 0 ? (gs(t), ht(i), r = ns(tt, l), (i.line >= r.to || i.line < r.from) && setTimeout(v(t, function () { p == f && ut(n) }), 150)) : (u = n.clientY < rt.top ? -20 : n.clientY > rt.bottom ? 20 : 0, u && setTimeout(v(t, function () { p == f && (tt.scroller.scrollTop += u, ut(n)) }), 50))) } function st(n) { p = Infinity; d(n); it(t); ui(document, "mousemove", et); ui(document, "mouseup", ot); l.history.lastSelOrigin = null } var tt = t.display, l = t.doc, a, y, w, b, k, nt, rt, p, et, ot; d(i); w = l.sel; h && !i.shiftKey ? (y = l.sel.contains(f), a = y > -1 ? l.sel.ranges[y] : new c(f, f)) : a = l.sel.primary(); i.altKey ? (s = "rect", h || (a = new c(f, f)), f = sr(t, i, !0, !0), y = -1) : s == "double" ? (b = fh(t, f), a = t.display.shift || l.extend ? fu(l, a, b.anchor, b.head) : b) : s == "triple" ? (k = new c(n(f.line, 0), u(l, n(f.line + 1, 0))), a = t.display.shift || l.extend ? fu(l, a, k.anchor, k.head) : k) : a = fu(l, a, f); h ? y > -1 ? vs(l, y, a, kh) : (y = l.sel.ranges.length, g(l, ct(l.sel.ranges.concat([a]), y), { scroll: !1, origin: "*mouse" })) : (y = 0, g(l, new dt([a], 0), kh), w = l.sel); nt = f; rt = tt.wrapper.getBoundingClientRect(); p = 0; et = v(t, function (n) { gy(n) ? ut(n) : st(n) }); ot = v(t, st); e(document, "mousemove", et); e(document, "mouseup", ot) } function la(n, t, i, r, u) { var s, e, o, h, f, c, l, a; try { s = t.clientX; e = t.clientY } catch (t) { return !1 } if (s >= Math.floor(n.display.gutters.getBoundingClientRect().right)) return !1; if (r && d(t), o = n.display, h = o.lineDiv.getBoundingClientRect(), e > h.bottom || !st(n, i)) return bh(t); for (e -= h.top - o.viewOffset, f = 0; f < n.options.gutters.length; ++f) if (c = o.gutters.childNodes[f], c && c.getBoundingClientRect().right >= s) return l = rr(n.doc, e), a = n.options.gutters[f], u(n, i, n, l, a, t), bh(t) } function aa(n, t) { return la(n, t, "gutterClick", !0, b) } function vb(n) { var t = this, i, f, e, o, r; if (!wt(t, n) && !gi(t.display, n) && (d(n), s && (nh = +new Date), i = sr(t, n, !0), f = n.dataTransfer.files, i && !he(t))) if (f && f.length && window.FileReader && window.File) { var h = f.length, e = Array(h), c = 0, l = function (n, r) { var f = new FileReader; f.onload = v(t, function () { if (e[r] = f.result, ++c == h) { i = u(t.doc, i); var n = { from: i, to: i, text: fr(e.join("\n")), origin: "paste" }; cr(t.doc, n); al(t.doc, wi(i, ii(n))) } }); f.readAsText(n) }; for (r = 0; r < h; ++r) l(f[r], r) } else { if (t.state.draggingText && t.doc.sel.contains(i) > -1) { t.state.draggingText(n); setTimeout(kt(it, t), 20); return } try { if (e = n.dataTransfer.getData("Text"), e) { if (!t.state.draggingText || (ot ? n.metaKey : n.ctrlKey) || (o = t.listSelections()), ne(t.doc, wi(i, i)), o) for (r = 0; r < o.length; ++r) we(t.doc, "", o[r].anchor, o[r].head, "drag"); t.replaceSelection(e, "around", "paste"); it(t) } } catch (n) { } } } function yb(n, t) { if (s && (!n.state.draggingText || +new Date - nh < 100)) { eo(t); return } if (!wt(n, t) && !gi(n.display, t) && (t.dataTransfer.setData("Text", n.getSelection()), t.dataTransfer.setDragImage && !vc)) { var r = i("img", null, null, "position: fixed; left: 0; top: 0;"); r.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="; et && (r.width = r.height = 1, n.display.wrapper.appendChild(r), r._top = r.offsetTop); t.dataTransfer.setDragImage(r, 0, 0); et && r.parentNode.removeChild(r) } } function vu(n, t) { Math.abs(n.doc.scrollTop - t) < 2 || (n.doc.scrollTop = t, nu || fs(n, { top: t }), n.display.scroller.scrollTop != t && (n.display.scroller.scrollTop = t), n.display.scrollbarV.scrollTop != t && (n.display.scrollbarV.scrollTop = t), nu && fs(n), ou(n, 100)) } function hr(n, t, i) { (i ? t == n.doc.scrollLeft : Math.abs(n.doc.scrollLeft - t) < 2) || (t = Math.min(t, n.display.scroller.scrollWidth - n.display.scroller.clientWidth), n.doc.scrollLeft = t, ts(n), n.display.scroller.scrollLeft != t && (n.display.scroller.scrollLeft = t), n.display.scrollbarH.scrollLeft != t && (n.display.scrollbarH.scrollLeft = t)) } function va(n, t) { var f = t.wheelDeltaX, u = t.wheelDeltaY, i, r, e, h, o; if (f == null && t.detail && t.axis == t.HORIZONTAL_AXIS && (f = t.detail), u == null && t.detail && t.axis == t.VERTICAL_AXIS ? u = t.detail : u == null && (u = t.wheelDelta), i = n.display, r = i.scroller, f && r.scrollWidth > r.clientWidth || u && r.scrollHeight > r.clientHeight) { if (u && ot && p) n: for (e = t.target, h = i.view; e != r; e = e.parentNode) for (o = 0; o < h.length; o++) if (h[o].node == e) { n.display.currentWheelTarget = e; break n } if (f && !nu && !et && ut != null) { u && vu(n, Math.max(0, Math.min(r.scrollTop + u * ut, r.scrollHeight - r.clientHeight))); hr(n, Math.max(0, Math.min(r.scrollLeft + f * ut, r.scrollWidth - r.clientWidth))); d(t); i.wheelStartX = null; return } if (u && ut != null) { var c = u * ut, s = n.doc.scrollTop, l = s + i.wrapper.clientHeight; c < 0 ? s = Math.max(0, s + c - 50) : l = Math.min(n.doc.height, l + c + 50); fs(n, { top: s, bottom: l }) } yu < 20 && (i.wheelStartX == null ? (i.wheelStartX = r.scrollLeft, i.wheelStartY = r.scrollTop, i.wheelDX = f, i.wheelDY = u, setTimeout(function () { if (i.wheelStartX != null) { var n = r.scrollLeft - i.wheelStartX, t = r.scrollTop - i.wheelStartY, u = t && i.wheelDY && t / i.wheelDY || n && i.wheelDX && n / i.wheelDX; (i.wheelStartX = i.wheelStartY = null, u) && (ut = (ut * yu + u) / (yu + 1), ++yu) } }, 200)) : (i.wheelDX += f, i.wheelDY += u)) } } function ae(n, t, i) { if (typeof t == "string" && (t = bu[t], !t)) return !1; n.display.pollingFast && ds(n) && (n.display.pollingFast = !1); var u = n.display.shift, r = !1; try { he(n) && (n.state.suppressEdits = !0); i && (n.display.shift = !1); r = t(n) != tp } finally { n.display.shift = u; n.state.suppressEdits = !1 } return r } function ya(n) { var t = n.state.keyMaps.slice(0); return n.options.extraKeys && t.push(n.options.extraKeys), t.push(n.options.keyMap), t } function wa(n, t) { var e = sh(n.options.keyMap), r = e.auto, i, u, f; return (clearTimeout(pa), r && !ik(t) && (pa = setTimeout(function () { sh(n.options.keyMap) == e && (n.options.keyMap = r.call ? r.call(null, n) : r, bc(n)) }, 50)), i = rk(t, !0), u = !1, !i) ? !1 : (f = ya(n), u = t.shiftKey ? no("Shift-" + i, f, function (t) { return ae(n, t, !0) }) || no(i, f, function (t) { if (typeof t == "string" ? /^go[A-Z]/.test(t) : t.motion) return ae(n, t) }) : no(i, f, function (t) { return ae(n, t) }), u && (d(t), ie(n), b(n, "keyHandled", n, i, t)), u) } function pb(n, t, i) { var r = no("'" + i + "'", ya(n), function (t) { return ae(n, t, !0) }); return r && (d(t), ie(n), b(n, "keyHandled", n, "'" + i + "'", t)), r } function ba(n) { var t = this, i, r; (gs(t), wt(t, n)) || (s && h < 11 && n.keyCode == 27 && (n.returnValue = !1), i = n.keyCode, t.display.shift = i == 16 || n.shiftKey, r = wa(t, n), et && (ve = r ? i : null, r || i != 88 || cp || !(ot ? n.metaKey : n.ctrlKey) || t.replaceSelection("", null, "cut")), i != 18 || /\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className) || wb(t)) } function wb(n) { function t(n) { n.keyCode != 18 && n.altKey || (so(i, "CodeMirror-crosshair"), ui(document, "keyup", t), ui(document, "mouseover", t)) } var i = n.display.lineDiv; ho(i, "CodeMirror-crosshair"); e(document, "keyup", t); e(document, "mouseover", t) } function ka(n) { n.keyCode == 16 && (this.doc.sel.shift = !1); wt(this, n) } function da(n) { var t = this, i, r, u; if (!wt(t, n) && (!n.ctrlKey || n.altKey) && (!ot || !n.metaKey)) { if (i = n.keyCode, r = n.charCode, et && i == ve) { ve = null; d(n); return } (et && (!n.which || n.which < 10) || ao) && wa(t, n) || (u = String.fromCharCode(r == null ? i : r), pb(t, n, u)) || (s && h >= 9 && (t.display.inputHasSelection = null), au(t)) } } function th(n) { n.options.readOnly != "nocursor" && (n.state.focused || (y(n, "focus", n), n.state.focused = !0, ho(n.display.wrapper, "CodeMirror-focused"), n.curOp || n.display.selForContextMenu == n.doc.sel || (lt(n), p && setTimeout(kt(lt, n, !0), 0))), se(n), ie(n)) } function ye(n) { n.state.focused && (y(n, "blur", n), n.state.focused = !1, so(n.display.wrapper, "CodeMirror-focused")); clearInterval(n.display.blinker); setTimeout(function () { n.state.focused || (n.display.shift = !1) }, 150) } function ga(n, t) { function a() { if (i.input.selectionStart != null) { var t = n.somethingSelected(), r = i.input.value = "​" + (t ? i.input.value : ""); i.prevInput = t ? "" : "​"; i.input.selectionStart = 1; i.input.selectionEnd = r.length; i.selForContextMenu = n.doc.sel } } function y() { if (i.inputDiv.style.position = "relative", i.input.style.cssText = c, s && h < 9 && (i.scrollbarV.scrollTop = i.scroller.scrollTop = f), se(n), i.input.selectionStart != null) { (!s || s && h < 9) && a(); var r = 0, t = function () { i.selForContextMenu == n.doc.sel && i.input.selectionStart == 0 ? v(n, bu.selectAll)(n) : r++ < 10 ? i.detectingSelectAll = setTimeout(t, 500) : lt(n) }; i.detectingSelectAll = setTimeout(t, 200) } } var i, r, f, o, c, l, u; wt(n, t, "contextmenu") || (i = n.display, gi(i, t) || bb(n, t)) || (r = sr(n, t), f = i.scroller.scrollTop, r && !et) && (o = n.options.resetSelectionOnContextMenu, o && n.doc.sel.contains(r) == -1 && v(n, g)(n.doc, wi(r), ai), c = i.input.style.cssText, i.inputDiv.style.position = "absolute", i.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (t.clientY - 5) + "px; left: " + (t.clientX - 5) + "px; z-index: 1000; background: " + (s ? "rgba(255, 255, 255, .05)" : "transparent") + "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);", p && (l = window.scrollY), it(n), p && window.scrollTo(null, l), lt(n), n.somethingSelected() || (i.input.value = i.prevInput = " "), i.selForContextMenu = n.doc.sel, clearTimeout(i.detectingSelectAll), s && h >= 9 && a(), yo ? (eo(t), u = function () { ui(window, "mouseup", u); setTimeout(y, 20) }, e(window, "mouseup", u)) : setTimeout(y, 50)) } function bb(n, t) { return st(n, "gutterContextMenu") ? la(n, t, "gutterContextMenu", !1, y) : !1 } function nv(t, i) { if (o(t, i.from) < 0) return t; if (o(t, i.to) <= 0) return ii(i); var u = t.line + i.text.length - (i.to.line - i.from.line) - 1, r = t.ch; return t.line == i.to.line && (r += ii(i).ch - i.to.ch), n(u, r) } function ih(n, t) { for (var r, u = [], i = 0; i < n.sel.ranges.length; i++) r = n.sel.ranges[i], u.push(new c(nv(r.anchor, t), nv(r.head, t))); return ct(u, n.sel.primIndex) } function tv(t, i, r) { return t.line == i.line ? n(r.line, t.ch - i.ch + r.ch) : n(r.line + (t.line - i.line), t.ch) } function kb(t, i, r) { for (var v, y, s = [], f = n(t.first, 0), h = f, u = 0; u < i.length; u++) { var l = i[u], e = tv(l.from, f, h), a = tv(ii(l), f, h); f = l.to; h = a; r == "around" ? (v = t.sel.ranges[u], y = o(v.head, v.anchor) < 0, s[u] = new c(y ? a : e, y ? e : a)) : s[u] = new c(e, e) } return new dt(s, t.sel.primIndex) } function iv(n, t, i) { var r = { canceled: !1, from: t.from, to: t.to, text: t.text, origin: t.origin, cancel: function () { this.canceled = !0 } }; return (i && (r.update = function (t, i, r, f) { t && (this.from = u(n, t)); i && (this.to = u(n, i)); r && (this.text = r); f !== undefined && (this.origin = f) }), y(n, "beforeChange", n, r), n.cm && y(n.cm, "beforeChange", n.cm, r), r.canceled) ? null : { from: r.from, to: r.to, text: r.text, origin: r.origin } } function cr(n, t, i) { var u, r; if (n.cm) { if (!n.cm.curOp) return v(n.cm, cr)(n, t, i); if (n.cm.state.suppressEdits) return } if (!st(n, "beforeChange") && (!n.cm || !st(n.cm, "beforeChange")) || (t = iv(n, t, !0), t)) if (u = pc && !i && lk(n, t.from, t.to), u) for (r = u.length - 1; r >= 0; --r) rv(n, { from: u[r].from, to: u[r].to, text: r ? [""] : t.text }); else rv(n, t) } function rv(n, t) { var i, r; (t.text.length != 1 || t.text[0] != "" || o(t.from, t.to) != 0) && (i = ih(n, t), yy(n, t, i, n.cm ? n.cm.curOp.id : NaN), pu(n, t, i, hh(n, t)), r = [], ir(n, function (n, i) { i || k(r, n.history) != -1 || (ky(n.history, t), r.push(n.history)); pu(n, t, null, hh(n, t)) })) } function pe(n, t, i) { var h, v, f, u, y, c; if (!n.cm || !n.cm.state.suppressEdits) { var e = n.history, r, a = n.sel, o = t == "undo" ? e.done : e.undone, s = t == "undo" ? e.undone : e.done; for (f = 0; f < o.length; f++) if (r = o[f], i ? r.ranges && !r.equals(n.sel) : !r.ranges) break; if (f != o.length) { for (e.lastOrigin = e.lastSelOrigin = null; ;) if (r = o.pop(), r.ranges) { if (fo(r, s), i && !r.equals(n.sel)) { g(n, r, { clearRedo: !1 }); return } a = r } else break; for (h = [], fo(a, s), s.push({ changes: h, generation: e.generation }), e.generation = r.generation || ++e.maxGeneration, v = st(n, "beforeChange") || n.cm && st(n.cm, "beforeChange"), f = r.changes.length - 1; f >= 0; --f) { if (u = r.changes[f], u.origin = t, v && !iv(n, u, !1)) { o.length = 0; return } h.push(wh(n, u)); y = f ? ih(n, u) : l(o); pu(n, u, y, lv(n, u)); !f && n.cm && n.cm.scrollIntoView({ from: u.from, to: ii(u) }); c = []; ir(n, function (n, t) { t || k(c, n.history) != -1 || (ky(n.history, u), c.push(n.history)); pu(n, u, null, lv(n, u)) }) } } } } function uv(t, i) { if (i != 0 && (t.first += i, t.sel = new dt(af(t.sel.ranges, function (t) { return new c(n(t.anchor.line + i, t.anchor.ch), n(t.head.line + i, t.head.ch)) }), t.sel.primIndex), t.cm)) { rt(t.cm, t.first, t.first - i, i); for (var u = t.cm.display, r = u.viewFrom; r < u.viewTo; r++) ti(t.cm, r, "gutter") } } function pu(t, i, u, f) { var o, e; if (t.cm && !t.cm.curOp) return v(t.cm, pu)(t, i, u, f); if (i.to.line < t.first) { uv(t, i.text.length - 1 - (i.to.line - i.from.line)); return } i.from.line > t.lastLine() || (i.from.line < t.first && (o = i.text.length - 1 - (t.first - i.from.line), uv(t, o), i = { from: n(t.first, 0), to: n(i.to.line + o, i.to.ch), text: [l(i.text)], origin: i.origin }), e = t.lastLine(), i.to.line > e && (i = { from: i.from, to: n(e, r(t, e).text.length), text: [i.text[0]], origin: i.origin }), i.removed = of(t, i.from, i.to), u || (u = ih(t, i)), t.cm ? db(t.cm, i, f) : yh(t, i, f), ne(t, u, ai)) } function db(n, t, i) { var f = n.doc, e = n.display, u = t.from, o = t.to, s = !1, h = u.line, y, c, l, v; n.options.lineWrapping || (h = a(vt(r(f, u.line))), f.iter(h, o.line + 1, function (n) { if (n == e.maxLine) return s = !0, !0 })); f.sel.contains(t.from, t.to) > -1 && np(n); yh(f, t, i, wc(n)); n.options.lineWrapping || (f.iter(h, u.line + t.text.length, function (n) { var t = bf(n); t > e.maxLineLength && (e.maxLine = n, e.maxLineLength = t, e.maxLineChanged = !0, s = !1) }), s && (n.curOp.updateMaxLine = !0)); f.frontier = Math.min(f.frontier, u.line); ou(n, 400); y = t.text.length - (o.line - u.line) - 1; u.line != o.line || t.text.length != 1 || hy(n.doc, t) ? rt(n, u.line, o.line + 1, y) : ti(n, u.line, "text"); c = st(n, "changes"); l = st(n, "change"); (l || c) && (v = { from: u, to: o, text: t.text, removed: t.removed, origin: t.origin }, l && b(n, "change", n, v), c && (n.curOp.changeObjs || (n.curOp.changeObjs = [])).push(v)); n.display.selForContextMenu = null } function we(n, t, i, r, u) { if (r || (r = i), o(r, i) < 0) { var f = r; r = i; i = f } typeof t == "string" && (t = fr(t)); cr(n, { from: i, to: r, text: t, origin: u }) } function gb(n, t) { var f = n.display, e = f.sizer.getBoundingClientRect(), r = null, u; t.top + e.top < 0 ? r = !0 : t.bottom + e.top > (window.innerHeight || document.documentElement.clientHeight) && (r = !1); r == null || kp || (u = i("div", "​", null, "position: absolute; top: " + (t.top - f.viewOffset - re(n.display)) + "px; height: " + (t.bottom - t.top + bt) + "px; left: " + t.left + "px; width: 2px;"), n.display.lineSpace.appendChild(u), u.scrollIntoView(r), n.display.lineSpace.removeChild(u)) } function nk(n, t, i, r) { for (r == null && (r = 0) ; ;) { var o = !1, u = gt(n, t), f = !i || i == t ? u : gt(n, i), e = be(n, Math.min(u.left, f.left), Math.min(u.top, f.top) - r, Math.max(u.left, f.left), Math.max(u.bottom, f.bottom) + r), s = n.doc.scrollTop, h = n.doc.scrollLeft; if (e.scrollTop != null && (vu(n, e.scrollTop), Math.abs(n.doc.scrollTop - s) > 1 && (o = !0)), e.scrollLeft != null && (hr(n, e.scrollLeft), Math.abs(n.doc.scrollLeft - h) > 1 && (o = !0)), !o) return u } } function tk(n, t, i, r, u) { var f = be(n, t, i, r, u); f.scrollTop != null && vu(n, f.scrollTop); f.scrollLeft != null && hr(n, f.scrollLeft) } function be(n, t, i, r, u) { var f = n.display, a = ki(n.display), h; i < 0 && (i = 0); var s = n.curOp && n.curOp.scrollTop != null ? n.curOp.scrollTop : f.scroller.scrollTop, o = f.scroller.clientHeight - bt, e = {}; u - i > o && (u = i + o); var v = n.doc.height + ys(f), p = i < a, w = u > v - a; i < s ? e.scrollTop = p ? 0 : i : u > s + o && (h = Math.min(i, (w ? v : u) - o), h != s && (e.scrollTop = h)); var y = n.curOp && n.curOp.scrollLeft != null ? n.curOp.scrollLeft : f.scroller.scrollLeft, c = f.scroller.clientWidth - bt - f.gutters.offsetWidth, l = r - t > c; return l && (r = i + o), t < 10 ? e.scrollLeft = 0 : t < y ? e.scrollLeft = Math.max(0, t - (l ? 0 : 10)) : r > c + y - 3 && (e.scrollLeft = r + (l ? 0 : 10) - c), e } function rh(n, t, i) { (t != null || i != null) && ke(n); t != null && (n.curOp.scrollLeft = (n.curOp.scrollLeft == null ? n.doc.scrollLeft : n.curOp.scrollLeft) + t); i != null && (n.curOp.scrollTop = (n.curOp.scrollTop == null ? n.doc.scrollTop : n.curOp.scrollTop) + i) } function lr(t) { ke(t); var i = t.getCursor(), r = i, u = i; t.options.lineWrapping || (r = i.ch ? n(i.line, i.ch - 1) : i, u = n(i.line, i.ch + 1)); t.curOp.scrollToPos = { from: r, to: u, margin: t.options.cursorScrollMargin, isCursor: !0 } } function ke(n) { var t = n.curOp.scrollToPos; if (t) { n.curOp.scrollToPos = null; var i = ea(n, t.from), r = ea(n, t.to), u = be(n, Math.min(i.left, r.left), Math.min(i.top, r.top) - t.margin, Math.max(i.right, r.right), Math.max(i.bottom, r.bottom) + t.margin); n.scrollTo(u.scrollLeft, u.scrollTop) } } function wu(t, i, u, f) { var o = t.doc, b, a, e, v, h, w, l; u == null && (u = "add"); u == "smart" && (o.mode.indent ? b = su(t, i) : u = "prev"); var y = t.options.tabSize, s = r(o, i), p = ft(s.text, null, y); if (s.stateAfter && (s.stateAfter = null), a = s.text.match(/^\s*/)[0], f || /\S/.test(s.text)) { if (u == "smart" && (e = o.mode.indent(b, s.text.slice(a.length), s.text), e == tp || e > 150)) { if (!f) return; u = "prev" } } else e = 0, u = "not"; if (u == "prev" ? e = i > o.first ? ft(r(o, i - 1).text, null, y) : 0 : u == "add" ? e = p + t.options.indentUnit : u == "subtract" ? e = p - t.options.indentUnit : typeof u == "number" && (e = p + u), e = Math.max(0, e), v = "", l = 0, t.options.indentWithTabs) for (h = Math.floor(e / y) ; h; --h) l += y, v += "\t"; if (l < e && (v += rp(e - l)), v != a) we(o, v, n(i, 0), n(i, a.length), "+input"); else for (h = 0; h < o.sel.ranges.length; h++) if (w = o.sel.ranges[h], w.head.line == i && w.head.ch < a.length) { l = n(i, a.length); vs(o, h, new c(l, l)); break } s.stateAfter = null } function de(n, t, i, u) { var f = t, e = t; return (typeof t == "number" ? e = r(n, hl(n, t)) : f = a(t), f == null) ? null : (u(e, f) && n.cm && ti(n.cm, f, i), e) } function ar(n, t) { for (var r, f, e = n.doc.sel.ranges, i = [], u = 0; u < e.length; u++) { for (r = t(e[u]) ; i.length && o(r.from, l(i).to) <= 0;) if (f = i.pop(), o(f.from, r.from) < 0) { r.from = f.from; break } i.push(r) } ni(n, function () { for (var t = i.length - 1; t >= 0; t--) we(n.doc, "", i[t].from, i[t].to, "+delete"); lr(n) }) } function uh(t, i, u, f, e) { function d() { var n = a + u; return n < t.first || n >= t.first + t.size ? y = !1 : (a = n, h = r(t, n)) } function c(n) { var t = (e ? cc : vp)(h, o, u, !0); if (t == null) if (!n && d()) o = e ? (u < 0 ? lo : co)(h) : u < 0 ? h.text.length : 0; else return y = !1; else o = t; return !0 } var a = i.line, o = i.ch, k = u, h = r(t, a), y = !0, l, v, s, b; if (f == "char") c(); else if (f == "column") c(!0); else if (f == "word" || f == "group") { var p = null, w = f == "group", g = t.cm && t.cm.getHelper(i, "wordChars"); for (l = !0; ; l = !1) { if (u < 0 && !c(!l)) break; if (v = h.text.charAt(o) || "\n", s = oo(v, g) ? "w" : w && v == "\n" ? "n" : !w || /\s/.test(v) ? null : "p", !w || l || s || (s = "s"), p && p != s) { u < 0 && (u = 1, c()); break } if (s && (p = s), u > 0 && !c(!l)) break } } return b = te(t, n(a, o), k, !0), y || (b.hitSide = !0), b } function fv(n, t, i, r) { var o = n.doc, s = t.left, u, e, f; for (r == "page" ? (e = Math.min(n.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight), u = t.top + i * (e - (i < 0 ? 1.5 : .5) * ki(n.display))) : r == "line" && (u = i > 0 ? t.bottom + 3 : t.top - 3) ; ;) { if (f = ks(n, s, u), !f.outside) break; if (i < 0 ? u <= 0 : u >= o.height) { f.hitSide = !0; break } u += i * 5 } return f } function fh(t, i) { var l = t.doc, f = r(l, i.line).text, u = i.ch, e = i.ch, o, s, h; if (f) { for (o = t.getHelper(i, "wordChars"), (i.xRel < 0 || e == f.length) && u ? --u : ++e, s = f.charAt(u), h = oo(s, o) ? function (n) { return oo(n, o) } : /\s/.test(s) ? function (n) { return /\s/.test(n) } : function (n) { return !/\s/.test(n) && !oo(n) }; u > 0 && h(f.charAt(u - 1)) ;)--u; while (e < f.length && h(f.charAt(e)))++e } return new c(n(i.line, u), n(i.line, e)) } function f(n, i, r, u) { t.defaults[n] = i; r && (nr[n] = u ? function (n, t, i) { i != eh && r(n, t, i) } : r) } function sh(n) { return typeof n == "string" ? at[n] : n } function wr(n, t, r, u, f) { var s, a, c, h, y, l; if (u && u.shared) return uk(n, t, r, u, f); if (n.cm && !n.cm.curOp) return v(n.cm, wr)(n, t, r, u, f); if (s = new ci(n, f), a = o(t, r), u && vf(u, s, !1), a > 0 || a == 0 && s.clearWhenEmpty !== !1) return s; if (s.replacedWith && (s.collapsed = !0, s.widgetNode = i("span", [s.replacedWith], "CodeMirror-widget"), u.handleMouseEvents || (s.widgetNode.ignoreEvents = !0), u.insertLeft && (s.widgetNode.insertLeft = !0)), s.collapsed) { if (bv(n, t.line, t, r, s) || t.line != r.line && bv(n, r.line, t, r, s)) throw new Error("Inserting collapsed marker partially overlapping an existing one"); ei = !0 } if (s.addToHistory && yy(n, { from: t, to: r, origin: "markText" }, n.sel, NaN), c = t.line, h = n.cm, n.iter(c, r.line + 1, function (n) { h && s.collapsed && !h.options.lineWrapping && vt(n) == h.display.maxLine && (y = !0); s.collapsed && c != t.line && yt(n, 0); sk(n, new to(s, c == t.line ? t.ch : null, c == r.line ? r.ch : null)); ++c }), s.collapsed && n.iter(t.line, r.line + 1, function (t) { tr(n, t) && yt(t, 0) }), s.clearOnEnter && e(s, "beforeCursorEnter", function () { s.clear() }), s.readOnly && (pc = !0, (n.history.done.length || n.history.undone.length) && n.clearHistory()), s.collapsed && (s.id = ++sv, s.atomic = !0), h) { if (y && (h.curOp.updateMaxLine = !0), s.collapsed) rt(h, t.line, r.line + 1); else if (s.className || s.title || s.startStyle || s.endStyle) for (l = t.line; l <= r.line; l++) ti(h, l, "text"); s.atomic && yl(h.doc); b(h, "markerAdded", h, s) } return s } function uk(n, t, i, r, f) { r = vf(r); r.shared = !1; var e = [wr(n, t, i, r, f)], o = e[0], s = r.widgetNode; return ir(n, function (n) { s && (r.widgetNode = s.cloneNode(!0)); e.push(wr(n, u(n, t), u(n, i), r, f)); for (var h = 0; h < n.linked.length; ++h) if (n.linked[h].isParent) return; o = l(e) }), new du(e, o) } function hv(t) { return t.findMarks(n(t.first, 0), t.clipPos(n(t.lastLine())), function (n) { return n.parent }) } function fk(n, t) { for (var u, r = 0; r < t.length; r++) { var i = t[r], f = i.find(), e = n.clipPos(f.from), s = n.clipPos(f.to); o(e, s) && (u = wr(n, e, s, i.primary, i.primary.type), i.markers.push(u), u.parent = i) } } function ek(n) { for (var t, u, i, f, r = 0; r < n.length; r++) for (t = n[r], u = [t.primary.doc], ir(t.primary.doc, function (n) { u.push(n) }), i = 0; i < t.markers.length; i++) f = t.markers[i], k(u, f.doc) == -1 && (f.parent = null, t.markers.splice(i--, 1)) } function to(n, t, i) { this.marker = n; this.from = t; this.to = i } function gu(n, t) { var i, r; if (n) for (i = 0; i < n.length; ++i) if (r = n[i], r.marker == t) return r } function ok(n, t) { for (var r, i = 0; i < n.length; ++i) n[i] != t && (r || (r = [])).push(n[i]); return r } function sk(n, t) { n.markedSpans = n.markedSpans ? n.markedSpans.concat([t]) : [t]; t.marker.attachLine(n) } function hk(n, t, i) { var u, e, o; if (n) for (u = 0; u < n.length; ++u) { var r = n[u], f = r.marker, s = r.from == null || (f.inclusiveLeft ? r.from <= t : r.from < t); !s && (r.from != t || f.type != "bookmark" || i && r.marker.insertLeft) || (o = r.to == null || (f.inclusiveRight ? r.to >= t : r.to > t), (e || (e = [])).push(new to(f, r.from, o ? null : r.to))) } return e } function ck(n, t, i) { var u, e, o; if (n) for (u = 0; u < n.length; ++u) { var r = n[u], f = r.marker, s = r.to == null || (f.inclusiveRight ? r.to >= t : r.to > t); (s || r.from == t && f.type == "bookmark" && (!i || r.marker.insertLeft)) && (o = r.from == null || (f.inclusiveLeft ? r.from <= t : r.from < t), (e || (e = [])).push(new to(f, o ? null : r.from - t, r.to == null ? null : r.to - t))) } return e } function hh(n, t) { var w = uu(n, t.from.line) && r(n, t.from.line).markedSpans, b = uu(n, t.to.line) && r(n, t.to.line).markedSpans, f, s, a, y, p, u; if (!w && !b) return null; var v = t.from.ch, d = t.to.ch, k = o(t.from, t.to) == 0, i = hk(w, v, k), e = ck(b, d, k), h = t.text.length == 1, c = l(t.text).length + (h ? v : 0); if (i) for (u = 0; u < i.length; ++u) f = i[u], f.to == null && (s = gu(e, f.marker), s ? h && (f.to = s.to == null ? null : s.to + c) : f.to = v); if (e) for (u = 0; u < e.length; ++u) f = e[u], f.to != null && (f.to += c), f.from == null ? (s = gu(i, f.marker), s || (f.from = c, h && (i || (i = [])).push(f))) : (f.from += c, h && (i || (i = [])).push(f)); if (i && (i = cv(i)), e && e != i && (e = cv(e)), a = [i], !h) { if (y = t.text.length - 2, y > 0 && i) for (u = 0; u < i.length; ++u) i[u].to == null && (p || (p = [])).push(new to(i[u].marker, null, null)); for (u = 0; u < y; ++u) a.push(p); a.push(e) } return a } function cv(n) { for (var i, t = 0; t < n.length; ++t) i = n[t], i.from != null && i.from == i.to && i.marker.clearWhenEmpty !== !1 && n.splice(t--, 1); return n.length ? n : null } function lv(n, t) { var i = ud(n, t), s = hh(n, t), r, f, u, e, h, o; if (!i) return s; if (!s) return i; for (r = 0; r < i.length; ++r) if (f = i[r], u = s[r], f && u) n: for (e = 0; e < u.length; ++e) { for (h = u[e], o = 0; o < f.length; ++o) if (f[o].marker == h.marker) continue n; f.push(h) } else u && (i[r] = u); return i } function lk(n, t, i) { var r = null, e, h, c, u, s, f; if (n.iter(t.line, i.line + 1, function (n) { var t, i; if (n.markedSpans) for (t = 0; t < n.markedSpans.length; ++t) i = n.markedSpans[t].marker, i.readOnly && (!r || k(r, i) == -1) && (r || (r = [])).push(i) }), !r) return null; for (e = [{ from: t, to: i }], h = 0; h < r.length; ++h) for (c = r[h], u = c.find(0), s = 0; s < e.length; ++s) if (f = e[s], !(o(f.to, u.from) < 0) && !(o(f.from, u.to) > 0)) { var l = [s, 1], a = o(f.from, u.from), v = o(f.to, u.to); (a < 0 || !c.inclusiveLeft && !a) && l.push({ from: f.from, to: u.from }); (v > 0 || !c.inclusiveRight && !v) && l.push({ from: u.to, to: f.to }); e.splice.apply(e, l); s += l.length - 1 } return e } function av(n) { var i = n.markedSpans, t; if (i) { for (t = 0; t < i.length; ++t) i[t].marker.detachLine(n); n.markedSpans = null } } function vv(n, t) { if (t) { for (var i = 0; i < t.length; ++i) t[i].marker.attachLine(n); n.markedSpans = t } } function io(n) { return n.inclusiveLeft ? -1 : 0 } function ro(n) { return n.inclusiveRight ? 1 : 0 } function yv(n, t) { var r = n.lines.length - t.lines.length, i; if (r != 0) return r; var u = n.find(), f = t.find(), e = o(u.from, f.from) || io(n) - io(t); return e ? -e : (i = o(u.to, f.to) || ro(n) - ro(t), i) ? i : t.id - n.id } function pv(n, t) { var f = ei && n.markedSpans, r, i, u; if (f) for (u = 0; u < f.length; ++u) i = f[u], i.marker.collapsed && (t ? i.from : i.to) == null && (!r || yv(r, i.marker) < 0) && (r = i.marker); return r } function wv(n) { return pv(n, !0) } function nf(n) { return pv(n, !1) } function bv(n, t, i, u, f) { var v = r(n, t), l = ei && v.markedSpans, s, e; if (l) for (s = 0; s < l.length; ++s) if (e = l[s], e.marker.collapsed) { var h = e.marker.find(0), c = o(h.from, i) || io(e.marker) - io(f), a = o(h.to, u) || ro(e.marker) - ro(f); if ((!(c >= 0) || !(a <= 0)) && (!(c <= 0) || !(a >= 0)) && (c <= 0 && (o(h.to, i) > 0 || e.marker.inclusiveRight && f.inclusiveLeft) || c >= 0 && (o(h.from, u) < 0 || e.marker.inclusiveLeft && f.inclusiveRight))) return !0 } } function vt(n) { for (var t; t = wv(n) ;) n = t.find(-1, !0).line; return n } function ak(n) { for (var i, t; i = nf(n) ;) n = i.find(1, !0).line, (t || (t = [])).push(n); return t } function ch(n, t) { var i = r(n, t), u = vt(i); return i == u ? t : a(u) } function kv(n, t) { if (t > n.lastLine()) return t; var i = r(n, t), u; if (!tr(n, i)) return t; while (u = nf(i)) i = u.find(1, !0).line; return a(i) + 1 } function tr(n, t) { var u = ei && t.markedSpans, i, r; if (u) for (r = 0; r < u.length; ++r) if (i = u[r], i.marker.collapsed) { if (i.from == null) return !0; if (!i.marker.widgetNode && i.from == 0 && i.marker.inclusiveLeft && lh(n, t, i)) return !0 } } function lh(n, t, i) { var f, r, u; if (i.to == null) return f = i.marker.find(1, !0), lh(n, f.line, gu(f.line.markedSpans, i.marker)); if (i.marker.inclusiveRight && i.to == t.text.length) return !0; for (u = 0; u < t.markedSpans.length; ++u) if (r = t.markedSpans[u], r.marker.collapsed && !r.marker.widgetNode && r.from == i.to && (r.to == null || r.to != i.from) && (r.marker.inclusiveLeft || i.marker.inclusiveRight) && lh(n, t, r)) return !0 } function dv(n, t, i) { ri(t) < (n.curOp && n.curOp.scrollTop || n.doc.scrollTop) && rh(n, null, i) } function rf(n) { if (n.height != null) return n.height; if (!ed(document.body, n.node)) { var t = "position: relative;"; n.coverGutter && (t += "margin-left: -" + n.cm.getGutterElement().offsetWidth + "px;"); ht(n.cm.display.measure, i("div", [n.node], null, t)) } return n.height = n.node.offsetHeight } function vk(n, t, i, r) { var u = new tf(n, i, r); return u.noHScroll && (n.display.alignWidgets = !0), de(n.doc, t, "widget", function (t) { var i = t.widgets || (t.widgets = []), r; return u.insertAt == null ? i.push(u) : i.splice(Math.min(i.length - 1, Math.max(0, u.insertAt)), 0, u), u.line = t, tr(n.doc, t) || (r = ri(t) < n.doc.scrollTop, yt(t, t.height + rf(u)), r && rh(n, null, u.height), n.curOp.forceUpdate = !0), !0 }), u } function yk(n, t, i, r) { n.text = t; n.stateAfter && (n.stateAfter = null); n.styles && (n.styles = null); n.order != null && (n.order = null); av(n); vv(n, i); var u = r ? r(n) : 1; u != n.height && yt(n, u) } function pk(n) { n.parent = null; av(n) } function gv(n, t) { var i, r; if (n) for (; ;) { if (i = n.match(/(?:^|\s+)line-(background-)?(\S+)/), !i) break; n = n.slice(0, i.index) + n.slice(i.index + i[0].length); r = i[1] ? "bgClass" : "textClass"; t[r] == null ? t[r] = i[2] : new RegExp("(?:^|s)" + i[2] + "(?:$|s)").test(t[r]) || (t[r] += " " + i[2]) } return n } function ny(n, i) { if (n.blankLine) return n.blankLine(i); if (n.innerMode) { var r = t.innerMode(n, i); if (r.mode.blankLine) return r.mode.blankLine(r.state) } } function ah(n, t, i) { for (var u, r = 0; r < 10; r++) if (u = n.token(t, i), t.pos > t.start) return u; throw new Error("Mode " + n.name + " failed to advance stream."); } function ty(n, i, r, u, f, e, o) { var l = r.flattenSpans, v, y; l == null && (l = n.options.flattenSpans); var c = 0, a = null, s = new ku(i, n.options.tabSize), h; for (i == "" && gv(ny(r, u), e) ; !s.eol() ;) s.pos > n.options.maxHighlightLength ? (l = !1, o && vh(n, i, u, s.pos), s.pos = i.length, h = null) : h = gv(ah(r, s, u), e), n.options.addModeClass && (v = t.innerMode(r, u).mode.name, v && (h = "m-" + (h ? v + " " + h : v))), l && a == h || (c < s.start && f(s.start, a), c = s.start, a = h), s.start = s.pos; while (c < s.pos) y = Math.min(s.pos, c + 5e4), f(y, a), c = y } function iy(n, t, i, r) { var u = [n.state.modeGen], e = {}, o; for (ty(n, t.text, n.doc.mode, i, function (n, t) { u.push(n, t) }, e, r), o = 0; o < n.state.overlays.length; ++o) { var s = n.state.overlays[o], f = 1, h = 0; ty(n, t.text, s.mode, !0, function (n, t) { for (var i = f, r, e; h < n;) r = u[f], r > n && u.splice(f, 1, n, u[f + 1], r), f += 2, h = Math.min(n, r); if (t) if (s.opaque) u.splice(i, f - i, n, "cm-overlay " + t), f = i + 2; else for (; i < f; i += 2) e = u[i + 1], u[i + 1] = (e ? e + " " : "") + "cm-overlay " + t }, e) } return { styles: u, classes: e.bgClass || e.textClass ? e : null } } function ry(n, t) { if (!t.styles || t.styles[0] != n.state.modeGen) { var i = iy(n, t, t.stateAfter = su(n, a(t))); t.styles = i.styles; i.classes ? t.styleClasses = i.classes : t.styleClasses && (t.styleClasses = null) } return t.styles } function vh(n, t, i, r) { var f = n.doc.mode, u = new ku(t, n.options.tabSize); for (u.start = u.pos = r || 0, t == "" && ny(f, i) ; !u.eol() && u.pos <= n.options.maxHighlightLength;) ah(f, u, i), u.start = u.pos } function ey(n, t) { if (!n || /^\s*$/.test(n)) return null; var i = t.addModeClass ? fy : uy; return i[n] || (i[n] = n.replace(/\S+/g, "cm-$&")) } function oy(n, t) { var e = i("span", null, null, p ? "padding-right: .1px" : null), r = { pre: i("pre", [e]), content: e, col: 0, pos: 0, cm: n }, f, u, o; for (t.measure = {}, f = 0; f <= (t.rest ? t.rest.length : 0) ; f++) u = f ? t.rest[f - 1] : t.line, r.pos = 0, r.addToken = bk, (s || p) && n.getOption("lineWrapping") && (r.addToken = kk(r.addToken)), ld(n.display.measure) && (o = pt(u)) && (r.addToken = dk(r.addToken, o)), r.map = [], gk(u, r, ry(n, u)), u.styleClasses && (u.styleClasses.bgClass && (r.bgClass = tc(u.styleClasses.bgClass, r.bgClass || "")), u.styleClasses.textClass && (r.textClass = tc(u.styleClasses.textClass, r.textClass || ""))), r.map.length == 0 && r.map.push(0, 0, r.content.appendChild(cd(n.display.measure))), f == 0 ? (t.measure.map = r.map, t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(r.map), (t.measure.caches || (t.measure.caches = [])).push({})); return y(n, "renderLine", n, t.line, r.pre), r.pre.className && (r.textClass = tc(r.pre.className, r.textClass || "")), r } function wk(n) { var t = i("span", "•", "cm-invalidchar"); return t.title = "\\u" + n.charCodeAt(0).toString(16), t } function bk(n, t, r, u, f, e) { var y, w, o, l, v, a, c, p, b; if (t) { if (y = n.cm.options.specialChars, w = !1, y.test(t)) for (o = document.createDocumentFragment(), l = 0; ;) { if (y.lastIndex = l, v = y.exec(t), a = v ? v.index - l : t.length - l, a && (c = document.createTextNode(t.slice(l, l + a)), s && h < 9 ? o.appendChild(i("span", [c])) : o.appendChild(c), n.map.push(n.pos, n.pos + a, c), n.col += a, n.pos += a), !v) break; if (l += a + 1, v[0] == "\t") { var k = n.cm.options.tabSize, d = k - n.col % k, c = o.appendChild(i("span", rp(d), "cm-tab")); n.col += d } else c = n.cm.options.specialCharPlaceholder(v[0]), s && h < 9 ? o.appendChild(i("span", [c])) : o.appendChild(c), n.col += 1; n.map.push(n.pos, n.pos + 1, c); n.pos++ } else n.col += t.length, o = document.createTextNode(t), n.map.push(n.pos, n.pos + t.length, o), s && h < 9 && (w = !0), n.pos += t.length; if (r || u || f || w) return p = r || "", u && (p += u), f && (p += f), b = i("span", [o], p), e && (b.title = e), n.content.appendChild(b); n.content.appendChild(o) } } function kk(n) { function t(n) { for (var i = " ", t = 0; t < n.length - 2; ++t) i += t % 2 ? " " : " "; return i + " " } return function (i, r, u, f, e, o) { n(i, r.replace(/ {3,}/g, t), u, f, e, o) } } function dk(n, t) { return function (i, r, u, f, e, o) { var s, l, c, h; for (u = u ? u + " cm-force-border" : "cm-force-border", s = i.pos, l = s + r.length; ;) { for (c = 0; c < t.length; c++) if (h = t[c], h.to > s && h.from <= s) break; if (h.to >= l) return n(i, r, u, f, e, o); n(i, r.slice(0, h.to - s), u, f, null, o); f = null; r = r.slice(h.to - s); s = h.to } } } function sy(n, t, i, r) { var u = !r && i.widgetNode; u && (n.map.push(n.pos, n.pos + t, u), n.content.appendChild(u)); n.pos += t } function gk(n, t, i) { var d = n.markedSpans, g = n.text, v = 0, h, a, u, f, s, l, k, it; if (!d) { for (h = 1; h < i.length; h += 2) t.addToken(t, g.slice(v, v = i[h]), ey(i[h + 1], t.cm.options)); return } for (var nt = g.length, r = 0, h = 1, c = "", tt, o = 0, y, p, w, b, e; ;) { if (o == r) { for (y = p = w = b = "", e = null, o = Infinity, a = [], s = 0; s < d.length; ++s) u = d[s], f = u.marker, u.from <= r && (u.to == null || u.to > r) ? (u.to != null && o > u.to && (o = u.to, p = ""), f.className && (y += " " + f.className), f.startStyle && u.from == r && (w += " " + f.startStyle), f.endStyle && u.to == o && (p += " " + f.endStyle), f.title && !b && (b = f.title), f.collapsed && (!e || yv(e.marker, f) < 0) && (e = u)) : u.from > r && o > u.from && (o = u.from), f.type == "bookmark" && u.from == r && f.widgetNode && a.push(f); if (e && (e.from || 0) == r && (sy(t, (e.to == null ? nt + 1 : e.to) - r, e.marker, e.from == null), e.to == null)) return; if (!e && a.length) for (s = 0; s < a.length; ++s) sy(t, 0, a[s]) } if (r >= nt) break; for (l = Math.min(nt, o) ; ;) { if (c) { if (k = r + c.length, e || (it = k > l ? c.slice(0, l - r) : c, t.addToken(t, it, tt ? tt + y : y, w, r + it.length == o ? p : "", b)), k >= l) { c = c.slice(l - r); r = l; break } r = k; w = "" } c = g.slice(v, v = i[h++]); tt = ey(i[h++], t.cm.options) } } } function hy(n, t) { return t.from.ch == 0 && t.to.ch == 0 && l(t.text) == "" && (!n.cm || n.cm.options.wholeLineUpdateBefore) } function yh(n, t, i, u) { function c(n) { return i ? i[n] : null } function a(n, i, r) { yk(n, i, r, u); b(n, "change", n, t) } var o = t.from, v = t.to, e = t.text, s = r(n, o.line), y = r(n, v.line), k = l(e), w = c(e.length - 1), p = v.line - o.line, f, h; if (hy(n, t)) { for (f = 0, h = []; f < e.length - 1; ++f) h.push(new li(e[f], c(f), u)); a(y, y.text, w); p && n.remove(o.line, p); h.length && n.insert(o.line, h) } else if (s == y) if (e.length == 1) a(s, s.text.slice(0, o.ch) + k + s.text.slice(v.ch), w); else { for (h = [], f = 1; f < e.length - 1; ++f) h.push(new li(e[f], c(f), u)); h.push(new li(k + s.text.slice(v.ch), w, u)); a(s, s.text.slice(0, o.ch) + e[0], c(0)); n.insert(o.line + 1, h) } else if (e.length == 1) a(s, s.text.slice(0, o.ch) + e[0] + y.text.slice(v.ch), c(0)), n.remove(o.line + 1, p); else { for (a(s, s.text.slice(0, o.ch) + e[0], c(0)), a(y, k + y.text.slice(v.ch), w), f = 1, h = []; f < e.length - 1; ++f) h.push(new li(e[f], c(f), u)); p > 1 && n.remove(o.line + 1, p - 1); n.insert(o.line + 1, h) } b(n, "change", n, t) } function uf(n) { this.lines = n; this.parent = null; for (var t = 0, i = 0; t < n.length; ++t) n[t].parent = this, i += n[t].height; this.height = i } function ff(n) { var r, u, t, i; for (this.children = n, r = 0, u = 0, t = 0; t < n.length; ++t) i = n[t], r += i.chunkSize(), u += i.height, i.parent = this; this.size = r; this.height = u; this.parent = null } function ir(n, t, i) { function r(n, u, f) { var o, e, s; if (n.linked) for (o = 0; o < n.linked.length; ++o) (e = n.linked[o], e.doc != u) && (s = f && e.sharedHist, !i || s) && (t(e.doc, s), r(e.doc, n, s)) } r(n, null, !0) } function ay(n, t) { if (t.cm) throw new Error("This document is already in use."); n.doc = t; t.cm = n; wo(n); po(n); n.options.lineWrapping || ko(n); n.options.mode = t.modeOption; rt(n) } function r(n, t) { var i, r, u, f; if (t -= n.first, t < 0 || t >= n.size) throw new Error("There is no line " + (t + n.first) + " in the document."); for (i = n; !i.lines;) for (r = 0; ; ++r) { if (u = i.children[r], f = u.chunkSize(), t < f) { i = u; break } t -= f } return i.lines[t] } function of(n, t, i) { var u = [], r = t.line; return n.iter(t.line, i.line + 1, function (n) { var f = n.text; r == i.line && (f = f.slice(0, i.ch)); r == t.line && (f = f.slice(t.ch)); u.push(f); ++r }), u } function ph(n, t, i) { var r = []; return n.iter(t, i, function (n) { r.push(n.text) }), r } function yt(n, t) { var r = t - n.height, i; if (r) for (i = n; i; i = i.parent) i.height += r } function a(n) { var i, u, t, r; if (n.parent == null) return null; for (i = n.parent, u = k(i.lines, n), t = i.parent; t; i = t, t = t.parent) for (r = 0; ; ++r) { if (t.children[r] == i) break; u += t.children[r].chunkSize() } return u + i.first } function rr(n, t) { var u = n.first, r, f, i, o, e; n: do { for (i = 0; i < n.children.length; ++i) { if (r = n.children[i], f = r.height, t < f) { n = r; continue n } t -= f; u += r.chunkSize() } return u } while (!n.lines); for (i = 0; i < n.lines.length; ++i) { if (o = n.lines[i], e = o.height, t < e) break; t -= e } return u + i } function ri(n) { var u, i, f, r, t, e; for (n = vt(n), u = 0, i = n.parent, t = 0; t < i.lines.length; ++t) if (f = i.lines[t], f == n) break; else u += f.height; for (r = i.parent; r; i = r, r = i.parent) for (t = 0; t < r.children.length; ++t) if (e = r.children[t], e == i) break; else u += e.height; return u } function pt(n) { var t = n.order; return t == null && (t = n.order = yp(n.text)), t } function uo(n) { this.done = []; this.undone = []; this.undoDepth = Infinity; this.lastModTime = this.lastSelTime = 0; this.lastOp = this.lastSelOp = null; this.lastOrigin = this.lastSelOrigin = null; this.generation = this.maxGeneration = n || 1 } function wh(n, t) { var i = { from: cs(t.from), to: ii(t), text: of(n, t.from, t.to) }; return py(n, i, t.from.line, t.to.line + 1), ir(n, function (n) { py(n, i, t.from.line, t.to.line + 1) }, !0), i } function vy(n) { while (n.length) { var t = l(n); if (t.ranges) n.pop(); else break } } function nd(n, t) { return t ? (vy(n.done), l(n.done)) : n.done.length && !l(n.done).ranges ? l(n.done) : n.done.length > 1 && !n.done[n.done.length - 2].ranges ? (n.done.pop(), l(n.done)) : void 0 } function yy(n, t, i, r) { var u = n.history, s, f, e, h; if (u.undone.length = 0, s = +new Date, (u.lastOp == r || u.lastOrigin == t.origin && t.origin && (t.origin.charAt(0) == "+" && n.cm && u.lastModTime > s - n.cm.options.historyEventDelay || t.origin.charAt(0) == "*")) && (f = nd(u, u.lastOp == r))) e = l(f.changes), o(t.from, t.to) == 0 && o(t.from, e.to) == 0 ? e.to = ii(t) : f.changes.push(wh(n, t)); else for (h = l(u.done), h && h.ranges || fo(n.sel, u.done), f = { changes: [wh(n, t)], generation: u.generation }, u.done.push(f) ; u.done.length > u.undoDepth;) u.done.shift(), u.done[0].ranges || u.done.shift(); u.done.push(i); u.generation = ++u.maxGeneration; u.lastModTime = u.lastSelTime = s; u.lastOp = u.lastSelOp = r; u.lastOrigin = u.lastSelOrigin = t.origin; e || y(n, "historyAdded") } function td(n, t, i, r) { var u = t.charAt(0); return u == "*" || u == "+" && i.ranges.length == r.ranges.length && i.somethingSelected() == r.somethingSelected() && new Date - n.history.lastSelTime <= (n.cm ? n.cm.options.historyEventDelay : 500) } function id(n, t, i, r) { var u = n.history, f = r && r.origin; i == u.lastSelOp || f && u.lastSelOrigin == f && (u.lastModTime == u.lastSelTime && u.lastOrigin == f || td(n, f, l(u.done), t)) ? u.done[u.done.length - 1] = t : fo(t, u.done); u.lastSelTime = +new Date; u.lastSelOrigin = f; u.lastSelOp = i; r && r.clearRedo !== !1 && vy(u.undone) } function fo(n, t) { var i = l(t); i && i.ranges && i.equals(n) || t.push(n) } function py(n, t, i, r) { var u = t["spans_" + n.id], f = 0; n.iter(Math.max(n.first, i), Math.min(n.first + n.size, r), function (i) { i.markedSpans && ((u || (u = t["spans_" + n.id] = {}))[f] = i.markedSpans); ++f }) } function rd(n) { if (!n) return null; for (var i = 0, t; i < n.length; ++i) n[i].marker.explicitlyCleared ? t || (t = n.slice(0, i)) : t && t.push(n[i]); return t ? t.length ? t : null : n } function ud(n, t) { var u = t["spans_" + n.id], i, r; if (!u) return null; for (i = 0, r = []; i < t.text.length; ++i) r.push(rd(u[i])); return r } function br(n, t, i) { for (var u, c, s, h, r, a, f, e = 0, o = []; e < n.length; ++e) { if (u = n[e], u.ranges) { o.push(i ? dt.prototype.deepCopy.call(u) : u); continue } for (c = u.changes, s = [], o.push({ changes: s }), h = 0; h < c.length; ++h) if (r = c[h], s.push({ from: r.from, to: r.to, text: r.text }), t) for (f in r) (a = f.match(/^spans_(\d+)$/)) && k(t, Number(a[1])) > -1 && (l(s)[f] = r[f], delete r[f]) } return o } function wy(n, t, i, r) { i < n.line ? n.line += r : t < n.line && (n.line = t, n.ch = 0) } function by(t, i, r, u) { for (var f, h, e, o, s = 0; s < t.length; ++s) { if (f = t[s], h = !0, f.ranges) { for (f.copied || (f = t[s] = f.deepCopy(), f.copied = !0), e = 0; e < f.ranges.length; e++) wy(f.ranges[e].anchor, i, r, u), wy(f.ranges[e].head, i, r, u); continue } for (e = 0; e < f.changes.length; ++e) if (o = f.changes[e], r < o.from.line) o.from = n(o.from.line + u, o.from.ch), o.to = n(o.to.line + u, o.to.ch); else if (i <= o.to.line) { h = !1; break } h || (t.splice(0, s + 1), s = 0) } } function ky(n, t) { var i = t.from.line, r = t.to.line, u = t.text.length - (r - i) - 1; by(n.done, i, r, u); by(n.undone, i, r, u) } function bh(n) { return n.defaultPrevented != null ? n.defaultPrevented : n.returnValue == !1 } function sf(n) { return n.target || n.srcElement } function gy(n) { var t = n.which; return t == null && (n.button & 1 ? t = 1 : n.button & 2 ? t = 3 : n.button & 4 && (t = 2)), ot && n.ctrlKey && t == 1 && (t = 3), t } function b(n, t) { function e(n) { return function () { n.apply(null, f) } } var u = n._handlers && n._handlers[t], f, i, r; if (u) for (f = Array.prototype.slice.call(arguments, 2), di ? i = di.delayedCallbacks : hf ? i = hf : (i = hf = [], setTimeout(fd, 0)), r = 0; r < u.length; ++r) i.push(e(u[r])) } function fd() { var t = hf, n; for (hf = null, n = 0; n < t.length; ++n) t[n]() } function wt(n, t, i) { return y(n, i || t.type, n, t), bh(t) || t.codemirrorIgnore } function np(n) { var i = n._handlers && n._handlers.cursorActivity, r, t; if (i) for (r = n.curOp.cursorActivityHandlers || (n.curOp.cursorActivityHandlers = []), t = 0; t < i.length; ++t) k(r, i[t]) == -1 && r.push(i[t]) } function st(n, t) { var i = n._handlers && n._handlers[t]; return i && i.length > 0 } function kr(n) { n.prototype.on = function (n, t) { e(this, n, t) }; n.prototype.off = function (n, t) { ui(this, n, t) } } function dh() { this.id = null } function ip(n, t, i) { for (var f, e, r = 0, u = 0; ;) { if (f = n.indexOf("\t", r), f == -1 && (f = n.length), e = f - r, f == n.length || u + e >= t) return r + Math.min(e, t - u); if (u += f - r, u += i - u % i, r = f + 1, u >= t) return r } } function rp(n) { while (lf.length <= n) lf.push(l(lf) + " "); return lf[n] } function l(n) { return n[n.length - 1] } function k(n, t) { for (var i = 0; i < n.length; ++i) if (n[i] == t) return i; return -1 } function af(n, t) { for (var r = [], i = 0; i < n.length; i++) r[i] = t(n[i], i); return r } function up(n, t) { var i, r; return Object.create ? i = Object.create(n) : (r = function () { }, r.prototype = n, i = new r), t && vf(t, i), i } function vf(n, t, i) { t || (t = {}); for (var r in n) n.hasOwnProperty(r) && (i !== !1 || !t.hasOwnProperty(r)) && (t[r] = n[r]); return t } function kt(n) { var t = Array.prototype.slice.call(arguments, 1); return function () { return n.apply(null, t) } } function oo(n, t) { return t ? t.source.indexOf("\\w") > -1 && gh(n) ? !0 : t.test(n) : gh(n) } function ep(n) { for (var t in n) if (n.hasOwnProperty(t) && n[t]) return !1; return !0 } function yf(n) { return n.charCodeAt(0) >= 768 && op.test(n) } function i(n, t, i, r) { var u = document.createElement(n), f; if (i && (u.className = i), r && (u.style.cssText = r), typeof t == "string") u.appendChild(document.createTextNode(t)); else if (t) for (f = 0; f < t.length; ++f) u.appendChild(t[f]); return u } function ur(n) { for (var t = n.childNodes.length; t > 0; --t) n.removeChild(n.firstChild); return n } function ht(n, t) { return ur(n).appendChild(t) } function ed(n, t) { if (n.contains) return n.contains(t); while (t = t.parentNode) if (t == n) return !0 } function vi() { return document.activeElement } function nc(n) { return new RegExp("\\b" + n + "\\b\\s*") } function so(n, t) { var i = nc(t); i.test(n.className) && (n.className = n.className.replace(i, "")) } function ho(n, t) { nc(t).test(n.className) || (n.className += " " + t) } function tc(n, t) { for (var r = n.split(" "), i = 0; i < r.length; i++) r[i] && !nc(r[i]).test(t) && (t += " " + r[i]); return t } function sp(n) { var i, t, r; if (document.body.getElementsByClassName) for (i = document.body.getElementsByClassName("CodeMirror"), t = 0; t < i.length; t++) r = i[t].CodeMirror, r && n(r) } function od() { ic || (sd(), ic = !0) } function sd() { var n; e(window, "resize", function () { n == null && (n = setTimeout(function () { n = null; pf = null; sp(hb) }, 100)) }); e(window, "blur", function () { sp(ye) }) } function hd(n) { if (pf != null) return pf; var t = i("div", null, null, "width: 50px; height: 50px; overflow-x: scroll"); return ht(n, t), t.offsetWidth && (pf = t.offsetHeight - t.clientHeight), pf || 0 } function cd(n) { if (rc == null) { var t = i("span", "​"); ht(n, i("span", [t, document.createTextNode("x")])); n.firstChild.offsetHeight != 0 && (rc = t.offsetWidth <= 1 && t.offsetHeight > 2 && !(s && h < 8)) } return rc ? i("span", "​") : i("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px") } function ld(n) { var i, t, r; return uc != null ? uc : (i = ht(n, document.createTextNode("AخA")), t = gr(i, 0, 1).getBoundingClientRect(), t.left == t.right) ? !1 : (r = gr(i, 1, 2).getBoundingClientRect(), uc = r.right - t.right < 3) } function vd(n) { if (fc != null) return fc; var t = ht(n, i("span", "x")), r = t.getBoundingClientRect(), u = gr(t, 0, 1).getBoundingClientRect(); return fc = Math.abs(r.left - u.left) > 1 } function yd(n, t, i, r) { var e, f, u; if (!n) return r(t, i, "ltr"); for (e = !1, f = 0; f < n.length; ++f) u = n[f], (u.from < i && u.to > t || t == i && u.to == t) && (r(Math.max(u.from, t), Math.min(u.to, i), u.level == 1 ? "rtl" : "ltr"), e = !0); e || r(t, i, "ltr") } function ec(n) { return n.level % 2 ? n.to : n.from } function oc(n) { return n.level % 2 ? n.from : n.to } function co(n) { var t = pt(n); return t ? ec(t[0]) : 0 } function lo(n) { var t = pt(n); return t ? oc(l(t)) : n.text.length } function lp(t, i) { var e = r(t.doc, i), u = vt(e), f, o; return u != e && (i = a(u)), f = pt(u), o = f ? f[0].level % 2 ? lo(u) : co(u) : 0, n(i, o) } function pd(t, i) { for (var e, u = r(t.doc, i), f, o; e = nf(u) ;) u = e.find(1, !0).line, i = null; return f = pt(u), o = f ? f[0].level % 2 ? co(u) : lo(u) : u.text.length, n(i == null ? a(u) : i, o) } function ap(t, i) { var u = lp(t, i.line), e = r(t.doc, u.line), o = pt(e), f, s; return !o || o[0].level == 0 ? (f = Math.max(0, e.text.search(/\S/)), s = i.line == u.line && i.ch <= f && i.ch, n(u.line, s ? 0 : f)) : u } function wd(n, t, i) { var r = n[0].level; return t == r ? !0 : i == r ? !1 : t < i } function sc(n, t) { var r, u, i; for (wf = null, r = 0; r < n.length; ++r) { if (i = n[r], i.from < t && i.to > t) return r; if (i.from == t || i.to == t) if (u == null) u = r; else return wd(n, i.level, n[u].level) ? (i.from != i.to && (wf = u), r) : (i.from != i.to && (wf = r), u) } return u } function hc(n, t, i, r) { if (!r) return t + i; do t += i; while (t > 0 && yf(n.text.charAt(t))); return t } function cc(n, t, i, r) { var e = pt(n); if (!e) return vp(n, t, i, r); for (var o = sc(e, t), u = e[o], f = hc(n, t, u.level % 2 ? -i : i, r) ; ;) { if (f > u.from && f < u.to) return f; if (f == u.from || f == u.to) return sc(e, f) == o ? f : (u = e[o += i], i > 0 == u.level % 2 ? u.to : u.from); if (u = e[o += i], !u) return null; f = i > 0 == u.level % 2 ? hc(n, u.to, -1, r) : hc(n, u.from, 1, r) } } function vp(n, t, i, r) { var u = t + i; if (r) while (u > 0 && yf(n.text.charAt(u))) u += i; return u < 0 || u > n.text.length ? null : u } var nu = /gecko\/\d/i.test(navigator.userAgent), lc = /MSIE \d/.test(navigator.userAgent), ac = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), s = lc || ac, h = s && (lc ? document.documentMode || 6 : ac[1]), p = /WebKit\//.test(navigator.userAgent), pp = p && /Qt\/\d+\.\d+/.test(navigator.userAgent), wp = /Chrome\//.test(navigator.userAgent), et = /Opera\//.test(navigator.userAgent), vc = /Apple Computer/.test(navigator.vendor), ao = /KHTML\//.test(navigator.userAgent), bp = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent), kp = /PhantomJS/.test(navigator.userAgent), tu = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent), vo = tu || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent), ot = tu || /Mac/.test(navigator.platform), dp = /win/i.test(navigator.platform), yi = et && navigator.userAgent.match(/Version\/(\d*\.\d*)/), n, o, ue, bi, di, oa, si, ce, le, nh, yu, ut, pa, ve, ii, ev, nr, eh, oh, vr, yr, ge, hi, pr, ov, bu, at, ku, ci, sv, du, tf, li, uy, fy, cy, tt, ly, ef, d, dy, eo, ft, lf, dr, fp, gh, op, gr, ic, hp, pf, rc, uc, fi, wf, yp; yi && (yi = Number(yi[1])); yi && yi >= 15 && (et = !1, p = !0); var yc = ot && (pp || et && (yi == null || yi < 12.11)), yo = nu || s && h >= 9, pc = !1, ei = !1; n = t.Pos = function (t, i) { if (!(this instanceof n)) return new n(t, i); this.line = t; this.ch = i }; o = t.cmpPos = function (n, t) { return n.line - t.line || n.ch - t.ch }; dt.prototype = { primary: function () { return this.ranges[this.primIndex] }, equals: function (n) { var t, i, r; if (n == this) return !0; if (n.primIndex != this.primIndex || n.ranges.length != this.ranges.length) return !1; for (t = 0; t < this.ranges.length; t++) if (i = this.ranges[t], r = n.ranges[t], o(i.anchor, r.anchor) != 0 || o(i.head, r.head) != 0) return !1; return !0 }, deepCopy: function () { for (var t = [], n = 0; n < this.ranges.length; n++) t[n] = new c(cs(this.ranges[n].anchor), cs(this.ranges[n].head)); return new dt(t, this.primIndex) }, somethingSelected: function () { for (var n = 0; n < this.ranges.length; n++) if (!this.ranges[n].empty()) return !0; return !1 }, contains: function (n, t) { var i, r; for (t || (t = n), i = 0; i < this.ranges.length; i++) if (r = this.ranges[i], o(t, r.from()) >= 0 && o(n, r.to()) <= 0) return i; return -1 } }; c.prototype = { from: function () { return as(this.anchor, this.head) }, to: function () { return ls(this.anchor, this.head) }, empty: function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch } }; ue = { left: 0, right: 0, top: 0, bottom: 0 }; di = null; oa = 0; si = null; nh = 0; yu = 0; ut = null; s ? ut = -.53 : nu ? ut = 15 : wp ? ut = -.7 : vc && (ut = -1 / 3); ve = null; ii = t.changeEnd = function (t) { return t.text ? n(t.from.line + t.text.length - 1, l(t.text).length + (t.text.length == 1 ? t.from.ch : 0)) : t.to }; t.prototype = { constructor: t, focus: function () { window.focus(); it(this); au(this) }, setOption: function (n, t) { var i = this.options, r = i[n]; (i[n] != t || n == "mode") && (i[n] = t, nr.hasOwnProperty(n) && v(this, nr[n])(this, t, r)) }, getOption: function (n) { return this.options[n] }, getDoc: function () { return this.doc }, addKeyMap: function (n, t) { this.state.keyMaps[t ? "push" : "unshift"](n) }, removeKeyMap: function (n) { for (var i = this.state.keyMaps, t = 0; t < i.length; ++t) if (i[t] == n || typeof i[t] != "string" && i[t].name == n) return i.splice(t, 1), !0 }, addOverlay: w(function (n, i) { var r = n.token ? n : t.getMode(this.options, n); if (r.startState) throw new Error("Overlays may not be stateful."); this.state.overlays.push({ mode: r, modeSpec: n, opaque: i && i.opaque }); this.state.modeGen++; rt(this) }), removeOverlay: w(function (n) { for (var r, i = this.state.overlays, t = 0; t < i.length; ++t) if (r = i[t].modeSpec, r == n || typeof n == "string" && r.name == n) { i.splice(t, 1); this.state.modeGen++; rt(this); return } }), indentLine: w(function (n, t, i) { typeof t != "string" && typeof t != "number" && (t = t == null ? this.options.smartIndent ? "smart" : "prev" : t ? "add" : "subtract"); uu(this.doc, n) && wu(this, n, t, i) }), indentSelection: w(function (n) { for (var i, u, f, e = this.doc.sel.ranges, r = -1, t = 0; t < e.length; t++) if (i = e[t], i.empty()) i.head.line > r && (wu(this, i.head.line, n, !0), r = i.head.line, t == this.doc.sel.primIndex && lr(this)); else { var o = i.from(), s = i.to(), h = Math.max(r, o.line); for (r = Math.min(this.lastLine(), s.line - (s.ch ? 0 : 1)) + 1, u = h; u < r; ++u) wu(this, u, n); f = this.doc.sel.ranges; o.ch == 0 && e.length == f.length && f[t].from().ch > 0 && vs(this.doc, t, new c(o, f[t].to()), ai) } }), getTokenAt: function (n, t) { var f = this.doc, o; n = u(f, n); for (var e = su(this, n.line, t), s = this.doc.mode, h = r(f, n.line), i = new ku(h.text, this.options.tabSize) ; i.pos < n.ch && !i.eol() ;) i.start = i.pos, o = ah(s, i, e); return { start: i.start, end: i.pos, string: i.current(), type: o || null, state: e } }, getTokenTypeAt: function (n) { var t, e; n = u(this.doc, n); var f = ry(this, r(this.doc, n.line)), s = 0, h = (f.length - 1) / 2, o = n.ch, i; if (o == 0) i = f[2]; else for (; ;) if (t = s + h >> 1, (t ? f[t * 2 - 1] : 0) >= o) h = t; else if (f[t * 2 + 1] < o) s = t + 1; else { i = f[t * 2 + 2]; break } return e = i ? i.indexOf("cm-overlay ") : -1, e < 0 ? i : e == 0 ? null : i.slice(0, e - 1) }, getModeAt: function (n) { var i = this.doc.mode; return i.innerMode ? t.innerMode(i, this.getTokenAt(n).state).mode : i }, getHelper: function (n, t) { return this.getHelpers(n, t)[0] }, getHelpers: function (n, t) { var f = [], r, i, o, u, e; if (!hi.hasOwnProperty(t)) return hi; if (r = hi[t], i = this.getModeAt(n), typeof i[t] == "string") r[i[t]] && f.push(r[i[t]]); else if (i[t]) for (u = 0; u < i[t].length; u++) o = r[i[t][u]], o && f.push(o); else i.helperType && r[i.helperType] ? f.push(r[i.helperType]) : r[i.name] && f.push(r[i.name]); for (u = 0; u < r._global.length; u++) e = r._global[u], e.pred(i, this) && k(f, e.val) == -1 && f.push(e.val); return f }, getStateAfter: function (n, t) { var i = this.doc; return n = hl(i, n == null ? i.first + i.size - 1 : n), su(this, n + 1, t) }, cursorCoords: function (n, t) { var r, i = this.doc.sel.primary(); return r = n == null ? i.head : typeof n == "object" ? u(this.doc, n) : n ? i.from() : i.to(), gt(this, r, t || "page") }, charCoords: function (n, t) { return bs(this, u(this.doc, n), t || "page") }, coordsChar: function (n, t) { return n = fa(this, n, t || "page"), ks(this, n.left, n.top) }, lineAtHeight: function (n, t) { return n = fa(this, { top: n, left: 0 }, t || "page").top, rr(this.doc, n + this.display.viewOffset) }, heightAtLine: function (n, t) { var u = !1, f = this.doc.first + this.doc.size - 1, i; return n < this.doc.first ? n = this.doc.first : n > f && (n = f, u = !0), i = r(this.doc, n), ws(this, i, { top: 0, left: 0 }, t || "page").top + (u ? this.doc.height - ri(i) : 0) }, defaultTextHeight: function () { return ki(this.display) }, defaultCharWidth: function () { return cu(this.display) }, setGutterMarker: w(function (n, t, i) { return de(this.doc, n, "gutter", function (n) { var r = n.gutterMarkers || (n.gutterMarkers = {}); return r[t] = i, !i && ep(r) && (n.gutterMarkers = null), !0 }) }), clearGutter: w(function (n) { var t = this, i = t.doc, r = i.first; i.iter(function (i) { i.gutterMarkers && i.gutterMarkers[n] && (i.gutterMarkers[n] = null, ti(t, r, "gutter"), ep(i.gutterMarkers) && (i.gutterMarkers = null)); ++r }) }), addLineWidget: w(function (n, t, i) { return vk(this, n, t, i) }), removeLineWidget: function (n) { n.clear() }, lineInfo: function (n) { var t; if (typeof n == "number") { if (!uu(this.doc, n) || (t = n, n = r(this.doc, n), !n)) return null } else if (t = a(n), t == null) return null; return { line: t, handle: n, text: n.text, gutterMarkers: n.gutterMarkers, textClass: n.textClass, bgClass: n.bgClass, wrapClass: n.wrapClass, widgets: n.widgets } }, getViewport: function () { return { from: this.display.viewFrom, to: this.display.viewTo } }, addWidget: function (n, t, i, r, f) { var s = this.display, o, e, h, c; n = gt(this, u(this.doc, n)); o = n.bottom; e = n.left; t.style.position = "absolute"; s.sizer.appendChild(t); r == "over" ? o = n.top : (r == "above" || r == "near") && (h = Math.max(s.wrapper.clientHeight, this.doc.height), c = Math.max(s.sizer.clientWidth, s.lineSpace.clientWidth), (r == "above" || n.bottom + t.offsetHeight > h) && n.top > t.offsetHeight ? o = n.top - t.offsetHeight : n.bottom + t.offsetHeight <= h && (o = n.bottom), e + t.offsetWidth > c && (e = c - t.offsetWidth)); t.style.top = o + "px"; t.style.left = t.style.right = ""; f == "right" ? (e = s.sizer.clientWidth - t.offsetWidth, t.style.right = "0px") : (f == "left" ? e = 0 : f == "middle" && (e = (s.sizer.clientWidth - t.offsetWidth) / 2), t.style.left = e + "px"); i && tk(this, e, o, e + t.offsetWidth, o + t.offsetHeight) }, triggerOnKeyDown: w(ba), triggerOnKeyPress: w(da), triggerOnKeyUp: ka, execCommand: function (n) { if (bu.hasOwnProperty(n)) return bu[n](this) }, findPosH: function (n, t, i, r) { var o = 1, e, f; for (t < 0 && (o = -1, t = -t), e = 0, f = u(this.doc, n) ; e < t; ++e) if (f = uh(this.doc, f, o, i, r), f.hitSide) break; return f }, moveH: w(function (n, t) { var i = this; i.extendSelectionsBy(function (r) { return i.display.shift || i.doc.extend || r.empty() ? uh(i.doc, r.head, n, t, i.options.rtlMoveVisually) : n < 0 ? r.from() : r.to() }, cf) }), deleteH: w(function (n, t) { var r = this.doc.sel, i = this.doc; r.somethingSelected() ? i.replaceSelection("", null, "+delete") : ar(this, function (r) { var u = uh(i, r.head, n, t, !1); return n < 0 ? { from: u, to: r.head } : { from: r.head, to: u } }) }), findPosV: function (n, t, i, r) { var h = 1, o = r, s, f, e; for (t < 0 && (h = -1, t = -t), s = 0, f = u(this.doc, n) ; s < t; ++s) if (e = gt(this, f, "div"), o == null ? o = e.left : e.left = o, f = fv(this, e, h, i), f.hitSide) break; return f }, moveV: w(function (n, t) { var r = this, i = this.doc, f = [], e = !r.display.shift && !i.extend && i.sel.somethingSelected(), u; if (i.extendSelectionsBy(function (u) { var o, s; return e ? n < 0 ? u.from() : u.to() : (o = gt(r, u.head, "div"), u.goalColumn != null && (o.left = u.goalColumn), f.push(o.left), s = fv(r, o, n, t), t == "page" && u == i.sel.primary() && rh(r, null, bs(r, s, "div").top - o.top), s) }, cf), f.length) for (u = 0; u < i.sel.ranges.length; u++) i.sel.ranges[u].goalColumn = f[u] }), toggleOverwrite: function (n) { (n == null || n != this.state.overwrite) && ((this.state.overwrite = !this.state.overwrite) ? ho(this.display.cursorDiv, "CodeMirror-overwrite") : so(this.display.cursorDiv, "CodeMirror-overwrite"), y(this, "overwriteToggle", this, this.state.overwrite)) }, hasFocus: function () { return vi() == this.display.input }, scrollTo: w(function (n, t) { (n != null || t != null) && ke(this); n != null && (this.curOp.scrollLeft = n); t != null && (this.curOp.scrollTop = t) }), getScrollInfo: function () { var n = this.display.scroller, t = bt; return { left: n.scrollLeft, top: n.scrollTop, height: n.scrollHeight - t, width: n.scrollWidth - t, clientHeight: n.clientHeight - t, clientWidth: n.clientWidth - t } }, scrollIntoView: w(function (t, i) { if (t == null ? (t = { from: this.doc.sel.primary().head, to: null }, i == null && (i = this.options.cursorScrollMargin)) : typeof t == "number" ? t = { from: n(t, 0), to: null } : t.from == null && (t = { from: t, to: null }), t.to || (t.to = t.from), t.margin = i || 0, t.from.line != null) ke(this), this.curOp.scrollToPos = t; else { var r = be(this, Math.min(t.from.left, t.to.left), Math.min(t.from.top, t.to.top) - t.margin, Math.max(t.from.right, t.to.right), Math.max(t.from.bottom, t.to.bottom) + t.margin); this.scrollTo(r.scrollLeft, r.scrollTop) } }), setSize: w(function (n, t) { function u(n) { return typeof n == "number" || /^\d+$/.test(String(n)) ? n + "px" : n } var i = this, r; n != null && (i.display.wrapper.style.width = u(n)); t != null && (i.display.wrapper.style.height = u(t)); i.options.lineWrapping && ia(this); r = i.display.viewFrom; i.doc.iter(r, i.display.viewTo, function (n) { if (n.widgets) for (var t = 0; t < n.widgets.length; t++) if (n.widgets[t].noHScroll) { ti(i, r, "widget"); break } ++r }); i.curOp.forceUpdate = !0; y(i, "refresh", this) }), operation: function (n) { return ni(this, n) }, refresh: w(function () { var n = this.display.cachedTextHeight; rt(this); this.curOp.forceUpdate = !0; hu(this); this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop); bo(this); (n == null || Math.abs(n - ki(this.display)) > .5) && wo(this); y(this, "refresh", this) }), swapDoc: w(function (n) { var t = this.doc; return t.cm = null, ay(this, n), hu(this), lt(this), this.scrollTo(n.scrollLeft, n.scrollTop), b(this, "swapDoc", this, t), t }), getInputField: function () { return this.display.input }, getWrapperElement: function () { return this.display.wrapper }, getScrollerElement: function () { return this.display.scroller }, getGutterElement: function () { return this.display.gutters } }; kr(t); ev = t.defaults = {}; nr = t.optionHandlers = {}; eh = t.Init = { toString: function () { return "CodeMirror.Init" } }; f("value", "", function (n, t) { n.setValue(t) }, !0); f("mode", null, function (n, t) { n.doc.modeOption = t; po(n) }, !0); f("indentUnit", 2, po, !0); f("indentWithTabs", !1); f("smartIndent", !0); f("tabSize", 4, function (n) { iu(n); hu(n); rt(n) }, !0); f("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function (n, t) { n.options.specialChars = new RegExp(t.source + (t.test("\t") ? "" : "|\t"), "g"); n.refresh() }, !0); f("specialCharPlaceholder", wk, function (n) { n.refresh() }, !0); f("electricChars", !0); f("rtlMoveVisually", !dp); f("wholeLineUpdateBefore", !0); f("theme", "default", function (n) { kc(n); ru(n) }, !0); f("keyMap", "default", bc); f("extraKeys", null); f("lineWrapping", !1, nw, !0); f("gutters", [], function (n) { go(n.options); ru(n) }, !0); f("fixedGutter", !0, function (n, t) { n.display.gutters.style.left = t ? rs(n.display) + "px" : "0"; n.refresh() }, !0); f("coverGutterNextToScrollbar", !1, pi, !0); f("lineNumbers", !1, function (n) { go(n.options); ru(n) }, !0); f("firstLineNumber", 1, ru, !0); f("lineNumberFormatter", function (n) { return n }, ru, !0); f("showCursorWhenSelecting", !1, eu, !0); f("resetSelectionOnContextMenu", !0); f("readOnly", !1, function (n, t) { t == "nocursor" ? (ye(n), n.display.input.blur(), n.display.disabled = !0) : (n.display.disabled = !1, t || lt(n)) }); f("disableInput", !1, function (n, t) { t || lt(n) }, !0); f("dragDrop", !0); f("cursorBlinkRate", 530); f("cursorScrollMargin", 0); f("cursorHeight", 1, eu, !0); f("singleCursorHeightPerLine", !0, eu, !0); f("workTime", 100); f("workDelay", 100); f("flattenSpans", !0, iu, !0); f("addModeClass", !1, iu, !0); f("pollInterval", 100); f("undoDepth", 200, function (n, t) { n.doc.history.undoDepth = t }); f("historyEventDelay", 1250); f("viewportMargin", 10, function (n) { n.refresh() }, !0); f("maxHighlightLength", 1e4, iu, !0); f("moveInputWithCursor", !0, function (n, t) { t || (n.display.inputDiv.style.top = n.display.inputDiv.style.left = 0) }); f("tabindex", null, function (n, t) { n.display.input.tabIndex = t || "" }); f("autofocus", null); oh = t.modes = {}; vr = t.mimeModes = {}; t.defineMode = function (n, i) { if (t.defaults.mode || n == "null" || (t.defaults.mode = n), arguments.length > 2) { i.dependencies = []; for (var r = 2; r < arguments.length; ++r) i.dependencies.push(arguments[r]) } oh[n] = i }; t.defineMIME = function (n, t) { vr[n] = t }; t.resolveMode = function (n) { if (typeof n == "string" && vr.hasOwnProperty(n)) n = vr[n]; else if (n && typeof n.name == "string" && vr.hasOwnProperty(n.name)) { var i = vr[n.name]; typeof i == "string" && (i = { name: i }); n = up(i, n); n.name = i.name } else if (typeof n == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(n)) return t.resolveMode("application/xml"); return typeof n == "string" ? { name: n } : n || { name: "null" } }; t.getMode = function (n, i) { var i = t.resolveMode(i), e = oh[i.name], u, f, r; if (!e) return t.getMode(n, "text/plain"); if (u = e(n, i), yr.hasOwnProperty(i.name)) { f = yr[i.name]; for (r in f) f.hasOwnProperty(r) && (u.hasOwnProperty(r) && (u["_" + r] = u[r]), u[r] = f[r]) } if (u.name = i.name, i.helperType && (u.helperType = i.helperType), i.modeProps) for (r in i.modeProps) u[r] = i.modeProps[r]; return u }; t.defineMode("null", function () { return { token: function (n) { n.skipToEnd() } } }); t.defineMIME("text/plain", "null"); yr = t.modeExtensions = {}; t.extendMode = function (n, t) { var i = yr.hasOwnProperty(n) ? yr[n] : yr[n] = {}; vf(t, i) }; t.defineExtension = function (n, i) { t.prototype[n] = i }; t.defineDocExtension = function (n, t) { tt.prototype[n] = t }; t.defineOption = f; ge = []; t.defineInitHook = function (n) { ge.push(n) }; hi = t.helpers = {}; t.registerHelper = function (n, i, r) { hi.hasOwnProperty(n) || (hi[n] = t[n] = { _global: [] }); hi[n][i] = r }; t.registerGlobalHelper = function (n, i, r, u) { t.registerHelper(n, i, u); hi[n]._global.push({ pred: r, val: u }) }; pr = t.copyState = function (n, t) { var r, u, i; if (t === !0) return t; if (n.copyState) return n.copyState(t); r = {}; for (u in t) i = t[u], i instanceof Array && (i = i.concat([])), r[u] = i; return r }; ov = t.startState = function (n, t, i) { return n.startState ? n.startState(t, i) : !0 }; t.innerMode = function (n, t) { while (n.innerMode) { var i = n.innerMode(t); if (!i || i.mode == n) break; t = i.state; n = i.mode } return i || { mode: n, state: t } }; bu = t.commands = { selectAll: function (t) { t.setSelection(n(t.firstLine(), 0), n(t.lastLine()), ai) }, singleSelection: function (n) { n.setSelection(n.getCursor("anchor"), n.getCursor("head"), ai) }, killLine: function (t) { ar(t, function (i) { if (i.empty()) { var u = r(t.doc, i.head.line).text.length; return i.head.ch == u && i.head.line < t.lastLine() ? { from: i.head, to: n(i.head.line + 1, 0) } : { from: i.head, to: n(i.head.line, u) } } return { from: i.from(), to: i.to() } }) }, deleteLine: function (t) { ar(t, function (i) { return { from: n(i.from().line, 0), to: u(t.doc, n(i.to().line + 1, 0)) } }) }, delLineLeft: function (t) { ar(t, function (t) { return { from: n(t.from().line, 0), to: t.from() } }) }, delWrappedLineLeft: function (n) { ar(n, function (t) { var i = n.charCoords(t.head, "div").top + 5, r = n.coordsChar({ left: 0, top: i }, "div"); return { from: r, to: t.from() } }) }, delWrappedLineRight: function (n) { ar(n, function (t) { var i = n.charCoords(t.head, "div").top + 5, r = n.coordsChar({ left: n.display.lineDiv.offsetWidth + 100, top: i }, "div"); return { from: t.from(), to: r } }) }, undo: function (n) { n.undo() }, redo: function (n) { n.redo() }, undoSelection: function (n) { n.undoSelection() }, redoSelection: function (n) { n.redoSelection() }, goDocStart: function (t) { t.extendSelection(n(t.firstLine(), 0)) }, goDocEnd: function (t) { t.extendSelection(n(t.lastLine())) }, goLineStart: function (n) { n.extendSelectionsBy(function (t) { return lp(n, t.head.line) }, { origin: "+move", bias: 1 }) }, goLineStartSmart: function (n) { n.extendSelectionsBy(function (t) { return ap(n, t.head) }, { origin: "+move", bias: 1 }) }, goLineEnd: function (n) { n.extendSelectionsBy(function (t) { return pd(n, t.head.line) }, { origin: "+move", bias: -1 }) }, goLineRight: function (n) { n.extendSelectionsBy(function (t) { var i = n.charCoords(t.head, "div").top + 5; return n.coordsChar({ left: n.display.lineDiv.offsetWidth + 100, top: i }, "div") }, cf) }, goLineLeft: function (n) { n.extendSelectionsBy(function (t) { var i = n.charCoords(t.head, "div").top + 5; return n.coordsChar({ left: 0, top: i }, "div") }, cf) }, goLineLeftSmart: function (n) { n.extendSelectionsBy(function (t) { var r = n.charCoords(t.head, "div").top + 5, i = n.coordsChar({ left: 0, top: r }, "div"); return i.ch < n.getLine(i.line).search(/\S/) ? ap(n, t.head) : i }, cf) }, goLineUp: function (n) { n.moveV(-1, "line") }, goLineDown: function (n) { n.moveV(1, "line") }, goPageUp: function (n) { n.moveV(-1, "page") }, goPageDown: function (n) { n.moveV(1, "page") }, goCharLeft: function (n) { n.moveH(-1, "char") }, goCharRight: function (n) { n.moveH(1, "char") }, goColumnLeft: function (n) { n.moveH(-1, "column") }, goColumnRight: function (n) { n.moveH(1, "column") }, goWordLeft: function (n) { n.moveH(-1, "word") }, goGroupRight: function (n) { n.moveH(1, "group") }, goGroupLeft: function (n) { n.moveH(-1, "group") }, goWordRight: function (n) { n.moveH(1, "word") }, delCharBefore: function (n) { n.deleteH(-1, "char") }, delCharAfter: function (n) { n.deleteH(1, "char") }, delWordBefore: function (n) { n.deleteH(-1, "word") }, delWordAfter: function (n) { n.deleteH(1, "word") }, delGroupBefore: function (n) { n.deleteH(-1, "group") }, delGroupAfter: function (n) { n.deleteH(1, "group") }, indentAuto: function (n) { n.indentSelection("smart") }, indentMore: function (n) { n.indentSelection("add") }, indentLess: function (n) { n.indentSelection("subtract") }, insertTab: function (n) { n.replaceSelection("\t") }, insertSoftTab: function (n) { for (var r, e, u = [], f = n.listSelections(), t = n.options.tabSize, i = 0; i < f.length; i++) r = f[i].from(), e = ft(n.getLine(r.line), r.ch, t), u.push(new Array(t - e % t + 1).join(" ")); n.replaceSelections(u) }, defaultTab: function (n) { n.somethingSelected() ? n.indentSelection("add") : n.execCommand("insertTab") }, transposeChars: function (t) { ni(t, function () { for (var i, u, f, o = t.listSelections(), s = [], e = 0; e < o.length; e++) i = o[e].head, u = r(t.doc, i.line).text, u && (i.ch == u.length && (i = new n(i.line, i.ch - 1)), i.ch > 0 ? (i = new n(i.line, i.ch + 1), t.replaceRange(u.charAt(i.ch - 1) + u.charAt(i.ch - 2), n(i.line, i.ch - 2), i, "+transpose")) : i.line > t.doc.first && (f = r(t.doc, i.line - 1).text, f && t.replaceRange(u.charAt(0) + "\n" + f.charAt(f.length - 1), n(i.line - 1, f.length - 1), n(i.line, 1), "+transpose"))), s.push(new c(i, i)); t.setSelections(s) }) }, newlineAndIndent: function (n) { ni(n, function () { for (var t, r = n.listSelections().length, i = 0; i < r; i++) t = n.listSelections()[i], n.replaceRange("\n", t.anchor, t.head, "+input"), n.indentLine(t.from().line + 1, null, !0), lr(n) }) }, toggleOverwrite: function (n) { n.toggleOverwrite() } }; at = t.keyMap = {}; at.basic = { Left: "goCharLeft", Right: "goCharRight", Up: "goLineUp", Down: "goLineDown", End: "goLineEnd", Home: "goLineStartSmart", PageUp: "goPageUp", PageDown: "goPageDown", Delete: "delCharAfter", Backspace: "delCharBefore", "Shift-Backspace": "delCharBefore", Tab: "defaultTab", "Shift-Tab": "indentAuto", Enter: "newlineAndIndent", Insert: "toggleOverwrite", Esc: "singleSelection" }; at.pcDefault = { "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo", "Ctrl-Home": "goDocStart", "Ctrl-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd", "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd", "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find", "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll", "Ctrl-[": "indentLess", "Ctrl-]": "indentMore", "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection", fallthrough: "basic" }; at.macDefault = { "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo", "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft", "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore", "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find", "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll", "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight", "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", fallthrough: ["basic", "emacsy"] }; at.emacsy = { "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown", "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars" }; at["default"] = ot ? at.macDefault : at.pcDefault; var no = t.lookupKey = function (n, t, i) { function u(t) { var f, r, e, o; if (t = sh(t), f = t[n], f === !1) return "stop"; if (f != null && i(f)) return !0; if (t.nofallthrough) return "stop"; if (r = t.fallthrough, r == null) return !1; if (Object.prototype.toString.call(r) != "[object Array]") return u(r); for (e = 0; e < r.length; ++e) if (o = u(r[e]), o) return o; return !1 } for (var f, r = 0; r < t.length; ++r) if (f = u(t[r]), f) return f != "stop" }, ik = t.isModifierKey = function (n) { var t = fi[n.keyCode]; return t == "Ctrl" || t == "Alt" || t == "Shift" || t == "Mod" }, rk = t.keyName = function (n, t) { if (et && n.keyCode == 34 && n.char) return !1; var i = fi[n.keyCode]; return i == null || n.altGraphKey ? !1 : (n.altKey && (i = "Alt-" + i), (yc ? n.metaKey : n.ctrlKey) && (i = "Ctrl-" + i), (yc ? n.ctrlKey : n.metaKey) && (i = "Cmd-" + i), !t && n.shiftKey && (i = "Shift-" + i), i) }; t.fromTextArea = function (n, i) { function f() { n.value = r.getValue() } var o, u, s, h, r; if (i || (i = {}), i.value = n.value, !i.tabindex && n.tabindex && (i.tabindex = n.tabindex), !i.placeholder && n.placeholder && (i.placeholder = n.placeholder), i.autofocus == null && (o = vi(), i.autofocus = o == n || n.getAttribute("autofocus") != null && o == document.body), n.form && (e(n.form, "submit", f), !i.leaveSubmitMethodAlone)) { u = n.form; s = u.submit; try { h = u.submit = function () { f(); u.submit = s; u.submit(); u.submit = h } } catch (c) { } } return n.style.display = "none", r = t(function (t) { n.parentNode.insertBefore(t, n.nextSibling) }, i), r.save = f, r.getTextArea = function () { return n }, r.toTextArea = function () { f(); n.parentNode.removeChild(r.getWrapperElement()); n.style.display = ""; n.form && (ui(n.form, "submit", f), typeof n.form.submit == "function" && (n.form.submit = s)) }, r }; ku = t.StringStream = function (n, t) { this.pos = this.start = 0; this.string = n; this.tabSize = t || 8; this.lastColumnPos = this.lastColumnValue = 0; this.lineStart = 0 }; ku.prototype = { eol: function () { return this.pos >= this.string.length }, sol: function () { return this.pos == this.lineStart }, peek: function () { return this.string.charAt(this.pos) || undefined }, next: function () { if (this.pos < this.string.length) return this.string.charAt(this.pos++) }, eat: function (n) { var t = this.string.charAt(this.pos), i; return i = typeof n == "string" ? t == n : t && (n.test ? n.test(t) : n(t)), i ? (++this.pos, t) : void 0 }, eatWhile: function (n) { for (var t = this.pos; this.eat(n) ;); return this.pos > t }, eatSpace: function () { for (var n = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)) ;)++this.pos; return this.pos > n }, skipToEnd: function () { this.pos = this.string.length }, skipTo: function (n) { var t = this.string.indexOf(n, this.pos); if (t > -1) return this.pos = t, !0 }, backUp: function (n) { this.pos -= n }, column: function () { return this.lastColumnPos < this.start && (this.lastColumnValue = ft(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? ft(this.string, this.lineStart, this.tabSize) : 0) }, indentation: function () { return ft(this.string, null, this.tabSize) - (this.lineStart ? ft(this.string, this.lineStart, this.tabSize) : 0) }, match: function (n, t, i) { var u, f, r; if (typeof n == "string") { if (u = function (n) { return i ? n.toLowerCase() : n }, f = this.string.substr(this.pos, n.length), u(f) == u(n)) return t !== !1 && (this.pos += n.length), !0 } else return (r = this.string.slice(this.pos).match(n), r && r.index > 0) ? null : (r && t !== !1 && (this.pos += r[0].length), r) }, current: function () { return this.string.slice(this.start, this.pos) }, hideFirstChars: function (n, t) { this.lineStart += n; try { return t() } finally { this.lineStart -= n } } }; ci = t.TextMarker = function (n, t) { this.lines = []; this.type = t; this.doc = n }; kr(ci); ci.prototype.clear = function () { var n, e, u, f, o, t, r, i, s, h; if (!this.explicitlyCleared) { for (n = this.doc.cm, e = n && !n.curOp, e && er(n), st(this, "clear") && (u = this.find(), u && b(this, "clear", u.from, u.to)), f = null, o = null, i = 0; i < this.lines.length; ++i) t = this.lines[i], r = gu(t.markedSpans, this), n && !this.collapsed ? ti(n, a(t), "text") : n && (r.to != null && (o = a(t)), r.from != null && (f = a(t))), t.markedSpans = ok(t.markedSpans, r), r.from == null && this.collapsed && !tr(this.doc, t) && n && yt(t, ki(n.display)); if (n && this.collapsed && !n.options.lineWrapping) for (i = 0; i < this.lines.length; ++i) s = vt(this.lines[i]), h = bf(s), h > n.display.maxLineLength && (n.display.maxLine = s, n.display.maxLineLength = h, n.display.maxLineChanged = !0); f != null && n && this.collapsed && rt(n, f, o + 1); this.lines.length = 0; this.explicitlyCleared = !0; this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, n && yl(n.doc)); n && b(n, "markerCleared", n, this); e && or(n); this.parent && this.parent.clear() } }; ci.prototype.find = function (t, i) { var f, o, e, r, u; for (t == null && this.type == "bookmark" && (t = 1), e = 0; e < this.lines.length; ++e) { if (r = this.lines[e], u = gu(r.markedSpans, this), u.from != null && (f = n(i ? r : a(r), u.from), t == -1)) return f; if (u.to != null && (o = n(i ? r : a(r), u.to), t == 1)) return o } return f && { from: f, to: o } }; ci.prototype.changed = function () { var i = this.find(-1, !0), t = this, n = this.doc.cm; i && n && ni(n, function () { var r = i.line, o = a(i.line), f = gl(n, o), e, u; f && (ta(f), n.curOp.selectionChanged = n.curOp.forceUpdate = !0); n.curOp.updateMaxLine = !0; tr(t.doc, r) || t.height == null || (e = t.height, t.height = null, u = rf(t) - e, u && yt(r, r.height + u)) }) }; ci.prototype.attachLine = function (n) { if (!this.lines.length && this.doc.cm) { var t = this.doc.cm.curOp; t.maybeHiddenMarkers && k(t.maybeHiddenMarkers, this) != -1 || (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this) } this.lines.push(n) }; ci.prototype.detachLine = function (n) { if (this.lines.splice(k(this.lines, n), 1), !this.lines.length && this.doc.cm) { var t = this.doc.cm.curOp; (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this) } }; sv = 0; du = t.SharedTextMarker = function (n, t) { this.markers = n; this.primary = t; for (var i = 0; i < n.length; ++i) n[i].parent = this }; kr(du); du.prototype.clear = function () { if (!this.explicitlyCleared) { this.explicitlyCleared = !0; for (var n = 0; n < this.markers.length; ++n) this.markers[n].clear(); b(this, "clear") } }; du.prototype.find = function (n, t) { return this.primary.find(n, t) }; tf = t.LineWidget = function (n, t, i) { if (i) for (var r in i) i.hasOwnProperty(r) && (this[r] = i[r]); this.cm = n; this.node = t }; kr(tf); tf.prototype.clear = function () { var r = this.cm, n = this.line.widgets, t = this.line, f = a(t), i, u; if (f != null && n) { for (i = 0; i < n.length; ++i) n[i] == this && n.splice(i--, 1); n.length || (t.widgets = null); u = rf(this); ni(r, function () { dv(r, t, -u); ti(r, f, "widget"); yt(t, Math.max(0, t.height - u)) }) } }; tf.prototype.changed = function () { var r = this.height, t = this.cm, i = this.line, n; (this.height = null, n = rf(this) - r, n) && ni(t, function () { t.curOp.forceUpdate = !0; dv(t, i, n); yt(i, i.height + n) }) }; li = t.Line = function (n, t, i) { this.text = n; vv(this, t); this.height = i ? i(this) : 1 }; kr(li); li.prototype.lineNo = function () { return a(this) }; uy = {}; fy = {}; uf.prototype = { chunkSize: function () { return this.lines.length }, removeInner: function (n, t) { for (var r, i = n, u = n + t; i < u; ++i) r = this.lines[i], this.height -= r.height, pk(r), b(r, "delete"); this.lines.splice(n, t) }, collapse: function (n) { n.push.apply(n, this.lines) }, insertInner: function (n, t, i) { this.height += i; this.lines = this.lines.slice(0, n).concat(t).concat(this.lines.slice(n)); for (var r = 0; r < t.length; ++r) t[r].parent = this }, iterN: function (n, t, i) { for (var r = n + t; n < r; ++n) if (i(this.lines[n])) return !0 } }; ff.prototype = { chunkSize: function () { return this.size }, removeInner: function (n, t) { var r, i, u, f, o, e; for (this.size -= t, r = 0; r < this.children.length; ++r) if (i = this.children[r], u = i.chunkSize(), n < u) { if (f = Math.min(t, u - n), o = i.height, i.removeInner(n, f), this.height -= o - i.height, u == f && (this.children.splice(r--, 1), i.parent = null), (t -= f) == 0) break; n = 0 } else n -= u; this.size - t < 25 && (this.children.length > 1 || !(this.children[0] instanceof uf)) && (e = [], this.collapse(e), this.children = [new uf(e)], this.children[0].parent = this) }, collapse: function (n) { for (var t = 0; t < this.children.length; ++t) this.children[t].collapse(n) }, insertInner: function (n, t, i) { var u, r, e, o, f; for (this.size += t.length, this.height += i, u = 0; u < this.children.length; ++u) { if (r = this.children[u], e = r.chunkSize(), n <= e) { if (r.insertInner(n, t, i), r.lines && r.lines.length > 50) { while (r.lines.length > 50) o = r.lines.splice(r.lines.length - 25, 25), f = new uf(o), r.height -= f.height, this.children.splice(u + 1, 0, f), f.parent = this; this.maybeSpill() } break } n -= e } }, maybeSpill: function () { var n, r, t, i, u; if (!(this.children.length <= 10)) { n = this; do r = n.children.splice(n.children.length - 5, 5), t = new ff(r), n.parent ? (n.size -= t.size, n.height -= t.height, u = k(n.parent.children, n), n.parent.children.splice(u + 1, 0, t)) : (i = new ff(n.children), i.parent = n, n.children = [i, t], n = i), t.parent = n.parent; while (n.children.length > 10); n.parent.maybeSpill() } }, iterN: function (n, t, i) { for (var f, u, e, r = 0; r < this.children.length; ++r) if (f = this.children[r], u = f.chunkSize(), n < u) { if (e = Math.min(t, u - n), f.iterN(n, e, i)) return !0; if ((t -= e) == 0) break; n = 0 } else n -= u } }; cy = 0; tt = t.Doc = function (t, i, r) { if (!(this instanceof tt)) return new tt(t, i, r); r == null && (r = 0); ff.call(this, [new uf([new li("", null)])]); this.first = r; this.scrollTop = this.scrollLeft = 0; this.cantEdit = !1; this.cleanGeneration = 1; this.frontier = r; var u = n(r, 0); this.sel = wi(u); this.history = new uo(null); this.id = ++cy; this.modeOption = i; typeof t == "string" && (t = fr(t)); yh(this, { from: u, to: u, text: t }); g(this, wi(u), ai) }; tt.prototype = up(ff.prototype, { constructor: tt, iter: function (n, t, i) { i ? this.iterN(n - this.first, t - n, i) : this.iterN(this.first, this.first + this.size, n) }, insert: function (n, t) { for (var r = 0, i = 0; i < t.length; ++i) r += t[i].height; this.insertInner(n - this.first, t, r) }, remove: function (n, t) { this.removeInner(n - this.first, t) }, getValue: function (n) { var t = ph(this, this.first, this.first + this.size); return n === !1 ? t : t.join(n || "\n") }, setValue: nt(function (t) { var i = n(this.first, 0), u = this.first + this.size - 1; cr(this, { from: i, to: n(u, r(this, u).text.length), text: fr(t), origin: "setValue" }, !0); g(this, wi(i)) }), replaceRange: function (n, t, i, r) { t = u(this, t); i = i ? u(this, i) : t; we(this, n, t, i, r) }, getRange: function (n, t, i) { var r = of(this, u(this, n), u(this, t)); return i === !1 ? r : r.join(i || "\n") }, getLine: function (n) { var t = this.getLineHandle(n); return t && t.text }, getLineHandle: function (n) { if (uu(this, n)) return r(this, n) }, getLineNumber: function (n) { return a(n) }, getLineHandleVisualStart: function (n) { return typeof n == "number" && (n = r(this, n)), vt(n) }, lineCount: function () { return this.size }, firstLine: function () { return this.first }, lastLine: function () { return this.first + this.size - 1 }, clipPos: function (n) { return u(this, n) }, getCursor: function (n) { var t = this.sel.primary(); return n == null || n == "head" ? t.head : n == "anchor" ? t.anchor : n == "end" || n == "to" || n === !1 ? t.to() : t.from() }, listSelections: function () { return this.sel.ranges }, somethingSelected: function () { return this.sel.somethingSelected() }, setCursor: nt(function (t, i, r) { ll(this, u(this, typeof t == "number" ? n(t, i || 0) : t), null, r) }), setSelection: nt(function (n, t, i) { ll(this, u(this, n), u(this, t || n), i) }), extendSelection: nt(function (n, t, i) { gf(this, u(this, n), t && u(this, t), i) }), extendSelections: nt(function (n, t) { cl(this, hw(this, n, t)) }), extendSelectionsBy: nt(function (n, t) { cl(this, af(this.sel.ranges, n), t) }), setSelections: nt(function (n, t, i) { if (n.length) { for (var r = 0, f = []; r < n.length; r++) f[r] = new c(u(this, n[r].anchor), u(this, n[r].head)); t == null && (t = Math.min(n.length - 1, this.sel.primIndex)); g(this, ct(f, t), i) } }), addSelection: nt(function (n, t, i) { var r = this.sel.ranges.slice(0); r.push(new c(u(this, n), u(this, t || n))); g(this, ct(r, r.length - 1), i) }), getSelection: function (n) { for (var u, r = this.sel.ranges, t, i = 0; i < r.length; i++) u = of(this, r[i].from(), r[i].to()), t = t ? t.concat(u) : u; return n === !1 ? t : t.join(n || "\n") }, getSelections: function (n) { for (var i, u = [], r = this.sel.ranges, t = 0; t < r.length; t++) i = of(this, r[t].from(), r[t].to()), n !== !1 && (i = i.join(n || "\n")), u[t] = i; return u }, replaceSelection: function (n, t, i) { for (var u = [], r = 0; r < this.sel.ranges.length; r++) u[r] = n; this.replaceSelections(u, t, i || "+input") }, replaceSelections: nt(function (n, t, i) { for (var f, e, u = [], o = this.sel, r = 0; r < o.ranges.length; r++) f = o.ranges[r], u[r] = { from: f.from(), to: f.to(), text: fr(n[r]), origin: i }; for (e = t && t != "end" && kb(this, u, t), r = u.length - 1; r >= 0; r--) cr(this, u[r]); e ? al(this, e) : this.cm && lr(this.cm) }), undo: nt(function () { pe(this, "undo") }), redo: nt(function () { pe(this, "redo") }), undoSelection: nt(function () { pe(this, "undo", !0) }), redoSelection: nt(function () { pe(this, "redo", !0) }), setExtending: function (n) { this.extend = n }, getExtending: function () { return this.extend }, historySize: function () { for (var t = this.history, i = 0, r = 0, n = 0; n < t.done.length; n++) t.done[n].ranges || ++i; for (n = 0; n < t.undone.length; n++) t.undone[n].ranges || ++r; return { undo: i, redo: r } }, clearHistory: function () { this.history = new uo(this.history.maxGeneration) }, markClean: function () { this.cleanGeneration = this.changeGeneration(!0) }, changeGeneration: function (n) { return n && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation }, isClean: function (n) { return this.history.generation == (n || this.cleanGeneration) }, getHistory: function () { return { done: br(this.history.done), undone: br(this.history.undone) } }, setHistory: function (n) { var t = this.history = new uo(this.history.maxGeneration); t.done = br(n.done.slice(0), null, !0); t.undone = br(n.undone.slice(0), null, !0) }, addLineClass: nt(function (n, t, i) { return de(this, n, "class", function (n) { var r = t == "text" ? "textClass" : t == "background" ? "bgClass" : "wrapClass"; if (n[r]) { if (new RegExp("(?:^|\\s)" + i + "(?:$|\\s)").test(n[r])) return !1; n[r] += " " + i } else n[r] = i; return !0 }) }), removeLineClass: nt(function (n, t, i) { return de(this, n, "class", function (n) { var f = t == "text" ? "textClass" : t == "background" ? "bgClass" : "wrapClass", u = n[f], r, e; if (u) if (i == null) n[f] = null; else { if (r = u.match(new RegExp("(?:^|\\s+)" + i + "(?:$|\\s+)")), !r) return !1; e = r.index + r[0].length; n[f] = u.slice(0, r.index) + (!r.index || e == u.length ? "" : " ") + u.slice(e) || null } else return !1; return !0 }) }), markText: function (n, t, i) { return wr(this, u(this, n), u(this, t), i, "range") }, setBookmark: function (n, t) { var i = { replacedWith: t && (t.nodeType == null ? t.widget : t), insertLeft: t && t.insertLeft, clearWhenEmpty: !1, shared: t && t.shared }; return n = u(this, n), wr(this, n, n, i, "bookmark") }, findMarksAt: function (n) { var e, i, f, t; if (n = u(this, n), e = [], i = r(this, n.line).markedSpans, i) for (f = 0; f < i.length; ++f) t = i[f], (t.from == null || t.from <= n.ch) && (t.to == null || t.to >= n.ch) && e.push(t.marker.parent || t.marker); return e }, findMarks: function (n, t, i) { n = u(this, n); t = u(this, t); var f = [], r = n.line; return this.iter(n.line, t.line + 1, function (u) { var s = u.markedSpans, o, e; if (s) for (o = 0; o < s.length; o++) e = s[o], r == n.line && n.ch > e.to || e.from == null && r != n.line || r == t.line && e.from > t.ch || i && !i(e.marker) || f.push(e.marker.parent || e.marker); ++r }), f }, getAllMarks: function () { var n = []; return this.iter(function (t) { var r = t.markedSpans, i; if (r) for (i = 0; i < r.length; ++i) r[i].from != null && n.push(r[i].marker) }), n }, posFromIndex: function (t) { var i, r = this.first; return this.iter(function (n) { var u = n.text.length + 1; if (u > t) return i = t, !0; t -= u; ++r }), u(this, n(r, i)) }, indexFromPos: function (n) { n = u(this, n); var t = n.ch; return n.line < this.first || n.ch < 0 ? 0 : (this.iter(this.first, n.line, function (n) { t += n.text.length + 1 }), t) }, copy: function (n) { var t = new tt(ph(this, this.first, this.first + this.size), this.modeOption, this.first); return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = this.sel, t.extend = !1, n && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t }, linkedDoc: function (n) { var i, r, t; return n || (n = {}), i = this.first, r = this.first + this.size, n.from != null && n.from > i && (i = n.from), n.to != null && n.to < r && (r = n.to), t = new tt(ph(this, i, r), n.mode || this.modeOption, i), n.sharedHist && (t.history = this.history), (this.linked || (this.linked = [])).push({ doc: t, sharedHist: n.sharedHist }), t.linked = [{ doc: this, isParent: !0, sharedHist: n.sharedHist }], fk(t, hv(this)), t }, unlinkDoc: function (n) { var i, u, r; if (n instanceof t && (n = n.doc), this.linked) for (i = 0; i < this.linked.length; ++i) if (u = this.linked[i], u.doc == n) { this.linked.splice(i, 1); n.unlinkDoc(this); ek(hv(this)); break } n.history == this.history && (r = [n.id], ir(n, function (n) { r.push(n.id) }, !0), n.history = new uo(null), n.history.done = br(this.history.done, r), n.history.undone = br(this.history.undone, r)) }, iterLinkedDocs: function (n) { ir(this, n) }, getMode: function () { return this.mode }, getEditor: function () { return this.cm } }); tt.prototype.eachLine = tt.prototype.iter; ly = "iter insert remove copy getEditor".split(" "); for (ef in tt.prototype) tt.prototype.hasOwnProperty(ef) && k(ly, ef) < 0 && (t.prototype[ef] = function (n) { return function () { return n.apply(this.doc, arguments) } }(tt.prototype[ef])); kr(tt); d = t.e_preventDefault = function (n) { n.preventDefault ? n.preventDefault() : n.returnValue = !1 }; dy = t.e_stopPropagation = function (n) { n.stopPropagation ? n.stopPropagation() : n.cancelBubble = !0 }; eo = t.e_stop = function (n) { d(n); dy(n) }; var e = t.on = function (n, t, i) { if (n.addEventListener) n.addEventListener(t, i, !1); else if (n.attachEvent) n.attachEvent("on" + t, i); else { var r = n._handlers || (n._handlers = {}), u = r[t] || (r[t] = []); u.push(i) } }, ui = t.off = function (n, t, i) { var r, u; if (n.removeEventListener) n.removeEventListener(t, i, !1); else if (n.detachEvent) n.detachEvent("on" + t, i); else { if (r = n._handlers && n._handlers[t], !r) return; for (u = 0; u < r.length; ++u) if (r[u] == i) { r.splice(u, 1); break } } }, y = t.signal = function (n, t) { var r = n._handlers && n._handlers[t], u, i; if (r) for (u = Array.prototype.slice.call(arguments, 2), i = 0; i < r.length; ++i) r[i].apply(null, u) }, hf = null; var bt = 30, tp = t.Pass = { toString: function () { return "CodeMirror.Pass" } }, ai = { scroll: !1 }, kh = { origin: "*mouse" }, cf = { origin: "+move" }; dh.prototype.set = function (n, t) { clearTimeout(this.id); this.id = setTimeout(t, n) }; ft = t.countColumn = function (n, t, i, r, u) { var f, e, o; for (t == null && (t = n.search(/[^\s\u00a0]/), t == -1 && (t = n.length)), f = r || 0, e = u || 0; ;) { if (o = n.indexOf("\t", f), o < 0 || o >= t) return e + (t - f); e += o - f; e += i - e % i; f = o + 1 } }; lf = [""]; dr = function (n) { n.select() }; tu ? dr = function (n) { n.selectionStart = 0; n.selectionEnd = n.value.length } : s && (dr = function (n) { try { n.select() } catch (t) { } });[].indexOf && (k = function (n, t) { return n.indexOf(t) });[].map && (af = function (n, t) { return n.map(t) }); fp = /[\u00df\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/; gh = t.isWordChar = function (n) { return /\w/.test(n) || n > "" && (n.toUpperCase() != n.toLowerCase() || fp.test(n)) }; op = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/; gr = document.createRange ? function (n, t, i) { var r = document.createRange(); return r.setEnd(n, i), r.setStart(n, t), r } : function (n, t, i) { var r = document.body.createTextRange(); return r.moveToElementText(n.parentNode), r.collapse(!0), r.moveEnd("character", i), r.moveStart("character", t), r }; s && h < 11 && (vi = function () { try { return document.activeElement } catch (n) { return document.body } }); ic = !1; hp = function () { if (s && h < 9) return !1; var n = i("div"); return "draggable" in n || "dragDrop" in n }(); var fr = t.splitLines = "\n\nb".split(/\n/).length != 3 ? function (n) { for (var i = 0, f = [], e = n.length, t, r, u; i <= e;) t = n.indexOf("\n", i), t == -1 && (t = n.length), r = n.slice(i, n.charAt(t - 1) == "\r" ? t - 1 : t), u = r.indexOf("\r"), u != -1 ? (f.push(r.slice(0, u)), i += u + 1) : (f.push(r), i = t + 1); return f } : function (n) { return n.split(/\r\n?|\n/) }, ad = window.getSelection ? function (n) { try { return n.selectionStart != n.selectionEnd } catch (t) { return !1 } } : function (n) { try { var t = n.ownerDocument.selection.createRange() } catch (i) { } return !t || t.parentElement() != n ? !1 : t.compareEndPoints("StartToEnd", t) != 0 }, cp = function () { var n = i("div"); return "oncopy" in n ? !0 : (n.setAttribute("oncopy", "return;"), typeof n.oncopy == "function") }(), fc = null; return fi = { 3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete", 63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert" }, t.keyNames = fi, function () { for (var n = 0; n < 10; n++) fi[n + 48] = fi[n + 96] = String(n); for (n = 65; n <= 90; n++) fi[n] = String.fromCharCode(n); for (n = 1; n <= 12; n++) fi[n + 111] = fi[n + 63235] = "F" + n }(), yp = function () { function s(n) { return n <= 247 ? e.charAt(n) : 1424 <= n && n <= 1524 ? "R" : 1536 <= n && n <= 1773 ? o.charAt(n - 1536) : 1774 <= n && n <= 2220 ? "r" : 8192 <= n && n <= 8203 ? "w" : n == 8204 ? "b" : "L" } function n(n, t, i) { this.level = n; this.from = t; this.to = i } var e = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", o = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm", h = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, i = /[stwN]/, r = /[LRr]/, u = /[Lb1n]/, f = /[1n]/, t = "L"; return function (e) { var y, c, b, tt, d, v, w, p, g, o, it, k, nt, a, rt; if (!h.test(e)) return !1; for (y = e.length, c = [], o = 0; o < y; ++o) c.push(v = s(e.charCodeAt(o))); for (o = 0, b = t; o < y; ++o) v = c[o], v == "m" ? c[o] = b : b = v; for (o = 0, d = t; o < y; ++o) v = c[o], v == "1" && d == "r" ? c[o] = "n" : r.test(v) && (d = v, v == "r" && (c[o] = "R")); for (o = 1, b = c[0]; o < y - 1; ++o) v = c[o], v == "+" && b == "1" && c[o + 1] == "1" ? c[o] = "1" : v == "," && b == c[o + 1] && (b == "1" || b == "n") && (c[o] = b), b = v; for (o = 0; o < y; ++o) if (v = c[o], v == ",") c[o] = "N"; else if (v == "%") { for (w = o + 1; w < y && c[w] == "%"; ++w); for (tt = o && c[o - 1] == "!" || w < y && c[w] == "1" ? "1" : "N", a = o; a < w; ++a) c[a] = tt; o = w - 1 } for (o = 0, d = t; o < y; ++o) v = c[o], d == "L" && v == "1" ? c[o] = "L" : r.test(v) && (d = v); for (o = 0; o < y; ++o) if (i.test(c[o])) { for (w = o + 1; w < y && i.test(c[w]) ; ++w); var ut = (o ? c[o - 1] : t) == "L", ft = (w < y ? c[w] : t) == "L", tt = ut || ft ? "L" : "R"; for (a = o; a < w; ++a) c[a] = tt; o = w - 1 } for (p = [], o = 0; o < y;) if (u.test(c[o])) { for (it = o, ++o; o < y && u.test(c[o]) ; ++o); p.push(new n(0, it, o)) } else { for (k = o, nt = p.length, ++o; o < y && c[o] != "L"; ++o); for (a = k; a < o;) if (f.test(c[a])) { for (k < a && p.splice(nt, 0, new n(1, k, a)), rt = a, ++a; a < o && f.test(c[a]) ; ++a); p.splice(nt, 0, new n(2, rt, a)); k = a } else ++a; k < o && p.splice(nt, 0, new n(1, k, o)) } return p[0].level == 1 && (g = e.match(/^\s+/)) && (p[0].from = g[0].length, p.unshift(new n(0, 0, g[0].length))), l(p).level == 1 && (g = e.match(/\s+$/)) && (l(p).to -= g[0].length, p.push(new n(0, y - g[0].length, y))), p[0].level != l(p).level && p.push(new n(p[0].level, y, y)), p } }(), t.version = "4.5.0", t });
//# sourceMappingURL=codemirror.min.js.map